   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB14:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 141:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 145:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 146:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 147:../uvc.c      **** };
 148:../uvc.c      **** 
 149:../uvc.c      **** 
 150:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 151:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 152:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 154:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 155:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 156:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 157:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 158:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 159:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 160:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 161:../uvc.c      ****                                    with adjustable compression parameters */
 162:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 163:../uvc.c      ****                                    streaming with adjustable compression parameters */
 164:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 165:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 170:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 171:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 173:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 174:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 175:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 176:../uvc.c      **** };
 177:../uvc.c      **** 
 178:../uvc.c      **** 
 179:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 180:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 181:../uvc.c      **** 
 182:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 183:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 184:../uvc.c      **** {
 185:../uvc.c      ****     0x0C,                               /* Header Length */
 186:../uvc.c      ****     0x8C,                               /* Bit field header field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 188:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 189:../uvc.c      **** };
 190:../uvc.c      **** 
 191:../uvc.c      **** CyBool_t glIsApplnActive = CyFalse;             /* Whether the Gpif->USB application is active or n
 192:../uvc.c      **** CyBool_t glIsConfigured = CyFalse;              /* Whether Application is in configured state or no
 193:../uvc.c      **** 
 194:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 195:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 196:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 197:../uvc.c      ****                                                            the current video frame. */
 198:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 199:../uvc.c      **** #ifndef CAM720
 200:../uvc.c      **** volatile static CyBool_t WDRflag = CyTrue;              /* the flag for WDR mode. It's initialized 
 201:../uvc.c      **** #else
 202:../uvc.c      **** volatile static CyBool_t WDRflag = CyFalse;
 203:../uvc.c      **** #endif
 204:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 205:../uvc.c      **** 
 206:../uvc.c      **** /************ control parameters array ***********
 207:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 208:../uvc.c      ****  *    e.g.
 209:../uvc.c      ****  *     1th D: backlight compensation, brightness, contrast, hue, saturation, sharpness, gamma, WBT,
 210:../uvc.c      ****  *     2nd D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 211:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 212:../uvc.c      ****  **************************************************/
 213:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 214:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 215:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 216:../uvc.c      **** #ifndef CAM720
 217:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 218:../uvc.c      **** #else
 219:../uvc.c      **** 		{/*0*/BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,
 220:../uvc.c      **** #endif
 221:../uvc.c      **** 		{/*1*/BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  63,     0, 1, 0, 3, 0, 31, 0, 
 222:../uvc.c      **** 		{/*2*/0x7/*ContrastReg*/  , 0x7/*ContrastReg*/   , 2,    16,   0,  64,     0, 1, 0, 3, 0, 40, 0, 
 223:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 224:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 225:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 226:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 227:../uvc.c      **** 		{/*7*/SharpnessReg        , SharpnessReg         , 2,    0,    0,   14,    0, 1, 0, 3, 0,   0, 0,
 228:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 229:../uvc.c      **** 		{/*9*/0x8/*WBModeReg*/    , 0x8/*WBModeReg*/     , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 230:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 231:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 232:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 233:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 234:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 235:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 237:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 238:../uvc.c      **** #ifndef CAM720
 239:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 240:../uvc.c      **** #else
 241:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 242:../uvc.c      **** #endif
 243:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 244:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 245:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 246:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 247:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 248:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 249:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  255,    0, 1, 0, 3, 0,   0,32
 250:../uvc.c      **** 		{/*1A*/AExReferleveReg0    , AExReferleveReg0     , 2,    0,    0,   63,    0, 1, 0, 3, 0,  32, 0
 251:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		/**********************************
 256:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 257:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 258:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 259:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 260:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 261:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 262:../uvc.c      **** 		 *
 263:../uvc.c      **** 		 *********************************/
 264:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 265:../uvc.c      **** };
 266:../uvc.c      **** 
 267:../uvc.c      **** #ifndef CAM720
 268:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 269:../uvc.c      **** #else
 270:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 271:../uvc.c      **** #endif
 272:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 273:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1280x960; 2:1280x720; 0:n/a
 274:../uvc.c      **** 
 275:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 276:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 277:../uvc.c      **** 
 278:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 279:../uvc.c      **** 
 280:../uvc.c      **** /*
 281:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 282:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 283:../uvc.c      ****  */
 284:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 285:../uvc.c      **** 		0xa0, 0x0f, 0xf, 0xf0
 286:../uvc.c      **** };
 287:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 288:../uvc.c      **** 		0
 289:../uvc.c      **** };
 290:../uvc.c      **** 
 291:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 292:../uvc.c      **** 
 293:../uvc.c      **** void I2CCmdHandler(){
 294:../uvc.c      **** ;
 295:../uvc.c      **** }
 296:../uvc.c      **** 
 297:../uvc.c      **** /************************************
 298:../uvc.c      ****  * set Iris mode
 299:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 300:../uvc.c      ****  */
 301:../uvc.c      **** 
 302:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 303:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 304:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 305:../uvc.c      ****     uint16_t readCount;
 306:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 307:../uvc.c      ****     uint8_t devAdd;
 308:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 309:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 310:../uvc.c      ****     	//RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 311:../uvc.c      ****         //RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 312:../uvc.c      ****         //devAdd = ExUCtrlParArry[locCtrlID][15];
 313:../uvc.c      ****         //Len = ExUCtrlParArry[locCtrlID][2];
 314:../uvc.c      ****     }else{
 315:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 316:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 317:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 318:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 319:../uvc.c      ****     }
 320:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 321:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 322:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 323:../uvc.c      **** #endif
 324:../uvc.c      ****     reqData = bRequest;
 325:../uvc.c      ****     /*
 326:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 327:../uvc.c      ****      */
 328:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 329:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 330:../uvc.c      ****     	goto EndofSet;
 331:../uvc.c      ****     }
 332:../uvc.c      ****     switch (bRequest)
 333:../uvc.c      **** 		 {
 334:../uvc.c      **** 
 335:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 336:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 337:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 338:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 339:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 340:../uvc.c      **** 			  break;
 341:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 342:../uvc.c      **** 
 343:../uvc.c      **** 			 switch(CtrlID)
 344:../uvc.c      **** 			 {
 345:../uvc.c      **** 				 case SaturCtlID6://TODO check sensor register
 346:../uvc.c      **** 				 default:
 347:../uvc.c      **** 
 348:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 349:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 350:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 351:../uvc.c      **** 		 	 		 }else{
 352:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 353:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 354:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 355:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 356:../uvc.c      **** 		 	 		 }
 357:../uvc.c      **** 
 358:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 359:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 360:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 361:../uvc.c      **** 					 break;
 362:../uvc.c      **** 			 }
 363:../uvc.c      **** 
 364:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 365:../uvc.c      **** 
 366:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 367:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 368:../uvc.c      **** #endif
 369:../uvc.c      **** 			  break;
 370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 371:../uvc.c      **** 			 {
 372:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 373:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 374:../uvc.c      **** 			 }
 375:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 376:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 377:../uvc.c      **** 			  break;
 378:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 379:../uvc.c      **** 			 {
 380:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 381:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 382:../uvc.c      **** 			 }
 383:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 384:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 385:../uvc.c      **** 			  break;
 386:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 387:../uvc.c      **** 		 	 {
 388:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 389:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 390:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 391:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 392:../uvc.c      **** 		 	 }
 393:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 394:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 395:../uvc.c      **** 			  break;
 396:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 397:../uvc.c      **** 		 	 {
 398:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 399:../uvc.c      **** 		 	 }
 400:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 401:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 402:../uvc.c      **** 			  Len = 1;
 403:../uvc.c      **** 			  break;
 404:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 405:../uvc.c      **** 		 	 {
 406:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 407:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 408:../uvc.c      **** 			 }
 409:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 410:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 411:../uvc.c      **** 			  break;
 412:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 413:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 414:../uvc.c      **** 				  glEp0Buffer, &readCount);
 415:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 416:../uvc.c      **** 			   {
 417:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 418:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 419:../uvc.c      **** 				  getData = glEp0Buffer[0];
 420:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 421:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 422:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 423:../uvc.c      **** #endif
 424:../uvc.c      **** 				  switch(CtrlID)
 425:../uvc.c      **** 					 {
 426:../uvc.c      **** 						 default:
 427:../uvc.c      **** 							 dataIdx = 0;
 428:../uvc.c      **** 
 429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 430:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 431:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 432:../uvc.c      **** 
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 434:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 435:../uvc.c      **** 							 break;
 436:../uvc.c      **** 					 }
 437:../uvc.c      **** 			   }else{
 438:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 439:../uvc.c      **** 			   }
 440:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 441:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 442:../uvc.c      **** #endif
 443:../uvc.c      **** 
 444:../uvc.c      **** 			  break;
 445:../uvc.c      **** 		  default:
 446:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 447:../uvc.c      **** 			  break;
 448:../uvc.c      **** 		 }
 449:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 450:../uvc.c      **** }
 451:../uvc.c      **** /************** CT control requests handler *************************/
 452:../uvc.c      **** 
 453:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
 454:../uvc.c      **** 
 455:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
 456:../uvc.c      **** void
 457:../uvc.c      **** CyFxUVCAddHeader (
 458:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
 459:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
 460:../uvc.c      ****         )
 461:../uvc.c      **** {
 462:../uvc.c      ****     /* Copy header to buffer */
 463:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 464:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 465:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 466:../uvc.c      **** 
 467:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
 468:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 469:../uvc.c      ****     {
 470:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 471:../uvc.c      ****     }
 472:../uvc.c      **** }
 473:../uvc.c      **** 
 474:../uvc.c      **** 
 475:../uvc.c      **** /* Application Error Handler */
 476:../uvc.c      **** void
 477:../uvc.c      **** CyFxAppErrorHandler (
 478:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
 479:../uvc.c      ****         )
 480:../uvc.c      **** {
 481:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 482:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
 483:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
 484:../uvc.c      **** 
 485:../uvc.c      ****        This function can be modified to take additional error handling actions such
 486:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
 487:../uvc.c      ****      */
 488:../uvc.c      ****     for (;;)
 489:../uvc.c      ****     {
 490:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 491:../uvc.c      ****         CyU3PThreadSleep (1000);
 492:../uvc.c      ****     }
 493:../uvc.c      **** }
 494:../uvc.c      **** 
 495:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
 496:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
 497:../uvc.c      ****  */
 498:../uvc.c      **** static void
 499:../uvc.c      **** CyFxUVCApplnAbortHandler (
 500:../uvc.c      ****         void)
 501:../uvc.c      **** {
 502:../uvc.c      **** 	uint32_t flag;
 503:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 504:../uvc.c      **** 	{
 505:../uvc.c      ****         /* Clear the Video Stream Request Event */
 506:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 507:../uvc.c      **** 
 508:../uvc.c      ****         /* Set Video Stream Abort Event */
 509:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 510:../uvc.c      **** 	}
 511:../uvc.c      **** }
 512:../uvc.c      **** 
 513:../uvc.c      **** /* This is the Callback function to handle the USB Events */
 514:../uvc.c      **** static void
 515:../uvc.c      **** CyFxUVCApplnUSBEventCB (
 516:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
 517:../uvc.c      ****         uint16_t             evdata  /* Event data */
 518:../uvc.c      ****         )
 519:../uvc.c      **** {
 520:../uvc.c      **** 	CyU3PDebugPrint (4, "\nthe event...0x%x 0x%x\r\n", evtype, evdata);
 521:../uvc.c      **** #if 1 //old fusion
 522:../uvc.c      **** 	switch (evtype)
 523:../uvc.c      ****     {
 524:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
 525:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 526:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 527:../uvc.c      ****             gpif_initialized = 0;
 528:../uvc.c      ****             streamingStarted = CyFalse;
 529:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 530:../uvc.c      ****             break;
 531:../uvc.c      **** 
 532:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
 533:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 534:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 535:../uvc.c      ****             gpif_initialized = 0;
 536:../uvc.c      ****             streamingStarted = CyFalse;
 537:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 538:../uvc.c      ****             break;
 539:../uvc.c      **** 
 540:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
 541:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 542:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 543:../uvc.c      ****             gpif_initialized = 0;
 544:../uvc.c      ****             isUsbConnected = CyFalse;
 545:../uvc.c      ****             streamingStarted = CyFalse;
 546:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 547:../uvc.c      ****             break;
 548:../uvc.c      **** 
 549:../uvc.c      ****         case CY_U3P_USB_EVENT_SETCONF:
 550:../uvc.c      ****         //case CY_U3P_USB_EVENT_RESET:
 551:../uvc.c      ****         //case CY_U3P_USB_EVENT_DISCONNECT:
 552:../uvc.c      ****         case CY_U3P_USB_EVENT_CONNECT:
 553:../uvc.c      ****             streamingStarted = CyFalse;
 554:../uvc.c      ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 555:../uvc.c      ****                 glIsConfigured = CyTrue;
 556:../uvc.c      ****             else
 557:../uvc.c      ****                 glIsConfigured = CyFalse;
 558:../uvc.c      **** 
 559:../uvc.c      ****             /* Stop the video streamer application and enable LPM. */
 560:../uvc.c      ****             //CyU3PUsbLPMEnable ();
 561:../uvc.c      ****             if (glIsApplnActive)
 562:../uvc.c      ****             {
 563:../uvc.c      ****             	clearFeatureRqtReceived = CyFalse;
 564:../uvc.c      ****                 //esUVCUvcApplnStop ();
 565:../uvc.c      ****                 CyFxUVCApplnAbortHandler ();
 566:../uvc.c      **** 
 567:../uvc.c      ****             }
 568:../uvc.c      ****             break;
 569:../uvc.c      **** 
 570:../uvc.c      **** #ifdef BACKFLOW_DETECT
 571:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
 572:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
 573:../uvc.c      ****             break;
 574:../uvc.c      **** #endif
 575:../uvc.c      ****         default:
 576:../uvc.c      ****         	CyU3PDebugPrint (4, "\n default...0x%x 0x%x\r\n", evtype, evdata);
 577:../uvc.c      ****             break;
 578:../uvc.c      ****     }
 579:../uvc.c      **** #else //new fusion
 580:../uvc.c      ****     switch (evtype)
 581:../uvc.c      ****     {
 582:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
 583:../uvc.c      ****             /* Suspend the device with Wake On Bus Activity set */
 584:../uvc.c      ****             glIsStreamingStarted = CyFalse;
 585:../uvc.c      ****             CyU3PEventSet (&glTimerEvent, ES_USB_SUSP_EVENT_FLAG, CYU3P_EVENT_OR);
 586:../uvc.c      ****             break;
 587:../uvc.c      ****         case CY_U3P_USB_EVENT_SETINTF:
 588:../uvc.c      ****             /* Start the video streamer application if the
 589:../uvc.c      ****              * interface requested was 1. If not, stop the
 590:../uvc.c      ****              * streamer. */
 591:../uvc.c      ****             interface = CY_U3P_GET_MSB(evdata);
 592:../uvc.c      ****             altSetting = CY_U3P_GET_LSB(evdata);
 593:../uvc.c      **** 
 594:../uvc.c      ****             glIsStreamingStarted = CyFalse;
 595:../uvc.c      **** 
 596:../uvc.c      ****             if ((altSetting == ES_UVC_STREAM_INTERFACE) && (interface == 1))
 597:../uvc.c      ****             {
 598:../uvc.c      ****                 /* Stop the application before re-starting. */
 599:../uvc.c      ****                 if (glIsApplnActive)
 600:../uvc.c      ****                 {
 601:../uvc.c      ****                 	glIsClearFeature = CyTrue;
 602:../uvc.c      ****                     esUVCUvcApplnStop ();
 603:../uvc.c      ****                 }
 604:../uvc.c      ****                 esUVCUvcApplnStart ();
 605:../uvc.c      **** 
 606:../uvc.c      ****             }
 607:../uvc.c      ****             else if ((altSetting == 0x00) && (interface == 1))
 608:../uvc.c      ****             {
 609:../uvc.c      ****             	glPreviewStarted = CyFalse;
 610:../uvc.c      ****             	/* Stop the application before re-starting. */
 611:../uvc.c      ****             	glIsClearFeature = CyTrue;
 612:../uvc.c      **** 				esUVCUvcApplnStop ();
 613:../uvc.c      **** 				glcommitcount = 0;
 614:../uvc.c      ****             }
 615:../uvc.c      ****             break;
 616:../uvc.c      **** 
 617:../uvc.c      ****             /* Fall-through. */
 618:../uvc.c      **** 
 619:../uvc.c      ****         case CY_U3P_USB_EVENT_SETCONF:
 620:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
 621:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
 622:../uvc.c      ****         case CY_U3P_USB_EVENT_CONNECT:
 623:../uvc.c      ****             glIsStreamingStarted = CyFalse;
 624:../uvc.c      ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 625:../uvc.c      ****                 glIsConfigured = CyTrue;
 626:../uvc.c      ****             else
 627:../uvc.c      ****                 glIsConfigured = CyFalse;
 628:../uvc.c      **** 
 629:../uvc.c      ****             /* Stop the video streamer application and enable LPM. */
 630:../uvc.c      ****             CyU3PUsbLPMEnable ();
 631:../uvc.c      ****             if (glIsApplnActive)
 632:../uvc.c      ****             {
 633:../uvc.c      ****             	glIsClearFeature = CyTrue;
 634:../uvc.c      ****                 esUVCUvcApplnStop ();
 635:../uvc.c      ****             }
 636:../uvc.c      ****             break;
 637:../uvc.c      ****         default:
 638:../uvc.c      ****         	CyU3PDebugPrint (4, "\n default...0x%x 0x%x\r\n", evtype, evdata);
 639:../uvc.c      ****             break;
 640:../uvc.c      ****     }
 641:../uvc.c      **** #endif
 642:../uvc.c      **** }
 643:../uvc.c      **** 
 644:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
 645:../uvc.c      **** static CyBool_t
 646:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
 647:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
 648:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
 649:../uvc.c      ****         )
 650:../uvc.c      **** {
 651:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 652:../uvc.c      ****     uint32_t status;
 653:../uvc.c      **** 
 654:../uvc.c      ****     /* Obtain Request Type and Request */
 655:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 656:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 657:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 658:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 659:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 660:../uvc.c      **** 
 661:../uvc.c      **** #if 1
 662:../uvc.c      ****    	CyU3PDebugPrint(4, "\n\rbRType = 0x%x, bRequest = 0x%x, wValue = 0x%x, wIndex = 0x%x, wLength= 
 663:../uvc.c      **** #endif
 664:../uvc.c      **** 
 665:../uvc.c      ****     /* Check for UVC Class Requests */
 666:../uvc.c      ****     switch (bmReqType)
 667:../uvc.c      ****     {
 668:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
 669:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
 670:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
 671:../uvc.c      ****             switch (wIndex & 0xFF)
 672:../uvc.c      ****             {
 673:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
 674:../uvc.c      ****                     {
 675:../uvc.c      ****                         uvcHandleReq = CyTrue;
 676:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 677:../uvc.c      ****                                 CYU3P_EVENT_OR);
 678:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 679:../uvc.c      ****                         {
 680:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 681:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 682:../uvc.c      ****                         }
 683:../uvc.c      ****                     }
 684:../uvc.c      ****                     break;
 685:../uvc.c      **** 
 686:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
 687:../uvc.c      ****                     {
 688:../uvc.c      ****                         uvcHandleReq = CyTrue;
 689:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 690:../uvc.c      ****                                 CYU3P_EVENT_OR);
 691:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 692:../uvc.c      ****                         {
 693:../uvc.c      ****                             /* Error handling */
 694:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 695:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 696:../uvc.c      ****                         }
 697:../uvc.c      ****                     }
 698:../uvc.c      ****                     break;
 699:../uvc.c      **** 
 700:../uvc.c      ****                 default:
 701:../uvc.c      ****                     break;
 702:../uvc.c      ****             }
 703:../uvc.c      ****             break;
 704:../uvc.c      **** 
 705:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
 706:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 707:../uvc.c      ****             {
 708:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
 709:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
 710:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 711:../uvc.c      ****                 {
 712:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
 713:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 714:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 715:../uvc.c      ****                     gpif_initialized = 0;
 716:../uvc.c      ****                     streamingStarted = CyFalse;
 717:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 718:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 719:../uvc.c      ****                     CyU3PBusyWait (100);
 720:../uvc.c      **** 
 721:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
 722:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 723:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 724:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 725:../uvc.c      ****                     CyU3PBusyWait (100);
 726:../uvc.c      **** 
 727:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
 728:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 729:../uvc.c      ****                     uvcHandleReq = CyTrue;
 730:../uvc.c      ****                     /* Complete Control request handshake */
 731:../uvc.c      ****                     CyU3PUsbAckSetup ();
 732:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 733:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 734:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 735:../uvc.c      **** 
 736:../uvc.c      ****                 }
 737:../uvc.c      ****             }
 738:../uvc.c      ****             break;
 739:../uvc.c      **** 
 740:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
 741:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 742:../uvc.c      ****             {
 743:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 744:../uvc.c      ****                 {
 745:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
 746:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
 747:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
 748:../uvc.c      ****                 	 * has started. */
 749:../uvc.c      ****                     if (streamingStarted == CyTrue)
 750:../uvc.c      ****                     {
 751:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 752:../uvc.c      **** 
 753:../uvc.c      ****                         /* Disable the GPIF state machine. */
 754:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 755:../uvc.c      ****                         gpif_initialized = 0;
 756:../uvc.c      ****                         streamingStarted = CyFalse;
 757:../uvc.c      **** 
 758:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
 759:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 760:../uvc.c      ****                         CyU3PBusyWait (100);
 761:../uvc.c      **** 
 762:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
 763:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 764:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 765:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 766:../uvc.c      ****                         CyU3PBusyWait (100);
 767:../uvc.c      **** 
 768:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
 769:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 770:../uvc.c      **** 
 771:../uvc.c      ****                         uvcHandleReq = CyTrue;
 772:../uvc.c      ****                         /* Complete Control request handshake */
 773:../uvc.c      ****                         CyU3PUsbAckSetup ();
 774:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 775:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 776:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 777:../uvc.c      ****                     }
 778:../uvc.c      ****                     else
 779:../uvc.c      ****                     {
 780:../uvc.c      ****                         uvcHandleReq = CyTrue;
 781:../uvc.c      ****                         CyU3PUsbAckSetup ();
 782:../uvc.c      ****                     }
 783:../uvc.c      ****                 }
 784:../uvc.c      ****             }
 785:../uvc.c      ****             break;
 786:../uvc.c      **** 
 787:../uvc.c      ****         default:
 788:../uvc.c      ****             break;
 789:../uvc.c      ****     }
 790:../uvc.c      **** 
 791:../uvc.c      ****     /* Return status of request handling to the USB driver */
 792:../uvc.c      ****     return uvcHandleReq;
 793:../uvc.c      **** }
 794:../uvc.c      **** 
 795:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
 796:../uvc.c      **** 
 797:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
 798:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
 799:../uvc.c      ****  */
 800:../uvc.c      **** void
 801:../uvc.c      **** CyFxUvcApplnDmaCallback (
 802:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
 803:../uvc.c      ****         CyU3PDmaCbType_t      type,
 804:../uvc.c      ****         CyU3PDmaCBInput_t    *input
 805:../uvc.c      ****         )
 806:../uvc.c      **** {
 807:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 808:../uvc.c      **** #if 1
 809:../uvc.c      ****     CyU3PReturnStatus_t status;
 810:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 811:../uvc.c      ****     {
 812:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 813:../uvc.c      ****             {
 814:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 815:../uvc.c      ****                 fb++;
 816:../uvc.c      ****             }
 817:../uvc.c      ****             else
 818:../uvc.c      ****             {
 819:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
 820:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 821:../uvc.c      ****                 pb++;
 822:../uvc.c      ****                 pbc = input->buffer_p.count;
 823:../uvc.c      ****                // hitFV = CyTrue;
 824:../uvc.c      **** #if 1   //remove the still flag clearing here
 825:../uvc.c      ****                 if(stiflag == 0x0F){
 826:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 827:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 828:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 829:../uvc.c      ****                 	//stiflag = 0xAA;
 830:../uvc.c      ****                 	stiflag = 0x0;//set back to video
 831:../uvc.c      ****                 }
 832:../uvc.c      **** #endif
 833:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 834:../uvc.c      ****             }
 835:../uvc.c      **** 
 836:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
 837:../uvc.c      ****             prodCount++;
 838:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 839:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 840:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
 841:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 842:../uvc.c      ****             {
 843:../uvc.c      ****                 prodCount--;
 844:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 845:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 846:../uvc.c      ****             }
 847:../uvc.c      ****     }
 848:../uvc.c      **** #endif
 849:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 850:../uvc.c      ****     {
 851:../uvc.c      ****         consCount++;
 852:../uvc.c      ****         streamingStarted = CyTrue;
 853:../uvc.c      ****     }
 854:../uvc.c      **** }
 855:../uvc.c      **** 
 856:../uvc.c      **** /*
 857:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
 858:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
 859:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
 860:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
 861:../uvc.c      ****  * to commit the buffer.
 862:../uvc.c      ****  */
 863:../uvc.c      **** static uint8_t
 864:../uvc.c      **** CyFxUvcAppCommitEOF (
 865:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
 866:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
 867:../uvc.c      ****         )
 868:../uvc.c      **** {
 869:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 870:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
 871:../uvc.c      **** 
 872:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
 873:../uvc.c      **** 
 874:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 875:../uvc.c      ****     {
 876:../uvc.c      ****         switch (stateId)
 877:../uvc.c      ****         {
 878:../uvc.c      ****             case FULL_BUF_IN_SCK0:
 879:../uvc.c      ****             case FULL_BUF_IN_SCK1:
 880:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
 881:../uvc.c      ****                 break;
 882:../uvc.c      **** 
 883:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
 884:../uvc.c      ****                 socket = 0;
 885:../uvc.c      ****                 break;
 886:../uvc.c      **** 
 887:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
 888:../uvc.c      ****                 socket = 1;
 889:../uvc.c      ****                 break;
 890:../uvc.c      **** 
 891:../uvc.c      ****             default:
 892:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 893:../uvc.c      ****                 /* Unexpected current state. Return error. */
 894:../uvc.c      ****                 return 1;
 895:../uvc.c      ****         }
 896:../uvc.c      ****     }
 897:../uvc.c      **** 
 898:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 899:../uvc.c      ****     {
 900:../uvc.c      ****         switch (stateId)
 901:../uvc.c      ****         {
 902:../uvc.c      **** #ifndef CAM720
 903:../uvc.c      **** #ifdef GPIFIIM
 904:../uvc.c      ****             case 13:
 905:../uvc.c      ****             case 24:
 906:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
 907:../uvc.c      ****                 break;
 908:../uvc.c      **** 
 909:../uvc.c      ****             case 8:
 910:../uvc.c      ****                 socket = 0;
 911:../uvc.c      ****                 break;
 912:../uvc.c      **** 
 913:../uvc.c      ****             case 20:
 914:../uvc.c      ****                 socket = 1;
 915:../uvc.c      ****                 break;
 916:../uvc.c      **** #else
 917:../uvc.c      ****             case 11:
 918:../uvc.c      ****             case 18:
 919:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
 920:../uvc.c      ****                 break;
 921:../uvc.c      **** 
 922:../uvc.c      ****             case 8:
 923:../uvc.c      ****                 socket = 0;
 924:../uvc.c      ****                 break;
 925:../uvc.c      **** 
 926:../uvc.c      ****             case 15:
 927:../uvc.c      ****                 socket = 1;
 928:../uvc.c      ****                 break;
 929:../uvc.c      **** #endif
 930:../uvc.c      **** #else
 931:../uvc.c      ****             case 11:
 932:../uvc.c      ****             case 18:
 933:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
 934:../uvc.c      ****                 break;
 935:../uvc.c      **** 
 936:../uvc.c      ****             case 8:
 937:../uvc.c      ****                 socket = 0;
 938:../uvc.c      ****                 break;
 939:../uvc.c      **** 
 940:../uvc.c      ****             case 15:
 941:../uvc.c      ****                 socket = 1;
 942:../uvc.c      ****                 break;
 943:../uvc.c      **** 
 944:../uvc.c      **** #endif
 945:../uvc.c      ****              default:
 946:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 947:../uvc.c      ****                 /* Unexpected current state. Return error. */
 948:../uvc.c      ****                return 1;
 949:../uvc.c      ****         }
 950:../uvc.c      ****     }
 951:../uvc.c      **** 
 952:../uvc.c      ****     if (socket != 0xFF)
 953:../uvc.c      ****     {
 954:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
 955:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
 956:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
 957:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 958:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 959:../uvc.c      ****         {
 960:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 961:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 962:../uvc.c      ****         }
 963:../uvc.c      ****     }
 964:../uvc.c      **** 
 965:../uvc.c      ****     return 0;
 966:../uvc.c      **** }
 967:../uvc.c      **** 
 968:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
 969:../uvc.c      **** void
 970:../uvc.c      **** CyFxGpifCB (
 971:../uvc.c      ****         CyU3PGpifEventType event,
 972:../uvc.c      ****         uint8_t currentState
 973:../uvc.c      ****         )
 974:../uvc.c      **** {
 975:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 976:../uvc.c      ****     {
 977:../uvc.c      ****         //hitFV = CyTrue;
 978:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
 979:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 980:../uvc.c      ****     }
 981:../uvc.c      **** }
 982:../uvc.c      **** 
 983:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
 984:../uvc.c      **** static void
 985:../uvc.c      **** CyFxUVCApplnDebugInit (
 986:../uvc.c      ****         void)
 987:../uvc.c      **** {
 988:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
 989:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
 990:../uvc.c      **** 
 991:../uvc.c      ****     /* Initialize the UART for printing debug messages */
 992:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 993:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 994:../uvc.c      ****     {
 995:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 996:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 997:../uvc.c      ****     }
 998:../uvc.c      **** 
 999:../uvc.c      ****     /* Set UART Configuration */
1000:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1001:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1002:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1003:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1004:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1005:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1006:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1007:../uvc.c      **** 
1008:../uvc.c      ****     /* Set the UART configuration */
1009:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1010:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1011:../uvc.c      ****     {
1012:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1013:../uvc.c      ****     }
1014:../uvc.c      **** 
1015:../uvc.c      ****     /* Set the UART transfer */
1016:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1017:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1018:../uvc.c      ****     {
1019:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1020:../uvc.c      ****     }
1021:../uvc.c      **** 
1022:../uvc.c      ****     /* Initialize the Debug logger module. */
1023:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
1024:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1025:../uvc.c      ****     {
1026:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1027:../uvc.c      ****     }
1028:../uvc.c      **** 
1029:../uvc.c      ****     /* Disable log message headers. */
1030:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1031:../uvc.c      **** }
1032:../uvc.c      **** 
1033:../uvc.c      **** /* I2C initialization. */
1034:../uvc.c      **** //static void
1035:../uvc.c      **** void
1036:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1037:../uvc.c      **** {
1038:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1039:../uvc.c      ****     CyU3PReturnStatus_t status;
1040:../uvc.c      **** 
1041:../uvc.c      ****     status = CyU3PI2cInit ();
1042:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1043:../uvc.c      ****     {
1044:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1045:../uvc.c      ****         CyFxAppErrorHandler (status);
1046:../uvc.c      ****     }
1047:../uvc.c      **** 
1048:../uvc.c      ****     /*  Set I2C Configuration */
1049:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1050:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1051:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1052:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1053:../uvc.c      **** 
1054:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1055:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1056:../uvc.c      ****     {
1057:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1058:../uvc.c      ****         CyFxAppErrorHandler (status);
1059:../uvc.c      ****     }
1060:../uvc.c      **** }
1061:../uvc.c      **** 
1062:../uvc.c      **** #ifdef BACKFLOW_DETECT
1063:../uvc.c      **** static void CyFxUvcAppPibCallback (
1064:../uvc.c      ****         CyU3PPibIntrType cbType,
1065:../uvc.c      ****         uint16_t cbArg)
1066:../uvc.c      **** {
1067:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1068:../uvc.c      ****     {
1069:../uvc.c      ****         if (!back_flow_detected)
1070:../uvc.c      ****         {
1071:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1072:../uvc.c      ****             back_flow_detected = 1;
1073:../uvc.c      ****         }
1074:../uvc.c      ****     }
1075:../uvc.c      **** }
1076:../uvc.c      **** #endif
1077:../uvc.c      **** 
1078:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1079:../uvc.c      **** static void
1080:../uvc.c      **** CyFxUvcAppDebugCallback (
1081:../uvc.c      ****         CyU3PDmaChannel   *handle,
1082:../uvc.c      ****         CyU3PDmaCbType_t   type,
1083:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1084:../uvc.c      **** {
1085:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1086:../uvc.c      ****     {
1087:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1088:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1089:../uvc.c      ****     }
1090:../uvc.c      **** }
1091:../uvc.c      **** #endif
1092:../uvc.c      **** 
1093:../uvc.c      **** #if 0
1094:../uvc.c      **** static void CyFxAppIntEpCb(
1095:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1096:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1097:../uvc.c      **** 		uint8_t  ebNum)
1098:../uvc.c      **** 		{
1099:../uvc.c      **** 			//CyBool_t value;
1100:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1101:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1102:../uvc.c      **** 
1103:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1104:../uvc.c      **** 		}
1105:../uvc.c      **** #endif
1106:../uvc.c      **** 
1107:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1108:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1109:../uvc.c      ****    configures the DMA module for the UVC Application */
1110:../uvc.c      **** static void
1111:../uvc.c      **** CyFxUVCApplnInit (void)
1112:../uvc.c      **** {
1113:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1114:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1115:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1116:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1117:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1118:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1119:../uvc.c      **** 
1120:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1121:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1122:../uvc.c      **** 
1123:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1124:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1125:../uvc.c      **** #endif
1126:../uvc.c      **** 
1127:../uvc.c      ****     /* Create UVC event group */
1128:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1129:../uvc.c      ****     if (apiRetStatus != 0)
1130:../uvc.c      ****     {
1131:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1132:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1133:../uvc.c      ****     }
1134:../uvc.c      **** 
1135:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1136:../uvc.c      ****     CyFxUvcAppPTZInit ();
1137:../uvc.c      **** #endif
1138:../uvc.c      **** 
1139:../uvc.c      ****     isUsbConnected = CyFalse;
1140:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1141:../uvc.c      **** 
1142:../uvc.c      ****     /* Init the GPIO module */
1143:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1144:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1145:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1146:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1147:../uvc.c      ****     gpioClock.halfDiv    = 0;
1148:../uvc.c      **** 
1149:../uvc.c      ****     /* Initialize Gpio interface */
1150:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1151:../uvc.c      ****     if (apiRetStatus != 0)
1152:../uvc.c      ****     {
1153:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1154:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1155:../uvc.c      ****     }
1156:../uvc.c      **** 
1157:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1158:../uvc.c      ****      * must use GpioOverride to configure it */
1159:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1160:../uvc.c      ****     if (apiRetStatus != 0)
1161:../uvc.c      ****     {
1162:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1163:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1164:../uvc.c      ****     }
1165:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1166:../uvc.c      ****     if (apiRetStatus != 0)
1167:../uvc.c      ****     {
1168:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1169:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1170:../uvc.c      ****     }
1171:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1172:../uvc.c      ****     if (apiRetStatus != 0)
1173:../uvc.c      ****     {
1174:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1175:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1176:../uvc.c      ****     }
1177:../uvc.c      **** 
1178:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1179:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1180:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1181:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1182:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1183:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1184:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1185:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1186:../uvc.c      ****     {
1187:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1188:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1189:../uvc.c      ****     }
1190:../uvc.c      **** 
1191:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1192:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1193:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1194:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1195:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1196:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1197:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1198:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1199:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1200:../uvc.c      ****     {
1201:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1202:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1203:../uvc.c      ****     }
1204:../uvc.c      **** 
1205:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1206:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1207:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1208:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1209:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1210:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1211:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1212:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1213:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1214:../uvc.c      ****     {
1215:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1216:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1217:../uvc.c      ****     }
1218:../uvc.c      **** 
1219:../uvc.c      ****     /* Initialize the P-port. */
1220:../uvc.c      ****     pibclock.clkDiv      = 2;
1221:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1222:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1223:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1224:../uvc.c      **** 
1225:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1226:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1227:../uvc.c      ****     {
1228:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1229:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1230:../uvc.c      ****     }
1231:../uvc.c      **** 
1232:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1233:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1234:../uvc.c      **** 
1235:../uvc.c      **** #ifdef BACKFLOW_DETECT
1236:../uvc.c      ****     back_flow_detected = 0;
1237:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1238:../uvc.c      **** #endif
1239:../uvc.c      **** 
1240:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1241:../uvc.c      ****     SensorReset ();
1242:../uvc.c      ****     SensorInit ();
1243:../uvc.c      **** 
1244:../uvc.c      ****     /* USB initialization. */
1245:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1247:../uvc.c      ****     {
1248:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1249:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1250:../uvc.c      ****     }
1251:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1252:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1253:../uvc.c      **** 
1254:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1255:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1256:../uvc.c      **** 
1257:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1258:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1259:../uvc.c      **** 
1260:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1261:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1262:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1263:../uvc.c      **** 
1264:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1265:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1266:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1267:../uvc.c      **** 
1268:../uvc.c      ****     /* Configuration descriptors. */
1269:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1270:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1271:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1272:../uvc.c      **** 
1273:../uvc.c      ****     /* String Descriptors */
1274:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1275:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1276:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1277:../uvc.c      **** 
1278:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
1279:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
1280:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1281:../uvc.c      ****     {
1282:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
1283:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1284:../uvc.c      ****     }
1285:../uvc.c      **** 
1286:../uvc.c      ****     CyU3PBusyWait(100);
1287:../uvc.c      **** 
1288:../uvc.c      ****     /* Configure the status interrupt endpoint.
1289:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1290:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1291:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1292:../uvc.c      ****      */
1293:../uvc.c      ****     endPointConfig.enable   = 1;
1294:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1295:../uvc.c      ****     endPointConfig.pcktSize = 64;
1296:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1297:../uvc.c      ****     endPointConfig.streams  = 0;
1298:../uvc.c      ****     endPointConfig.burstLen = 1;
1299:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1300:../uvc.c      **** 
1301:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1302:../uvc.c      ****     {
1303:../uvc.c      ****         /* Error Handling */
1304:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1305:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1306:../uvc.c      ****     }
1307:../uvc.c      **** 
1308:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1309:../uvc.c      ****     dmaInterConfig.size           = 1024;
1310:../uvc.c      ****     dmaInterConfig.count          = 1;
1311:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1312:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1313:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1314:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1315:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1316:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1317:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1318:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1319:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1320:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1321:../uvc.c      ****             &dmaInterConfig);
1322:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1323:../uvc.c      ****     {
1324:../uvc.c      ****         /* Error handling */
1325:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1326:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1327:../uvc.c      ****     }
1328:../uvc.c      **** 
1329:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1330:../uvc.c      ****     if (glInterStaBuffer == 0)
1331:../uvc.c      ****     {
1332:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1333:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1334:../uvc.c      ****     }
1335:../uvc.c      **** 
1336:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1337:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
1338:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1339:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1340:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1341:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1342:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1343:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1344:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1345:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1346:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1347:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1348:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1349:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1350:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1351:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1352:../uvc.c      ****             &dmaMultiConfig);
1353:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1354:../uvc.c      ****     {
1355:../uvc.c      ****         /* Error handling */
1356:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1357:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1358:../uvc.c      ****     }
1359:../uvc.c      **** 
1360:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1361:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
1362:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
1363:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
1364:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
1365:../uvc.c      ****      */
1366:../uvc.c      **** 
1367:../uvc.c      ****     endPointConfig.enable   = 1;
1368:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
1369:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
1370:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1371:../uvc.c      ****     endPointConfig.streams  = 0;
1372:../uvc.c      ****     endPointConfig.burstLen = 1;
1373:../uvc.c      **** 
1374:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
1375:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1376:../uvc.c      ****     {
1377:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
1378:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1379:../uvc.c      ****     }
1380:../uvc.c      **** 
1381:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
1382:../uvc.c      **** 
1383:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
1384:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1385:../uvc.c      ****     {
1386:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
1387:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1388:../uvc.c      ****     }
1389:../uvc.c      **** 
1390:../uvc.c      ****     channelConfig.size           = 1024;
1391:../uvc.c      ****     channelConfig.count          = 1;
1392:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
1393:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
1394:../uvc.c      ****     channelConfig.prodAvailCount = 0;
1395:../uvc.c      ****     channelConfig.prodHeader     = 0;
1396:../uvc.c      ****     channelConfig.prodFooter     = 0;
1397:../uvc.c      ****     channelConfig.consHeader     = 0;
1398:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1399:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
1400:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
1401:../uvc.c      **** 
1402:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
1403:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1404:../uvc.c      ****     {
1405:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
1406:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1407:../uvc.c      ****     }
1408:../uvc.c      **** 
1409:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
1410:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1411:../uvc.c      ****     {
1412:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
1413:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1414:../uvc.c      ****     }
1415:../uvc.c      **** 
1416:../uvc.c      ****     channelConfig.size           = 1024;
1417:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
1418:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1419:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
1420:../uvc.c      ****     channelConfig.prodAvailCount = 0;
1421:../uvc.c      ****     channelConfig.prodHeader     = 0;
1422:../uvc.c      ****     channelConfig.prodFooter     = 0;
1423:../uvc.c      ****     channelConfig.consHeader     = 0;
1424:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1425:../uvc.c      ****     channelConfig.notification   = 0;
1426:../uvc.c      ****     channelConfig.cb             = 0;
1427:../uvc.c      **** 
1428:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
1429:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1430:../uvc.c      ****     {
1431:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
1432:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1433:../uvc.c      ****     }
1434:../uvc.c      **** 
1435:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1436:../uvc.c      ****     if (glDebugRspBuffer == 0)
1437:../uvc.c      ****     {
1438:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
1439:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1440:../uvc.c      ****     }
1441:../uvc.c      **** #endif
1442:../uvc.c      **** 
1443:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
1444:../uvc.c      **** /*    apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
1445:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1446:../uvc.c      ****     {
1447:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
1448:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1449:../uvc.c      ****     }
1450:../uvc.c      **** */
1451:../uvc.c      ****     CyU3PBusyWait(100);
1452:../uvc.c      **** 
1453:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
1454:../uvc.c      **** 
1455:../uvc.c      ****     endPointConfig.enable   = 1;
1456:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
1457:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
1458:../uvc.c      ****     {
1459:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
1460:../uvc.c      ****     	endPointConfig.burstLen = 16;
1461:../uvc.c      ****     }
1462:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
1463:../uvc.c      ****     {
1464:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
1465:../uvc.c      ****     	endPointConfig.burstLen = 1;
1466:../uvc.c      ****     }
1467:../uvc.c      ****     endPointConfig.streams  = 0;
1468:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
1469:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1470:../uvc.c      ****     {
1471:../uvc.c      ****         /* Error Handling */
1472:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1473:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1474:../uvc.c      ****     }
1475:../uvc.c      **** #if 0    //for still image method 3 using
1476:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
1477:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1478:../uvc.c      ****     {
1479:../uvc.c      ****         /* Error Handling */
1480:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
1481:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1482:../uvc.c      ****     }
1483:../uvc.c      **** #endif
1484:../uvc.c      **** 
1485:../uvc.c      **** }
1486:../uvc.c      **** 
1487:../uvc.c      **** /*
1488:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
1489:../uvc.c      ****  * streaming session is started.
1490:../uvc.c      ****  */
1491:../uvc.c      **** static void
1492:../uvc.c      **** CyFxUvcAppGpifInit (
1493:../uvc.c      ****         void)
1494:../uvc.c      **** {
1495:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
1496:../uvc.c      **** 
1497:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1498:../uvc.c      ****     {
1499:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
1500:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
1501:../uvc.c      ****     }
1502:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1503:../uvc.c      ****     {
1504:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
1505:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
1506:../uvc.c      ****     }
1507:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1508:../uvc.c      ****     {
1509:../uvc.c      ****         /* Error Handling */
1510:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
1511:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1512:../uvc.c      ****     }
1513:../uvc.c      **** 
1514:../uvc.c      ****     /* Start the state machine from the designated start state. */
1515:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1516:../uvc.c      ****     {
1517:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
1518:../uvc.c      ****     }
1519:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
1520:../uvc.c      ****     {
1521:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
1522:../uvc.c      ****     }
1523:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1524:../uvc.c      ****     {
1525:../uvc.c      ****         /* Error Handling */
1526:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
1527:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1528:../uvc.c      ****     }
1529:../uvc.c      **** }
1530:../uvc.c      **** 
1531:../uvc.c      **** /*
1532:../uvc.c      ****  * Entry function for the UVC Application Thread
1533:../uvc.c      ****  */
1534:../uvc.c      **** 
1535:../uvc.c      **** uint32_t posTick;
1536:../uvc.c      **** CyU3PTimer I2CCmdTimer;
1537:../uvc.c      **** 
1538:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 1538 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
1539:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
1540:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  28              		.loc 1 1540 0
  29 0000 08009FE5 		ldr	r0, .L2
  30              	.LVL1:
  31 0004 2010A0E3 		mov	r1, #32
  32 0008 0020A0E3 		mov	r2, #0
  33 000c FEFFFFEA 		b	_txe_event_flags_set
  34              	.LVL2:
  35              	.L3:
  36              		.align	2
  37              	.L2:
  38 0010 00000000 		.word	.LANCHOR0
  39              		.cfi_endproc
  40              	.LFE14:
  42              		.align	2
  43              		.global	I2cAppThread_Entry
  45              	I2cAppThread_Entry:
  46              	.LFB22:
1541:../uvc.c      **** }
1542:../uvc.c      **** 
1543:../uvc.c      **** 
1544:../uvc.c      **** void
1545:../uvc.c      **** UVCAppThread_Entry (
1546:../uvc.c      ****         uint32_t input)
1547:../uvc.c      **** {
1548:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
1549:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
1550:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
1551:../uvc.c      ****     uint8_t i = 0;
1552:../uvc.c      ****     uint32_t flag;
1553:../uvc.c      ****     uint32_t prinflag = 0;
1554:../uvc.c      **** static uint8_t IMcount = 0;
1555:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
1556:../uvc.c      ****     uint32_t frameCnt = 0;
1557:../uvc.c      **** #endif
1558:../uvc.c      ****     /* Initialize the Uart Debug Module */
1559:../uvc.c      ****     CyFxUVCApplnDebugInit ();
1560:../uvc.c      **** 
1561:../uvc.c      ****     /* Initialize the I2C interface */
1562:../uvc.c      **** 	while (i++ < 6){
1563:../uvc.c      **** 		CyU3PThreadSleep(500);
1564:../uvc.c      **** 	}
1565:../uvc.c      **** 
1566:../uvc.c      ****     CyFxUVCApplnI2CInit ();
1567:../uvc.c      **** 
1568:../uvc.c      ****     /* Initialize the UVC Application */
1569:../uvc.c      ****     CyFxUVCApplnInit ();
1570:../uvc.c      **** 
1571:../uvc.c      ****     /*
1572:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
1573:../uvc.c      **** 
1574:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
1575:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
1576:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
1577:../uvc.c      **** 
1578:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
1579:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
1580:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
1581:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
1582:../uvc.c      **** 
1583:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
1584:../uvc.c      ****        of handling the abort request.
1585:../uvc.c      ****      */
1586:../uvc.c      **** 
1587:../uvc.c      ****     for (;;)
1588:../uvc.c      ****     {
1589:../uvc.c      ****         /* Waiting for the Video Stream Event */
1590:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
1591:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
1592:../uvc.c      ****         {
1593:../uvc.c      **** #if 0 //test for new firmware no video bring up
1594:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
1595:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
1596:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
1597:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
1598:../uvc.c      ****             {
1599:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
1600:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
1601:../uvc.c      ****                 {
1602:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
1603:../uvc.c      **** #ifdef  USB_LOWRES_IMG
1604:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
1605:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
1606:../uvc.c      **** #endif
1607:../uvc.c      **** #endif
1608:../uvc.c      ****                     }
1609:../uvc.c      ****                 else
1610:../uvc.c      ****                 {
1611:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
1612:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
1613:../uvc.c      **** #ifdef USB_LOWRES_IMG
1614:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
1615:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1616:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
1617:../uvc.c      **** #endif
1618:../uvc.c      **** #endif
1619:../uvc.c      ****                 }
1620:../uvc.c      **** 
1621:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
1622:../uvc.c      ****                 prodCount++;
1623:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
1624:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1625:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
1626:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
1627:../uvc.c      ****                 {
1628:../uvc.c      ****                     prodCount--;
1629:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
1630:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
1631:../uvc.c      ****                 }
1632:../uvc.c      ****             }
1633:../uvc.c      **** #endif
1634:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
1635:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
1636:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
1637:../uvc.c      ****             {
1638:../uvc.c      ****             	if(0&&(prinflag == 0)){
1639:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
1640:../uvc.c      ****             		prinflag = 1;
1641:../uvc.c      ****             	}
1642:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
1643:../uvc.c      ****             	fb=0;
1644:../uvc.c      ****             	pb=0;
1645:../uvc.c      ****             	pbc=0;
1646:../uvc.c      ****                 prodCount = 0;
1647:../uvc.c      ****                 consCount = 0;
1648:../uvc.c      ****                 hitFV     = CyFalse;
1649:../uvc.c      **** 
1650:../uvc.c      **** #ifdef BACKFLOW_DETECT
1651:../uvc.c      ****                 back_flow_detected = 0;
1652:../uvc.c      **** #endif
1653:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
1654:../uvc.c      ****                 frameCnt++;
1655:../uvc.c      **** #endif
1656:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
1657:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
1658:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
1659:../uvc.c      ****                 //}
1660:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
1661:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1662:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
1663:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
1664:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
1665:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
1666:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
1667:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
1668:../uvc.c      ****                      	//CyU3PThreadSleep(100);
1669:../uvc.c      ****                 		stiflag = 0xFF;
1670:../uvc.c      ****                 		IMcount = 0;
1671:../uvc.c      ****                 	}
1672:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
1673:../uvc.c      **** 
1674:../uvc.c      ****                  		if(IMcount++ >= 0x3){
1675:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
1676:../uvc.c      ****                 		stiflag = 0x0F;
1677:../uvc.c      ****                 		IMcount = 0;
1678:../uvc.c      ****                 		}
1679:../uvc.c      ****                  		/*if(IMcount > 0x4){
1680:../uvc.c      ****                 			stiflag = 0x0F;
1681:../uvc.c      ****                 			IMcount = 0;
1682:../uvc.c      ****                 		}*/
1683:../uvc.c      **** 
1684:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
1685:../uvc.c      ****                     //CyU3PThreadSleep(400);
1686:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1687:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1688:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1689:../uvc.c      **** 
1690:../uvc.c      ****                 	if(IMcount++ >= 0x3)
1691:../uvc.c      ****                 	{
1692:../uvc.c      ****                     switch (setRes)
1693:../uvc.c      ****                      {
1694:../uvc.c      ****                  	case 1: //720
1695:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
1696:../uvc.c      ****                  		//CyU3PThreadSleep(100);
1697:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0xb, 0x0);
1698:../uvc.c      ****                  		break;
1699:../uvc.c      ****                  	case 2: //960
1700:../uvc.c      ****                  		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
1701:../uvc.c      ****                  		//CyU3PThreadSleep(100);
1702:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", 0x0b, 0x1);
1703:../uvc.c      ****                  		break;
1704:../uvc.c      ****                  	default:
1705:../uvc.c      ****                  		break;
1706:../uvc.c      ****                      }
1707:../uvc.c      ****                     IMcount = 0;
1708:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1709:../uvc.c      ****                 	stiflag = 0x0;
1710:../uvc.c      ****                 	}
1711:../uvc.c      ****                 }
1712:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
1713:../uvc.c      ****                 /* Reset the DMA channel. */
1714:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1715:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
1716:../uvc.c      ****                 {
1717:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
1718:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
1719:../uvc.c      ****                 }
1720:../uvc.c      **** 
1721:../uvc.c      ****                 /* Start Channel Immediately */
1722:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
1723:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
1724:../uvc.c      ****                 {
1725:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
1726:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
1727:../uvc.c      ****                 }
1728:../uvc.c      **** 
1729:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
1730:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
1731:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
1732:../uvc.c      ****                 }
1733:../uvc.c      ****         }
1734:../uvc.c      ****         else
1735:../uvc.c      ****         {
1736:../uvc.c      ****             /* If we have a stream abort request pending. */
1737:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
1738:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
1739:../uvc.c      ****             {
1740:../uvc.c      ****                 hitFV     = CyFalse;
1741:../uvc.c      ****                 prodCount = 0;
1742:../uvc.c      ****                 consCount = 0;
1743:../uvc.c      ****                 glIsApplnActive = CyFalse;//gpif->USB is not active
1744:../uvc.c      ****                 if(0&&(prinflag == 0)){
1745:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
1746:../uvc.c      ****                 	prinflag = 1;
1747:../uvc.c      ****                 }
1748:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
1749:../uvc.c      ****                 fb=0;
1750:../uvc.c      ****                 pb=0;
1751:../uvc.c      ****                 pbc=0;
1752:../uvc.c      **** 
1753:../uvc.c      ****                 if (!clearFeatureRqtReceived)
1754:../uvc.c      ****                 {
1755:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1756:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
1757:../uvc.c      ****                     {
1758:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
1759:../uvc.c      ****                     }
1760:../uvc.c      **** 
1761:../uvc.c      ****                     /* Flush the Endpoint memory */
1762:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1763:../uvc.c      ****                 }
1764:../uvc.c      **** 
1765:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
1766:../uvc.c      ****             }
1767:../uvc.c      ****             else
1768:../uvc.c      ****             {
1769:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
1770:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
1771:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
1772:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
1773:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
1774:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
1775:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
1776:../uvc.c      ****                 {
1777:../uvc.c      ****                     /* Error handling */
1778:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
1779:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
1780:../uvc.c      ****                 }
1781:../uvc.c      **** 
1782:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
1783:../uvc.c      ****                 if (gpif_initialized == CyFalse)
1784:../uvc.c      ****                 {
1785:../uvc.c      **** #if 0
1786:../uvc.c      ****                 	//for start up of the AF Lens
1787:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
1788:../uvc.c      ****                     CyU3PThreadSleep(500);
1789:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
1790:../uvc.c      ****                     CyU3PThreadSleep(500);
1791:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
1792:../uvc.c      ****                    	CyU3PThreadSleep(300);
1793:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
1794:../uvc.c      ****                     CyU3PThreadSleep(500);
1795:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
1796:../uvc.c      ****                     CyU3PThreadSleep(500);
1797:../uvc.c      **** #endif
1798:../uvc.c      ****                     CyFxUvcAppGpifInit ();
1799:../uvc.c      ****                     gpif_initialized = CyTrue;
1800:../uvc.c      ****                     CyU3PThreadSleep(200);
1801:../uvc.c      **** 
1802:../uvc.c      ****                 }
1803:../uvc.c      ****                 else
1804:../uvc.c      ****                 {
1805:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
1806:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
1807:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
1808:../uvc.c      ****                 }
1809:../uvc.c      ****             }
1810:../uvc.c      ****         }
1811:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
1812:../uvc.c      ****         glIsApplnActive = CyTrue;//gpif->USB is active
1813:../uvc.c      **** 
1814:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
1815:../uvc.c      ****         CyU3PThreadRelinquish ();
1816:../uvc.c      ****     }
1817:../uvc.c      **** }
1818:../uvc.c      **** 
1819:../uvc.c      **** /*
1820:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
1821:../uvc.c      ****  */
1822:../uvc.c      **** 
1823:../uvc.c      **** static void
1824:../uvc.c      **** UVCHandleProcessingUnitRqts (
1825:../uvc.c      ****         void)
1826:../uvc.c      **** {
1827:../uvc.c      ****     uint8_t CtrlAdd;
1828:../uvc.c      **** #ifdef DbgInfo
1829:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
1830:../uvc.c      **** #endif
1831:../uvc.c      ****     switch (wValue)
1832:../uvc.c      ****     {
1833:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
1834:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
1835:../uvc.c      ****     		ControlHandle(BLCCtlID0);
1836:../uvc.c      ****     		break;
1837:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
1838:../uvc.c      ****         	CtrlAdd = CtrlParArry[ExtExRefCtlID10/*BrgtCtlID1*/][0]; //Exreference places brightness.
1839:../uvc.c      ****    			ControlHandle(ExtExRefCtlID10/*BrgtCtlID1*/);
1840:../uvc.c      ****     		break;
1841:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
1842:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
1843:../uvc.c      **** 			ControlHandle(ConsCtlID2);
1844:../uvc.c      **** 			break;
1845:../uvc.c      **** 
1846:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
1847:../uvc.c      **** 
1848:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
1849:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
1850:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
1851:../uvc.c      ****       		break;
1852:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
1853:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
1854:../uvc.c      ****      		ControlHandle(HueCtlID5);
1855:../uvc.c      ****      		break;
1856:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
1857:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
1858:../uvc.c      ****           		ControlHandle(SaturCtlID6);
1859:../uvc.c      ****           		break;
1860:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
1861:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
1862:../uvc.c      ****           		ControlHandle(ShapCtlID7);
1863:../uvc.c      ****           		break;
1864:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
1865:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
1866:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
1867:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
1868:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
1869:../uvc.c      ****     		break;
1870:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
1871:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
1872:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
1873:../uvc.c      ****     		break;
1874:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
1875:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
1876:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
1877:../uvc.c      ****     		break;
1878:../uvc.c      **** 
1879:../uvc.c      ****         default:
1880:../uvc.c      ****             /*
1881:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
1882:../uvc.c      ****              * other controls.
1883:../uvc.c      ****              */
1884:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
1885:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
1886:../uvc.c      ****             break;
1887:../uvc.c      ****     }
1888:../uvc.c      **** }
1889:../uvc.c      **** 
1890:../uvc.c      **** /*
1891:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
1892:../uvc.c      ****  */
1893:../uvc.c      **** static void
1894:../uvc.c      **** UVCHandleCameraTerminalRqts (
1895:../uvc.c      ****         void)
1896:../uvc.c      **** {
1897:../uvc.c      ****     uint8_t CtrlAdd;
1898:../uvc.c      **** 
1899:../uvc.c      ****     switch (wValue)
1900:../uvc.c      ****     {
1901:../uvc.c      ****         default:
1902:../uvc.c      ****             /*
1903:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
1904:../uvc.c      ****              * other controls.
1905:../uvc.c      ****              */
1906:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
1907:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
1908:../uvc.c      ****             break;
1909:../uvc.c      ****     }
1910:../uvc.c      **** 
1911:../uvc.c      **** }
1912:../uvc.c      **** 
1913:../uvc.c      **** /*
1914:../uvc.c      ****  * Handler for UVC Interface control requests.
1915:../uvc.c      ****  */
1916:../uvc.c      **** static void
1917:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
1918:../uvc.c      ****         void)
1919:../uvc.c      **** {
1920:../uvc.c      **** 
1921:../uvc.c      ****     switch (wValue)
1922:../uvc.c      ****     {
1923:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
1924:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
1925:../uvc.c      ****     		break;
1926:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
1927:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
1928:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
1929:../uvc.c      ****     		break;
1930:../uvc.c      ****     	default:
1931:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
1932:../uvc.c      ****      		break;
1933:../uvc.c      ****     }
1934:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
1935:../uvc.c      **** 
1936:../uvc.c      **** }
1937:../uvc.c      **** 
1938:../uvc.c      **** /*
1939:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
1940:../uvc.c      ****  */
1941:../uvc.c      **** static void
1942:../uvc.c      **** UVCHandleExtensionUnitRqts (
1943:../uvc.c      ****         void)
1944:../uvc.c      **** {
1945:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
1946:../uvc.c      **** 
1947:../uvc.c      **** #ifdef DbgInfo
1948:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
1949:../uvc.c      **** #endif
1950:../uvc.c      ****     switch (wValue)
1951:../uvc.c      ****     {
1952:../uvc.c      ****    	default:
1953:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
1954:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
1955:../uvc.c      ****     		break;
1956:../uvc.c      ****     }
1957:../uvc.c      **** 
1958:../uvc.c      **** }
1959:../uvc.c      **** 
1960:../uvc.c      **** /*
1961:../uvc.c      ****  * Handler for the video streaming control requests.
1962:../uvc.c      ****  */
1963:../uvc.c      **** static void
1964:../uvc.c      **** UVCHandleVideoStreamingRqts (
1965:../uvc.c      ****         void)
1966:../uvc.c      **** {
1967:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1968:../uvc.c      ****     uint16_t readCount;
1969:../uvc.c      **** 
1970:../uvc.c      ****     switch (wValue)
1971:../uvc.c      ****     {
1972:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
1973:../uvc.c      ****             switch (bRequest)
1974:../uvc.c      ****             {
1975:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
1976:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
1977:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1978:../uvc.c      ****                     break;
1979:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
1980:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
1981:../uvc.c      ****                     glEp0Buffer[1] = 0;
1982:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1983:../uvc.c      ****                     break;
1984:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
1985:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
1986:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
1987:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
1988:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED)//supports both SS and HS
1989:../uvc.c      ****                     {
1990:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
1991:../uvc.c      ****                     }
1992:../uvc.c      ****                     else
1993:../uvc.c      ****                     {
1994:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
1995:../uvc.c      ****                     }
1996:../uvc.c      ****                     break;
1997:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
1998:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1999:../uvc.c      ****                             glCommitCtrl, &readCount);
2000:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2001:../uvc.c      ****                     {
2002:../uvc.c      ****                         //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2003:../uvc.c      ****                         {
2004:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2005:../uvc.c      ****                                active data structure. */
2006:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2007:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2008:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2009:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2010:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2011:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2012:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
2013:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
2014:../uvc.c      ****                         }
2015:../uvc.c      ****                     }
2016:../uvc.c      ****                     break;
2017:../uvc.c      ****                 default:
2018:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2019:../uvc.c      ****                     break;
2020:../uvc.c      ****             }
2021:../uvc.c      ****             break;
2022:../uvc.c      **** 
2023:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2024:../uvc.c      ****             switch (bRequest)
2025:../uvc.c      ****             {
2026:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2027:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2028:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2029:../uvc.c      ****                     break;
2030:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2031:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2032:../uvc.c      ****                     glEp0Buffer[1] = 0;
2033:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2034:../uvc.c      ****                     break;
2035:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2036:../uvc.c      ****                     if (1 || usbSpeed == CY_U3P_SUPER_SPEED) //support both SS and HS
2037:../uvc.c      ****                     {
2038:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2039:../uvc.c      ****                     }
2040:../uvc.c      ****                     else
2041:../uvc.c      ****                     {
2042:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2043:../uvc.c      ****                     }
2044:../uvc.c      ****                     break;
2045:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2046:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2047:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2048:../uvc.c      ****                        */
2049:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2050:../uvc.c      ****                             glCommitCtrl, &readCount);
2051:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)//supports both SS and HS
2052:../uvc.c      ****                     {
2053:../uvc.c      ****                         if(setRes != glCommitCtrl[3])
2054:../uvc.c      ****                         {
2055:../uvc.c      ****                         switch (glCommitCtrl[3])
2056:../uvc.c      ****                          {
2057:../uvc.c      ****                          	case 1: //720 or 360
2058:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2059:../uvc.c      ****                          		CyU3PThreadSleep(500);
2060:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
2061:../uvc.c      ****                          		break;
2062:../uvc.c      ****                          	case 2: //960 or 480
2063:../uvc.c      ****                          		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);/
2064:../uvc.c      ****                          		CyU3PThreadSleep(500);
2065:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
2066:../uvc.c      ****                          		break;
2067:../uvc.c      ****                          	default:
2068:../uvc.c      ****                          		break;
2069:../uvc.c      ****                          }                         
2070:../uvc.c      ****                         setRes = glCommitCtrl[3];
2071:../uvc.c      ****                         }
2072:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
2073:../uvc.c      **** 
2074:../uvc.c      **** #if 0
2075:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2076:../uvc.c      ****                         {
2077:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2078:../uvc.c      ****                         }
2079:../uvc.c      ****                         else
2080:../uvc.c      ****                         {
2081:../uvc.c      ****                             SensorScaling_VGA ();
2082:../uvc.c      ****                         }
2083:../uvc.c      **** #endif
2084:../uvc.c      ****                         /* We can start streaming video now. */
2085:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2086:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2087:../uvc.c      ****                         {
2088:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2089:../uvc.c      ****                         }
2090:../uvc.c      ****                     }
2091:../uvc.c      ****                     break;
2092:../uvc.c      **** 
2093:../uvc.c      ****                 default:
2094:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2095:../uvc.c      ****                     break;
2096:../uvc.c      ****             }
2097:../uvc.c      ****             break;
2098:../uvc.c      **** 
2099:../uvc.c      **** /* still image streaming handler */
2100:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2101:../uvc.c      ****                 switch (bRequest)
2102:../uvc.c      ****                 {
2103:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2104:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2105:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2106:../uvc.c      ****                         break;
2107:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2108:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2109:../uvc.c      ****                         glEp0Buffer[1] = 0;
2110:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2111:../uvc.c      ****                         break;
2112:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2113:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2114:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2115:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2116:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2117:../uvc.c      ****                         {
2118:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2119:../uvc.c      ****                         }
2120:../uvc.c      ****                         else
2121:../uvc.c      ****                         {
2122:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2123:../uvc.c      ****                         }
2124:../uvc.c      ****                         break;
2125:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2126:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2127:../uvc.c      ****                                 glCommitCtrl, &readCount);
2128:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2129:../uvc.c      ****                         {
2130:../uvc.c      ****                             //if (usbSpeed == CY_U3P_SUPER_SPEED)//for both SS and HS
2131:../uvc.c      ****                             {
2132:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2133:../uvc.c      ****                                    active data structure. */
2134:../uvc.c      ****                             	//glProbeStilCtrl[1] = glCommitCtrl[1];
2135:../uvc.c      ****                             	//glProbeStilCtrl[2] = glCommitCtrl[2];
2136:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
2137:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
2138:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
2139:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
2140:../uvc.c      ****                             	//glProbeStilCtrl[7] = glCommitCtrl[7];
2141:../uvc.c      ****                             }
2142:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d \r\n", readCoun
2143:../uvc.c      ****                             CyU3PDebugPrint (4, "%d %d %d %d %d %d %d %d %d %d %d\r\n",
2144:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[1],  glCommitCtrl[2], glCommitCtrl[3],
2145:../uvc.c      ****                             		glCommitCtrl[4], glCommitCtrl[5],  glCommitCtrl[6], glCommitCtrl[7],
2146:../uvc.c      ****                             		glCommitCtrl[8], glCommitCtrl[9], glCommitCtrl[10]);
2147:../uvc.c      ****                         }
2148:../uvc.c      ****                         break;
2149:../uvc.c      ****                     default:
2150:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2151:../uvc.c      ****                         break;
2152:../uvc.c      ****                 }
2153:../uvc.c      ****                 break;
2154:../uvc.c      **** 
2155:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2156:../uvc.c      ****                 switch (bRequest)
2157:../uvc.c      ****                 {
2158:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2159:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2160:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2161:../uvc.c      ****                         break;
2162:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2163:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2164:../uvc.c      ****                         glEp0Buffer[1] = 0;
2165:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2166:../uvc.c      ****                         break;
2167:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2168:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2169:../uvc.c      ****                         {
2170:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2171:../uvc.c      ****                         }
2172:../uvc.c      ****                         else
2173:../uvc.c      ****                         {
2174:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2175:../uvc.c      ****                         }
2176:../uvc.c      ****                         break;
2177:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2178:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2179:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2180:../uvc.c      ****                            */
2181:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2182:../uvc.c      ****                                 glCommitCtrl, &readCount);
2183:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2184:../uvc.c      ****                         {
2185:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still commit(set) control %d \r\n", readCo
2186:../uvc.c      ****                             CyU3PDebugPrint (4, "%d %d %d %d %d %d %d %d %d %d %d\r\n",
2187:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[1],  glCommitCtrl[2], glCommitCtrl[3],
2188:../uvc.c      ****                             		glCommitCtrl[4], glCommitCtrl[5],  glCommitCtrl[6], glCommitCtrl[7],
2189:../uvc.c      ****                             		glCommitCtrl[8], glCommitCtrl[9], glCommitCtrl[10]);
2190:../uvc.c      **** 
2191:../uvc.c      ****     #if 0
2192:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
2193:../uvc.c      ****                             {
2194:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
2195:../uvc.c      ****                             }
2196:../uvc.c      ****                             else
2197:../uvc.c      ****                             {
2198:../uvc.c      ****                                 SensorScaling_VGA ();
2199:../uvc.c      ****                             }
2200:../uvc.c      ****                             /* We can start streaming video now. */
2201:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
2202:../uvc.c      **** 
2203:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
2204:../uvc.c      ****                             {
2205:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
2206:../uvc.c      ****                             }
2207:../uvc.c      **** 	#endif
2208:../uvc.c      **** #if 0 //remove the still resolution set for invendo because the still res. is always the same as th
2209:../uvc.c      ****                            switch (glCommitCtrl[1])
2210:../uvc.c      ****                              {
2211:../uvc.c      ****                              	case 1: //720
2212:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x1, I2C_DSPBOARD_ADDR_WR/*boardID*
2213:../uvc.c      ****                              		//CyU3PThreadSleep(500);
2214:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
2215:../uvc.c      ****                              		break;
2216:../uvc.c      ****                             	case 2: //960
2217:../uvc.c      ****                              		SensorSetIrisControl(0x0b, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*
2218:../uvc.c      ****                              		//CyU3PThreadSleep(500);
2219:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", 0x0b, 
2220:../uvc.c      ****                              		break;
2221:../uvc.c      ****                               	default:
2222:../uvc.c      ****                              		break;
2223:../uvc.c      ****                              }
2224:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
2225:../uvc.c      **** 
2226:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
2227:../uvc.c      **** #endif
2228:../uvc.c      ****                         }
2229:../uvc.c      ****                         break;
2230:../uvc.c      **** 
2231:../uvc.c      ****                     default:
2232:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2233:../uvc.c      ****                         break;
2234:../uvc.c      ****                 }
2235:../uvc.c      ****                 break;
2236:../uvc.c      **** 
2237:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
2238:../uvc.c      ****                 switch (bRequest)
2239:../uvc.c      ****                 {
2240:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2241:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2242:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2243:../uvc.c      ****                         break;
2244:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2245:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
2246:../uvc.c      ****                         glEp0Buffer[1] = 0;
2247:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2248:../uvc.c      ****                         break;
2249:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
2250:../uvc.c      ****                         if (1 || usbSpeed == CY_U3P_SUPER_SPEED)// support both SS and HS
2251:../uvc.c      ****                         {
2252:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
2253:../uvc.c      ****                         }
2254:../uvc.c      ****                         else
2255:../uvc.c      ****                         {
2256:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
2257:../uvc.c      ****                         }
2258:../uvc.c      ****                         break;
2259:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2260:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2261:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2262:../uvc.c      ****                            */
2263:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2264:../uvc.c      ****                                 glCommitCtrl, &readCount);
2265:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2266:../uvc.c      ****                         {
2267:../uvc.c      ****     #if 1
2268:../uvc.c      ****                             /* We can start still streaming video now. */
2269:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2270:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
2271:../uvc.c      ****                             {
2272:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
2273:../uvc.c      ****                             }
2274:../uvc.c      ****     #endif
2275:../uvc.c      ****                             else{
2276:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
2277:../uvc.c      ****                             //stillcont = 0;
2278:../uvc.c      ****                             }
2279:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
2280:../uvc.c      ****                         }else{
2281:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
2282:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
2283:../uvc.c      ****                         }
2284:../uvc.c      ****                         break;
2285:../uvc.c      **** 
2286:../uvc.c      ****                     default:
2287:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2288:../uvc.c      ****                         break;
2289:../uvc.c      ****                 }
2290:../uvc.c      ****                 break;
2291:../uvc.c      **** 
2292:../uvc.c      ****         default:
2293:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2294:../uvc.c      ****             break;
2295:../uvc.c      ****     }
2296:../uvc.c      **** }
2297:../uvc.c      **** 
2298:../uvc.c      **** /*
2299:../uvc.c      ****  * Entry function for the UVC control request processing thread.
2300:../uvc.c      ****  */
2301:../uvc.c      **** void
2302:../uvc.c      **** UVCAppEP0Thread_Entry (
2303:../uvc.c      ****         uint32_t input)
2304:../uvc.c      **** {
2305:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
2306:../uvc.c      ****     uint32_t eventFlag;
2307:../uvc.c      **** 	CyBool_t value;
2308:../uvc.c      **** 	CyBool_t *valueptr = &value;
2309:../uvc.c      **** 
2310:../uvc.c      **** 
2311:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2312:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2313:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
2314:../uvc.c      **** 
2315:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
2316:../uvc.c      **** #endif
2317:../uvc.c      **** 
2318:../uvc.c      ****     /* for interrupt status test */
2319:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2320:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
2321:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
2322:../uvc.c      **** 
2323:../uvc.c      ****     for (;;)
2324:../uvc.c      ****     {
2325:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
2326:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
2327:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
2328:../uvc.c      ****         {
2329:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
2330:../uvc.c      ****             if (!isUsbConnected)
2331:../uvc.c      ****             {
2332:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
2333:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
2334:../uvc.c      ****                 {
2335:../uvc.c      ****                     isUsbConnected = CyTrue;
2336:../uvc.c      ****                 }
2337:../uvc.c      ****             }
2338:../uvc.c      **** //#ifdef DbgInfo
2339:../uvc.c      **** #if 0
2340:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
2341:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
2342:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
2343:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
2344:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
2345:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
2346:../uvc.c      **** #endif
2347:../uvc.c      **** //#endif
2348:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
2349:../uvc.c      ****             {
2350:../uvc.c      ****             	switch ((wIndex >> 8))
2351:../uvc.c      ****                 {
2352:../uvc.c      **** 
2353:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
2354:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
2355:../uvc.c      ****                         break;
2356:../uvc.c      **** 
2357:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
2358:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
2359:../uvc.c      ****                         break;
2360:../uvc.c      **** 
2361:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
2362:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
2363:../uvc.c      ****                         break;
2364:../uvc.c      **** 
2365:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
2366:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
2367:../uvc.c      ****                         break;
2368:../uvc.c      **** 
2369:../uvc.c      ****                     default:
2370:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
2371:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2372:../uvc.c      ****                         break;
2373:../uvc.c      ****                 }
2374:../uvc.c      ****             }
2375:../uvc.c      **** 
2376:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
2377:../uvc.c      ****             {
2378:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
2379:../uvc.c      **** 
2380:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
2381:../uvc.c      ****                 {
2382:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2383:../uvc.c      ****                 }
2384:../uvc.c      ****                 else
2385:../uvc.c      ****                 {
2386:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
2387:../uvc.c      ****                 }
2388:../uvc.c      ****             }
2389:../uvc.c      **** 
2390:../uvc.c      ****             /* handle interrupt status event */
2391:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
2392:../uvc.c      ****             {
2393:../uvc.c      **** 
2394:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
2395:../uvc.c      ****             	/** preparing interrupt status data **/
2396:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
2397:../uvc.c      **** 
2398:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
2399:../uvc.c      **** 
2400:../uvc.c      **** #if 1 //for real button
2401:../uvc.c      **** 				if(value&&(!snapButFlag)){
2402:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
2403:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
2404:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
2405:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
2406:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
2407:../uvc.c      **** 
2408:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
2409:../uvc.c      **** 					interStabuf.size   = 1024;
2410:../uvc.c      **** 					interStabuf.status = 0;
2411:../uvc.c      **** 
2412:../uvc.c      **** 					interStabuf.count = 4;
2413:../uvc.c      **** 
2414:../uvc.c      **** 					/** wait unitll the responses has gone out **/
2415:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
2416:../uvc.c      **** 
2417:../uvc.c      **** 					/** send a interrupt status data **/
2418:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
2419:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
2420:../uvc.c      **** 					{
2421:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
2422:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
2423:../uvc.c      **** 					}
2424:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
2425:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
2426:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
2427:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
2428:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
2429:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
2430:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
2431:../uvc.c      **** 
2432:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
2433:../uvc.c      **** 					interStabuf.size   = 1024;
2434:../uvc.c      **** 					interStabuf.status = 0;
2435:../uvc.c      **** 
2436:../uvc.c      **** 					interStabuf.count = 4;
2437:../uvc.c      **** 
2438:../uvc.c      **** 					/** wait unitll the responses has gone out **/
2439:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
2440:../uvc.c      **** 
2441:../uvc.c      **** 					/** send a interrupt status data **/
2442:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
2443:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
2444:../uvc.c      **** 					{
2445:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
2446:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
2447:../uvc.c      **** 					}
2448:../uvc.c      **** 
2449:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
2450:../uvc.c      **** 					stiflag = 0xFF;
2451:../uvc.c      **** 				}
2452:../uvc.c      **** #else			//for botton simulation
2453:../uvc.c      **** 				if(snapButFlag == 0x0f){
2454:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
2455:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
2456:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
2457:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
2458:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
2459:../uvc.c      **** 
2460:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
2461:../uvc.c      **** 					interStabuf.size   = 1024;
2462:../uvc.c      **** 					interStabuf.status = 0;
2463:../uvc.c      **** 
2464:../uvc.c      **** 					interStabuf.count = 4;
2465:../uvc.c      **** 
2466:../uvc.c      **** 					/** wait unitll the responses has gone out **/
2467:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
2468:../uvc.c      **** 
2469:../uvc.c      **** 					/** send a interrupt status data **/
2470:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
2471:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
2472:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
2473:../uvc.c      **** 					{
2474:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
2475:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
2476:../uvc.c      **** 					}
2477:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
2478:../uvc.c      **** 
2479:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
2480:../uvc.c      **** 				}else if(!snapButFlag){
2481:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
2482:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
2483:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
2484:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
2485:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
2486:../uvc.c      **** 
2487:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
2488:../uvc.c      **** 					interStabuf.size   = 1024;
2489:../uvc.c      **** 					interStabuf.status = 0;
2490:../uvc.c      **** 
2491:../uvc.c      **** 					interStabuf.count = 4;
2492:../uvc.c      **** 
2493:../uvc.c      **** 					/** wait unitll the responses has gone out **/
2494:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
2495:../uvc.c      **** 
2496:../uvc.c      **** 					/** send a interrupt status data **/
2497:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
2498:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
2499:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
2500:../uvc.c      **** 					{
2501:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
2502:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
2503:../uvc.c      **** 					}
2504:../uvc.c      **** 
2505:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
2506:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
2507:../uvc.c      **** 				}
2508:../uvc.c      **** #endif
2509:../uvc.c      **** 
2510:../uvc.c      ****             }
2511:../uvc.c      **** 
2512:../uvc.c      **** 
2513:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2514:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
2515:../uvc.c      ****             {
2516:../uvc.c      ****                 /* Get the command buffer */
2517:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
2518:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2519:../uvc.c      ****                 {
2520:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
2521:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2522:../uvc.c      ****                 }
2523:../uvc.c      **** 
2524:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
2525:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
2526:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
2527:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
2528:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
2529:../uvc.c      ****                  * register value high byte and register value low byte.
2530:../uvc.c      ****                  */
2531:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
2532:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
2533:../uvc.c      ****                 {
2534:../uvc.c      ****                     if (dmaInfo.count == 3)
2535:../uvc.c      ****                     {
2536:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
2537:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
2538:../uvc.c      ****                         dmaInfo.count = 3;
2539:../uvc.c      ****                     }
2540:../uvc.c      ****                     else if (dmaInfo.count == 4)
2541:../uvc.c      ****                     {
2542:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
2543:../uvc.c      ****                         {
2544:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
2545:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
2546:../uvc.c      ****                         }
2547:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
2548:../uvc.c      ****                     }
2549:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
2550:../uvc.c      ****                 }
2551:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
2552:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
2553:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
2554:../uvc.c      ****                  */
2555:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
2556:../uvc.c      ****                 {
2557:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
2558:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
2559:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
2560:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
2561:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
2562:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
2563:../uvc.c      ****                         	break;
2564:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
2565:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
2566:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
2567:../uvc.c      ****                         	break;*/
2568:../uvc.c      ****                     dmaInfo.count -= 2;
2569:../uvc.c      ****                 }
2570:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
2571:../uvc.c      ****                 else
2572:../uvc.c      ****                 {
2573:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
2574:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
2575:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
2576:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
2577:../uvc.c      ****                 }
2578:../uvc.c      **** 
2579:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
2580:../uvc.c      ****                 dmaInfo.size   = 1024;
2581:../uvc.c      ****                 dmaInfo.status = 0;
2582:../uvc.c      **** 
2583:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
2584:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
2585:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2586:../uvc.c      ****                 {
2587:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
2588:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2589:../uvc.c      ****                 }
2590:../uvc.c      **** 
2591:../uvc.c      ****                 /* Wait until the response has gone out. */
2592:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
2593:../uvc.c      **** 
2594:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
2595:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2596:../uvc.c      ****                 {
2597:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
2598:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2599:../uvc.c      ****                 }
2600:../uvc.c      ****             }
2601:../uvc.c      **** #endif
2602:../uvc.c      ****         }
2603:../uvc.c      ****         /* Allow other ready threads to run. */
2604:../uvc.c      ****         CyU3PThreadRelinquish ();
2605:../uvc.c      ****     }
2606:../uvc.c      **** }
2607:../uvc.c      **** 
2608:../uvc.c      **** /*
2609:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
2610:../uvc.c      ****  * added 10/2013
2611:../uvc.c      ****  */
2612:../uvc.c      **** /*
2613:../uvc.c      **** static uint8_t timeDelay[64] = {
2614:../uvc.c      **** 
2615:../uvc.c      **** };
2616:../uvc.c      **** */
2617:../uvc.c      **** 
2618:../uvc.c      **** static uint8_t timercount = 0;
2619:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  47              		.loc 1 2619 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              	.LVL3:
  52 0014 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
  53              	.LCFI0:
  54              		.cfi_def_cfa_offset 36
  55              		.cfi_offset 4, -36
  56              		.cfi_offset 5, -32
  57              		.cfi_offset 6, -28
  58              		.cfi_offset 7, -24
  59              		.cfi_offset 8, -20
  60              		.cfi_offset 9, -16
  61              		.cfi_offset 10, -12
  62              		.cfi_offset 11, -8
  63              		.cfi_offset 14, -4
2620:../uvc.c      **** 
2621:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
2622:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2623:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2624:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
2625:../uvc.c      **** 	VdstateDes *lcStaDes;
2626:../uvc.c      **** 	uint32_t flag = 0;
2627:../uvc.c      **** 	uint8_t  cmdFlag = 0;
2628:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
2629:../uvc.c      **** 	uint8_t i, curFlagIdx;
2630:../uvc.c      **** 	uint16_t delaytime;
2631:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
2632:../uvc.c      **** 
2633:../uvc.c      **** #if 0 //for test the command queue
2634:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
2635:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
2636:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
2637:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
2638:../uvc.c      **** 		lcCmdDes += 1;
2639:../uvc.c      **** 	}
2640:../uvc.c      **** #endif
2641:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
2642:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  64              		.loc 1 2642 0
  65 0018 24029FE5 		ldr	r0, .L25
  66              	.LVL4:
2619:../uvc.c      **** 
  67              		.loc 1 2619 0
  68 001c 1CD04DE2 		sub	sp, sp, #28
  69              	.LCFI1:
  70              		.cfi_def_cfa_offset 64
2626:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  71              		.loc 1 2626 0
  72 0020 00C0A0E3 		mov	ip, #0
  73              		.loc 1 2642 0
  74 0024 FA2FA0E3 		mov	r2, #1000
  75 0028 2C30A0E3 		mov	r3, #44
  76 002c 0C10A0E1 		mov	r1, ip
  77 0030 04C08DE5 		str	ip, [sp, #4]
  78 0034 08C08DE5 		str	ip, [sp, #8]
  79 0038 00208DE5 		str	r2, [sp]
  80 003c 0C308DE5 		str	r3, [sp, #12]
  81 0040 00229FE5 		ldr	r2, .L25+4
  82 0044 0B30A0E3 		mov	r3, #11
2626:../uvc.c      **** 	uint8_t  cmdFlag = 0;
  83              		.loc 1 2626 0
  84 0048 14C08DE5 		str	ip, [sp, #20]
  85              	.LVL5:
  86              		.loc 1 2642 0
  87 004c FEFFFFEB 		bl	_txe_timer_create
  88              	.LVL6:
2643:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  89              		.loc 1 2643 0
  90 0050 FEFFFFEB 		bl	_tx_time_get
  91              	.LVL7:
2644:../uvc.c      **** 	CyU3PThreadSleep(50);
2645:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
2646:../uvc.c      **** 
2647:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  92              		.loc 1 2647 0
  93 0054 F0519FE5 		ldr	r5, .L25+8
2643:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  94              		.loc 1 2643 0
  95 0058 F0119FE5 		ldr	r1, .L25+12
  96 005c 0020A0E1 		mov	r2, r0
  97 0060 0400A0E3 		mov	r0, #4
  98 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  99              	.LVL8:
2644:../uvc.c      **** 	CyU3PThreadSleep(50);
 100              		.loc 1 2644 0
 101 0068 3200A0E3 		mov	r0, #50
 102 006c FEFFFFEB 		bl	_tx_thread_sleep
 103              	.LVL9:
2645:../uvc.c      **** 
 104              		.loc 1 2645 0
 105 0070 CC019FE5 		ldr	r0, .L25
 106 0074 FEFFFFEB 		bl	_txe_timer_activate
 107              	.LVL10:
 108              		.loc 1 2647 0
 109 0078 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 110 007c 000052E3 		cmp	r2, #0
 111 0080 0300001A 		bne	.L5
 112              	.L6:
2648:../uvc.c      ****         /* Allow other ready threads to run. */
2649:../uvc.c      **** 
2650:../uvc.c      ****         CyU3PThreadRelinquish ();
 113              		.loc 1 2650 0
 114 0084 FEFFFFEB 		bl	_txe_thread_relinquish
 115              	.LVL11:
2647:../uvc.c      ****         /* Allow other ready threads to run. */
 116              		.loc 1 2647 0
 117 0088 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 118 008c 000052E3 		cmp	r2, #0
 119 0090 FBFFFF0A 		beq	.L6
 120              	.L5:
2651:../uvc.c      **** 	}
2652:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 121              		.loc 1 2652 0
 122 0094 103095E5 		ldr	r3, [r5, #16]
 123 0098 0400A0E3 		mov	r0, #4
 124 009c 3C3093E5 		ldr	r3, [r3, #60]
 125 00a0 AC119FE5 		ldr	r1, .L25+16
 126 00a4 FEFFFFEB 		bl	CyU3PDebugPrint
 127              	.LVL12:
 128 00a8 A8819FE5 		ldr	r8, .L25+20
 129 00ac A8619FE5 		ldr	r6, .L25+24
 130 00b0 A8A19FE5 		ldr	r10, .L25+28
2653:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
2654:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
2655:../uvc.c      **** 	//CyU3PThreadSleep(100);
2656:../uvc.c      **** 	//SetCurCmd();
2657:../uvc.c      **** 	/*********** the loop of the thread ***********/
2658:../uvc.c      **** 	for(;;){
2659:../uvc.c      **** 
2660:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 131              		.loc 1 2660 0
 132 00b4 0890A0E1 		mov	r9, r8
 133 00b8 0070E0E3 		mvn	r7, #0
 134              	.L19:
 135 00bc 14308DE2 		add	r3, sp, #20
 136 00c0 0320A0E3 		mov	r2, #3
 137 00c4 2010A0E3 		mov	r1, #32
 138 00c8 00708DE5 		str	r7, [sp]
 139 00cc 84019FE5 		ldr	r0, .L25+20
 140 00d0 FEFFFFEB 		bl	_txe_event_flags_get
 141              	.LVL13:
2661:../uvc.c      **** 		//CyU3PDebugPrint (4, "In I2C loop timercounter %d cmdFlag 0x%x\r\n", timercount, cmdFlag);
2662:../uvc.c      **** /*  // for test GPIO output
2663:../uvc.c      **** 		if(trigger)
2664:../uvc.c      **** 		{
2665:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
2666:../uvc.c      **** 			{
2667:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
2668:../uvc.c      **** 			}
2669:../uvc.c      **** 
2670:../uvc.c      **** 		}else{
2671:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
2672:../uvc.c      **** 			{
2673:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
2674:../uvc.c      **** 			}
2675:../uvc.c      **** 
2676:../uvc.c      **** 		}
2677:../uvc.c      **** */
2678:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 142              		.loc 1 2678 0
 143 00d4 0010E0E3 		mvn	r1, #0
 144 00d8 1C0096E5 		ldr	r0, [r6, #28]
 145 00dc FEFFFFEB 		bl	_txe_mutex_get
 146              	.LVL14:
2679:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
2680:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
2681:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
2682:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
2683:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
2684:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
2685:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
2686:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2687:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
2688:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
2689:../uvc.c      **** #endif
2690:../uvc.c      **** 				}
2691:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
2692:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
2693:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
2694:../uvc.c      **** 			}
2695:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 147              		.loc 1 2695 0
 148 00e0 1C0096E5 		ldr	r0, [r6, #28]
 149 00e4 FEFFFFEB 		bl	_txe_mutex_put
 150              	.LVL15:
2696:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
2697:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 151              		.loc 1 2697 0
 152 00e8 1C0095E5 		ldr	r0, [r5, #28]
 153 00ec 0010E0E3 		mvn	r1, #0
 154 00f0 FEFFFFEB 		bl	_txe_mutex_get
 155              	.LVL16:
2698:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 156              		.loc 1 2698 0
 157 00f4 104095E5 		ldr	r4, [r5, #16]
 158              	.LVL17:
2699:../uvc.c      **** 
2700:../uvc.c      **** 				/*
2701:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
2702:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
2703:../uvc.c      **** 				*/
2704:../uvc.c      **** 
2705:../uvc.c      **** 				/* find a available command */
2706:../uvc.c      **** 				i = 0;
2707:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 159              		.loc 1 2707 0
 160 00f8 3C3094E5 		ldr	r3, [r4, #60]
 161 00fc 000053E3 		cmp	r3, #0
 162 0100 0900001A 		bne	.L7
 163 0104 40B0A0E3 		mov	fp, #64
 164 0108 010000EA 		b	.L10
 165              	.LVL18:
 166              	.L8:
 167              		.loc 1 2707 0 is_stmt 0 discriminator 2
 168 010c FFB013E2 		ands	fp, r3, #255
 169 0110 2D00000A 		beq	.L23
 170              	.L10:
2708:../uvc.c      **** 					i++;
2709:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 171              		.loc 1 2709 0 is_stmt 1
 172 0114 344094E5 		ldr	r4, [r4, #52]
 173              	.LVL19:
 174 0118 01304BE2 		sub	r3, fp, #1
2707:../uvc.c      **** 					i++;
 175              		.loc 1 2707 0
 176 011c 3C2094E5 		ldr	r2, [r4, #60]
 177 0120 000052E3 		cmp	r2, #0
 178 0124 F8FFFF0A 		beq	.L8
 179 0128 104085E5 		str	r4, [r5, #16]
 180              	.L7:
 181              	.LVL20:
 182 012c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
2710:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
2711:../uvc.c      **** 				}
2712:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
2713:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
2714:../uvc.c      **** 					i = lcCmdDes->curNum;
2715:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
2716:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
2717:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
2718:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
2719:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 183              		.loc 1 2719 0
 184 0130 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 185 0134 833083E0 		add	r3, r3, r3, asl #1
 186 0138 833084E0 		add	r3, r4, r3, asl #1
 187 013c 20C04CE2 		sub	ip, ip, #32
2715:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 188              		.loc 1 2715 0
 189 0140 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 190              	.LVL21:
2716:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 191              		.loc 1 2716 0
 192 0144 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 193              	.LVL22:
2717:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 194              		.loc 1 2717 0
 195 0148 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 196              	.LVL23:
2718:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 197              		.loc 1 2718 0
 198 014c B8B0D3E1 		ldrh	fp, [r3, #8]
 199              	.LVL24:
 200              		.loc 1 2719 0
 201 0150 03005CE3 		cmp	ip, #3
 202 0154 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 203 0158 360000EA 		b	.L16
 204              	.L20:
 205 015c 6C010000 		.word	.L13
 206 0160 6C010000 		.word	.L13
 207 0164 BC010000 		.word	.L15
 208 0168 BC010000 		.word	.L15
 209              	.L13:
2720:../uvc.c      **** 						case 0x20:
2721:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
2722:../uvc.c      **** 							delaytime = 500;
2723:../uvc.c      **** 							break;
2724:../uvc.c      **** 						case 0x21:
2725:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 210              		.loc 1 2725 0
 211 016c 5230A0E3 		mov	r3, #82
 212              	.LVL25:
 213 0170 FEFFFFEB 		bl	SensorSetIrisControl
 214              	.LVL26:
2726:../uvc.c      **** 							delaytime = 500;
2727:../uvc.c      **** 							break;
 215              		.loc 1 2727 0
 216 0174 7D1FA0E3 		mov	r1, #500
 217              	.LVL27:
 218              	.L12:
2728:../uvc.c      **** 						case 0x22:
2729:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
2730:../uvc.c      **** 							delaytime = 300;
2731:../uvc.c      **** 							break;
2732:../uvc.c      **** 						case 0x23:
2733:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//opt Zoom
2734:../uvc.c      **** 							delaytime = 300;
2735:../uvc.c      **** 							break;
2736:../uvc.c      **** 						default:
2737:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
2738:../uvc.c      **** 							break;
2739:../uvc.c      **** 					}
2740:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
2741:../uvc.c      **** 					/** timer's ticket modify **/
2742:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 219              		.loc 1 2742 0
 220 0178 0020A0E3 		mov	r2, #0
 221 017c C0009FE5 		ldr	r0, .L25
 222 0180 FEFFFFEB 		bl	_txe_timer_change
 223              	.LVL28:
2743:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 224              		.loc 1 2743 0
 225 0184 B8009FE5 		ldr	r0, .L25
 226 0188 FEFFFFEB 		bl	_txe_timer_activate
 227              	.LVL29:
2744:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
2745:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
2746:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2747:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
2748:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
2749:../uvc.c      **** #endif
2750:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 228              		.loc 1 2750 0
 229 018c 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 230 0190 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 231 0194 030052E1 		cmp	r2, r3
 232 0198 1D00000A 		beq	.L24
2751:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
2752:../uvc.c      **** 						if(0 && (lcCmdDes->CmdID >= EXUAOFFSET)){
2753:../uvc.c      **** 							;//ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET+4)][16] = CyFalse;
2754:../uvc.c      **** 						}else{
2755:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
2756:../uvc.c      **** 						}
2757:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
2758:../uvc.c      **** 					}else{
2759:../uvc.c      **** 						lcCmdDes->curNum ++;
 233              		.loc 1 2759 0
 234 019c 013083E2 		add	r3, r3, #1
2760:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 235              		.loc 1 2760 0
 236 01a0 0F20A0E3 		mov	r2, #15
2759:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 237              		.loc 1 2759 0
 238 01a4 0130C4E5 		strb	r3, [r4, #1]
 239              		.loc 1 2760 0
 240 01a8 3C2084E5 		str	r2, [r4, #60]
 241              	.LVL30:
 242              	.L18:
2761:../uvc.c      **** 					}
2762:../uvc.c      **** 				}else{
2763:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0); //the free I2C commands timer pace (no setting comman
2764:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
2765:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
2766:../uvc.c      **** 					if(timercount >= 3){
2767:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
2768:../uvc.c      **** 							curFlag[curFlagIdx] = 0;
2769:../uvc.c      **** 						}
2770:../uvc.c      **** 							timercount = 0;
2771:../uvc.c      **** 
2772:../uvc.c      **** 					}else{
2773:../uvc.c      **** 							timercount++;
2774:../uvc.c      **** 					}
2775:../uvc.c      **** 				}
2776:../uvc.c      **** 			}
2777:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 243              		.loc 1 2777 0
 244 01ac 1C0095E5 		ldr	r0, [r5, #28]
 245 01b0 FEFFFFEB 		bl	_txe_mutex_put
 246              	.LVL31:
2778:../uvc.c      **** /*
2779:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
2780:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
2781:../uvc.c      **** */
2782:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2783:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
2784:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
2785:../uvc.c      **** #endif
2786:../uvc.c      **** 
2787:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
2788:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
2789:../uvc.c      **** #if 0
2790:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
2791:../uvc.c      **** 
2792:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
2793:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
2794:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
2795:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
2796:../uvc.c      **** 			    i = 0;
2797:../uvc.c      **** 				 switch(cmdCopyIdx)
2798:../uvc.c      **** 				 {
2799:../uvc.c      **** 					 case BrgtCtlID1:
2800:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
2801:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2802:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
2803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2804:../uvc.c      **** 							 i++;
2805:../uvc.c      **** 						 }
2806:../uvc.c      **** 						 else{
2807:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
2808:../uvc.c      **** 						 }
2809:../uvc.c      **** 
2810:../uvc.c      **** 						 CyU3PBusyWait(500);
2811:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
2812:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
2813:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2814:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
2815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2816:../uvc.c      **** 						 }
2817:../uvc.c      **** 						 else{
2818:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
2819:../uvc.c      **** 						 }
2820:../uvc.c      **** 						 break;
2821:../uvc.c      **** 					 case HueCtlID5:
2822:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
2823:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2824:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
2825:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2826:../uvc.c      **** 						 }
2827:../uvc.c      **** 						 else{
2828:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
2829:../uvc.c      **** 						 }
2830:../uvc.c      **** 						 break;
2831:../uvc.c      **** 					 case SaturCtlID6:
2832:../uvc.c      **** 					 case WBTLevCtlID10:
2833:../uvc.c      **** 					 default:
2834:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
2835:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2836:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
2837:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2838:../uvc.c      **** 						 }
2839:../uvc.c      **** 						 else{
2840:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
2841:../uvc.c      **** 						 }
2842:../uvc.c      **** 						 break;
2843:../uvc.c      **** 				 }
2844:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
2845:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
2846:../uvc.c      **** 			}
2847:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
2848:../uvc.c      **** #endif
2849:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
2850:../uvc.c      **** 		/* Allow other ready threads to run. */
2851:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
2852:../uvc.c      **** 			CyU3PThreadRelinquish ();
 247              		.loc 1 2852 0
 248 01b4 FEFFFFEB 		bl	_txe_thread_relinquish
 249              	.LVL32:
2853:../uvc.c      **** 		}
 250              		.loc 1 2853 0
 251 01b8 BFFFFFEA 		b	.L19
 252              	.LVL33:
 253              	.L15:
2733:../uvc.c      **** 							delaytime = 300;
 254              		.loc 1 2733 0
 255 01bc 8230A0E3 		mov	r3, #130
 256              	.LVL34:
 257 01c0 FEFFFFEB 		bl	SensorSetIrisControl
 258              	.LVL35:
2735:../uvc.c      **** 						default:
 259              		.loc 1 2735 0
 260 01c4 4B1FA0E3 		mov	r1, #300
 261 01c8 EAFFFFEA 		b	.L12
 262              	.LVL36:
 263              	.L23:
2763:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 264              		.loc 1 2763 0
 265 01cc 0B20A0E1 		mov	r2, fp
 266 01d0 FA1FA0E3 		mov	r1, #1000
 267 01d4 68009FE5 		ldr	r0, .L25
 268 01d8 104085E5 		str	r4, [r5, #16]
 269 01dc FEFFFFEB 		bl	_txe_timer_change
 270              	.LVL37:
2764:../uvc.c      **** 					//CyU3PDebugPrint (4, "I2Ctimer counter %d", timercount);
 271              		.loc 1 2764 0
 272 01e0 5C009FE5 		ldr	r0, .L25
 273 01e4 FEFFFFEB 		bl	_txe_timer_activate
 274              	.LVL38:
2766:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 275              		.loc 1 2766 0
 276 01e8 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 277 01ec 020052E3 		cmp	r2, #2
2773:../uvc.c      **** 					}
 278              		.loc 1 2773 0
 279 01f0 01208292 		addls	r2, r2, #1
 280 01f4 2820C995 		strlsb	r2, [r9, #40]
2766:../uvc.c      **** 						for(curFlagIdx = 0; curFlagIdx<64; curFlagIdx++){
 281              		.loc 1 2766 0
 282 01f8 EBFFFF9A 		bls	.L18
 283 01fc 60009FE5 		ldr	r0, .L25+32
 284 0200 0B10A0E1 		mov	r1, fp
 285 0204 4020A0E3 		mov	r2, #64
 286 0208 FEFFFFEB 		bl	memset
 287              	.LVL39:
2770:../uvc.c      **** 
 288              		.loc 1 2770 0
 289 020c 28B0C9E5 		strb	fp, [r9, #40]
 290 0210 E5FFFFEA 		b	.L18
 291              	.LVL40:
 292              	.L24:
2755:../uvc.c      **** 						}
 293              		.loc 1 2755 0
 294 0214 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
2757:../uvc.c      **** 					}else{
 295              		.loc 1 2757 0
 296 0218 342094E5 		ldr	r2, [r4, #52]
2755:../uvc.c      **** 						}
 297              		.loc 1 2755 0
 298 021c 833083E0 		add	r3, r3, r3, asl #1
 299 0220 83118AE0 		add	r1, r10, r3, asl #3
2751:../uvc.c      **** 						if(0 && (lcCmdDes->CmdID >= EXUAOFFSET)){
 300              		.loc 1 2751 0
 301 0224 0030A0E3 		mov	r3, #0
2755:../uvc.c      **** 						}
 302              		.loc 1 2755 0
 303 0228 1030C1E5 		strb	r3, [r1, #16]
2751:../uvc.c      **** 						if(0 && (lcCmdDes->CmdID >= EXUAOFFSET)){
 304              		.loc 1 2751 0
 305 022c 3C3084E5 		str	r3, [r4, #60]
2757:../uvc.c      **** 					}else{
 306              		.loc 1 2757 0
 307 0230 102085E5 		str	r2, [r5, #16]
 308 0234 DCFFFFEA 		b	.L18
 309              	.LVL41:
 310              	.L16:
2737:../uvc.c      **** 							break;
 311              		.loc 1 2737 0
 312 0238 FEFFFFEB 		bl	SensorSetControl
 313              	.LVL42:
 314 023c 0B10A0E1 		mov	r1, fp
2738:../uvc.c      **** 					}
 315              		.loc 1 2738 0
 316 0240 CCFFFFEA 		b	.L12
 317              	.L26:
 318              		.align	2
 319              	.L25:
 320 0244 00000000 		.word	I2CCmdTimer
 321 0248 00000000 		.word	I2CCmdCb
 322 024c 00000000 		.word	cmdQu
 323 0250 00000000 		.word	.LC0
 324 0254 14000000 		.word	.LC1
 325 0258 00000000 		.word	.LANCHOR0
 326 025c 00000000 		.word	statQu
 327 0260 00000000 		.word	.LANCHOR1
 328 0264 2C000000 		.word	.LANCHOR0+44
 329              		.cfi_endproc
 330              	.LFE22:
 332              		.align	2
 333              		.global	CyFxUvcApplnDmaCallback
 335              	CyFxUvcApplnDmaCallback:
 336              	.LFB7:
 806:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 337              		.loc 1 806 0
 338              		.cfi_startproc
 339              		@ args = 0, pretend = 0, frame = 0
 340              		@ frame_needed = 0, uses_anonymous_args = 0
 341              	.LVL43:
 810:../uvc.c      ****     {
 342              		.loc 1 810 0
 343 0268 080051E3 		cmp	r1, #8
 806:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 344              		.loc 1 806 0
 345 026c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 346              	.LCFI2:
 347              		.cfi_def_cfa_offset 20
 348              		.cfi_offset 4, -20
 349              		.cfi_offset 5, -16
 350              		.cfi_offset 6, -12
 351              		.cfi_offset 7, -8
 352              		.cfi_offset 14, -4
 353 0270 0250A0E1 		mov	r5, r2
 354 0274 0CD04DE2 		sub	sp, sp, #12
 355              	.LCFI3:
 356              		.cfi_def_cfa_offset 32
 810:../uvc.c      ****     {
 357              		.loc 1 810 0
 358 0278 0B00000A 		beq	.L38
 849:../uvc.c      ****     {
 359              		.loc 1 849 0
 360 027c 100051E3 		cmp	r1, #16
 361 0280 0700001A 		bne	.L27
 851:../uvc.c      ****         streamingStarted = CyTrue;
 362              		.loc 1 851 0
 363 0284 74319FE5 		ldr	r3, .L41
 852:../uvc.c      ****     }
 364              		.loc 1 852 0
 365 0288 0110A0E3 		mov	r1, #1
 366              	.LVL44:
 851:../uvc.c      ****         streamingStarted = CyTrue;
 367              		.loc 1 851 0
 368 028c BE27D3E1 		ldrh	r2, [r3, #126]
 369              	.LVL45:
 852:../uvc.c      ****     }
 370              		.loc 1 852 0
 371 0290 801083E5 		str	r1, [r3, #128]
 851:../uvc.c      ****         streamingStarted = CyTrue;
 372              		.loc 1 851 0
 373 0294 012082E0 		add	r2, r2, r1
 374 0298 0228A0E1 		mov	r2, r2, asl #16
 375 029c 2228A0E1 		mov	r2, r2, lsr #16
 376 02a0 BE27C3E1 		strh	r2, [r3, #126]	@ movhi
 377              	.LVL46:
 378              	.L27:
 854:../uvc.c      **** 
 379              		.loc 1 854 0
 380 02a4 0CD08DE2 		add	sp, sp, #12
 381              		@ sp needed
 382 02a8 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 383              	.LVL47:
 384              	.L38:
 812:../uvc.c      ****             {
 385              		.loc 1 812 0
 386 02ac 50319FE5 		ldr	r3, .L41+4
 387 02b0 B420D2E1 		ldrh	r2, [r2, #4]
 388              	.LVL48:
 814:../uvc.c      ****                 fb++;
 389              		.loc 1 814 0
 390 02b4 006095E5 		ldr	r6, [r5]
 812:../uvc.c      ****             {
 391              		.loc 1 812 0
 392 02b8 030052E1 		cmp	r2, r3
 393 02bc 3300000A 		beq	.L39
 394              	.LVL49:
 395              	.LBB8:
 396              	.LBB9:
 464:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 397              		.loc 1 464 0
 398 02c0 40719FE5 		ldr	r7, .L41+8
 463:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 399              		.loc 1 463 0
 400 02c4 0010E0E3 		mvn	r1, #0
 401              	.LVL50:
 402 02c8 3C019FE5 		ldr	r0, .L41+12
 403              	.LVL51:
 404 02cc FEFFFFEB 		bl	_txe_mutex_get
 405              	.LVL52:
 464:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 406              		.loc 1 464 0
 407 02d0 031C87E2 		add	r1, r7, #768
 408 02d4 0C20A0E3 		mov	r2, #12
 409 02d8 0C0046E2 		sub	r0, r6, #12
 410              	.LVL53:
 411 02dc FEFFFFEB 		bl	CyU3PMemCopy
 412              	.LVL54:
 465:../uvc.c      **** 
 413              		.loc 1 465 0
 414 02e0 24019FE5 		ldr	r0, .L41+12
 415 02e4 FEFFFFEB 		bl	_txe_mutex_put
 416              	.LVL55:
 470:../uvc.c      ****     }
 417              		.loc 1 470 0
 418 02e8 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 419              	.LBE9:
 420              	.LBE8:
 821:../uvc.c      ****                 pbc = input->buffer_p.count;
 421              		.loc 1 821 0
 422 02ec 0C419FE5 		ldr	r4, .L41
 423              	.LBB11:
 424              	.LBB10:
 470:../uvc.c      ****     }
 425              		.loc 1 470 0
 426 02f0 023083E3 		orr	r3, r3, #2
 427 02f4 0B3046E5 		strb	r3, [r6, #-11]
 428              	.LBE10:
 429              	.LBE11:
 825:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 430              		.loc 1 825 0
 431 02f8 741094E5 		ldr	r1, [r4, #116]
 821:../uvc.c      ****                 pbc = input->buffer_p.count;
 432              		.loc 1 821 0
 433 02fc BE26D4E1 		ldrh	r2, [r4, #110]
 822:../uvc.c      ****                // hitFV = CyTrue;
 434              		.loc 1 822 0
 435 0300 B430D5E1 		ldrh	r3, [r5, #4]
 821:../uvc.c      ****                 pbc = input->buffer_p.count;
 436              		.loc 1 821 0
 437 0304 012082E2 		add	r2, r2, #1
 825:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 438              		.loc 1 825 0
 439 0308 0F0051E3 		cmp	r1, #15
 821:../uvc.c      ****                 pbc = input->buffer_p.count;
 440              		.loc 1 821 0
 441 030c BE26C4E1 		strh	r2, [r4, #110]	@ movhi
 822:../uvc.c      ****                // hitFV = CyTrue;
 442              		.loc 1 822 0
 443 0310 B037C4E1 		strh	r3, [r4, #112]	@ movhi
 825:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 444              		.loc 1 825 0
 445 0314 2D00000A 		beq	.L40
 446              	.L31:
 833:../uvc.c      ****             }
 447              		.loc 1 833 0
 448 0318 0120A0E3 		mov	r2, #1
 449 031c 782084E5 		str	r2, [r4, #120]
 450              	.LVL56:
 451              	.L30:
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 452              		.loc 1 837 0
 453 0320 BC27D4E1 		ldrh	r2, [r4, #124]
 838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 454              		.loc 1 838 0
 455 0324 0C1083E2 		add	r1, r3, #12
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 456              		.loc 1 837 0
 457 0328 013082E2 		add	r3, r2, #1
 838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 458              		.loc 1 838 0
 459 032c 0118A0E1 		mov	r1, r1, asl #16
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 460              		.loc 1 837 0
 461 0330 0338A0E1 		mov	r3, r3, asl #16
 838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 462              		.loc 1 838 0
 463 0334 2118A0E1 		mov	r1, r1, lsr #16
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 464              		.loc 1 837 0
 465 0338 2338A0E1 		mov	r3, r3, lsr #16
 838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 466              		.loc 1 838 0
 467 033c 0020A0E3 		mov	r2, #0
 468 0340 C8009FE5 		ldr	r0, .L41+16
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 469              		.loc 1 837 0
 470 0344 BC37C4E1 		strh	r3, [r4, #124]	@ movhi
 838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 471              		.loc 1 838 0
 472 0348 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 473              	.LVL57:
 837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 474              		.loc 1 837 0
 475 034c AC109FE5 		ldr	r1, .L41
 841:../uvc.c      ****             {
 476              		.loc 1 841 0
 477 0350 002050E2 		subs	r2, r0, #0
 478 0354 D2FFFF0A 		beq	.L27
 843:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 479              		.loc 1 843 0
 480 0358 BC07D1E1 		ldrh	r0, [r1, #124]
 481              	.LVL58:
 844:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 482              		.loc 1 844 0
 483 035c B430D5E1 		ldrh	r3, [r5, #4]
 843:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 484              		.loc 1 843 0
 485 0360 010040E2 		sub	r0, r0, #1
 486 0364 0008A0E1 		mov	r0, r0, asl #16
 487 0368 2008A0E1 		mov	r0, r0, lsr #16
 488 036c BC07C1E1 		strh	r0, [r1, #124]	@ movhi
 844:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
 489              		.loc 1 844 0
 490 0370 BC07D1E1 		ldrh	r0, [r1, #124]
 491 0374 BE17D1E1 		ldrh	r1, [r1, #126]
 492 0378 001061E0 		rsb	r1, r1, r0
 493 037c 00108DE5 		str	r1, [sp]
 494 0380 0400A0E3 		mov	r0, #4
 495 0384 88109FE5 		ldr	r1, .L41+20
 496 0388 FEFFFFEB 		bl	CyU3PDebugPrint
 497              	.LVL59:
 498 038c C4FFFFEA 		b	.L27
 499              	.LVL60:
 500              	.L39:
 501              	.LBB12:
 502              	.LBB13:
 463:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 503              		.loc 1 463 0
 504 0390 0010E0E3 		mvn	r1, #0
 505              	.LVL61:
 506              	.LBE13:
 507              	.LBE12:
 815:../uvc.c      ****             }
 508              		.loc 1 815 0
 509 0394 64409FE5 		ldr	r4, .L41
 510              	.LBB16:
 511              	.LBB14:
 463:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 512              		.loc 1 463 0
 513 0398 6C009FE5 		ldr	r0, .L41+12
 514              	.LVL62:
 515 039c FEFFFFEB 		bl	_txe_mutex_get
 516              	.LVL63:
 517              	.LBE14:
 518              	.LBE16:
 814:../uvc.c      ****                 fb++;
 519              		.loc 1 814 0
 520 03a0 0C6046E2 		sub	r6, r6, #12
 521              	.LVL64:
 522              	.LBB17:
 523              	.LBB15:
 464:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 524              		.loc 1 464 0
 525 03a4 0C20A0E3 		mov	r2, #12
 526 03a8 0600A0E1 		mov	r0, r6
 527 03ac 64109FE5 		ldr	r1, .L41+24
 528 03b0 FEFFFFEB 		bl	CyU3PMemCopy
 529              	.LVL65:
 465:../uvc.c      **** 
 530              		.loc 1 465 0
 531 03b4 50009FE5 		ldr	r0, .L41+12
 532 03b8 FEFFFFEB 		bl	_txe_mutex_put
 533              	.LVL66:
 534              	.LBE15:
 535              	.LBE17:
 815:../uvc.c      ****             }
 536              		.loc 1 815 0
 537 03bc BC26D4E1 		ldrh	r2, [r4, #108]
 538 03c0 B430D5E1 		ldrh	r3, [r5, #4]
 539 03c4 012082E2 		add	r2, r2, #1
 540 03c8 BC26C4E1 		strh	r2, [r4, #108]	@ movhi
 541 03cc D3FFFFEA 		b	.L30
 542              	.LVL67:
 543              	.L40:
 826:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 544              		.loc 1 826 0
 545 03d0 0010E0E3 		mvn	r1, #0
 546 03d4 30009FE5 		ldr	r0, .L41+12
 547 03d8 FEFFFFEB 		bl	_txe_mutex_get
 548              	.LVL68:
 827:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 549              		.loc 1 827 0
 550 03dc 0133D7E5 		ldrb	r3, [r7, #769]	@ zero_extendqisi2
 828:../uvc.c      ****                 	//stiflag = 0xAA;
 551              		.loc 1 828 0
 552 03e0 24009FE5 		ldr	r0, .L41+12
 827:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 553              		.loc 1 827 0
 554 03e4 DF3003E2 		and	r3, r3, #223
 555 03e8 0133C7E5 		strb	r3, [r7, #769]
 828:../uvc.c      ****                 	//stiflag = 0xAA;
 556              		.loc 1 828 0
 557 03ec FEFFFFEB 		bl	_txe_mutex_put
 558              	.LVL69:
 830:../uvc.c      ****                 }
 559              		.loc 1 830 0
 560 03f0 0030A0E3 		mov	r3, #0
 561 03f4 743084E5 		str	r3, [r4, #116]
 562 03f8 B430D5E1 		ldrh	r3, [r5, #4]
 563 03fc C5FFFFEA 		b	.L31
 564              	.L42:
 565              		.align	2
 566              	.L41:
 567 0400 00000000 		.word	.LANCHOR0
 568 0404 F03F0000 		.word	16368
 569 0408 00000000 		.word	.LANCHOR1
 570 040c 00000000 		.word	imgHdMux
 571 0410 00000000 		.word	glChHandleUVCStream
 572 0414 38000000 		.word	.LC2
 573 0418 00030000 		.word	.LANCHOR1+768
 574              		.cfi_endproc
 575              	.LFE7:
 577              		.align	2
 579              	CyFxUVCApplnUSBEventCB:
 580              	.LFB5:
 519:../uvc.c      **** 	CyU3PDebugPrint (4, "\nthe event...0x%x 0x%x\r\n", evtype, evdata);
 581              		.loc 1 519 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 8
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              	.LVL70:
 586 041c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 587              	.LCFI4:
 588              		.cfi_def_cfa_offset 12
 589              		.cfi_offset 4, -12
 590              		.cfi_offset 5, -8
 591              		.cfi_offset 14, -4
 520:../uvc.c      **** #if 1 //old fusion
 592              		.loc 1 520 0
 593 0420 0020A0E1 		mov	r2, r0
 519:../uvc.c      **** 	CyU3PDebugPrint (4, "\nthe event...0x%x 0x%x\r\n", evtype, evdata);
 594              		.loc 1 519 0
 595 0424 0040A0E1 		mov	r4, r0
 596 0428 14D04DE2 		sub	sp, sp, #20
 597              	.LCFI5:
 598              		.cfi_def_cfa_offset 32
 519:../uvc.c      **** 	CyU3PDebugPrint (4, "\nthe event...0x%x 0x%x\r\n", evtype, evdata);
 599              		.loc 1 519 0
 600 042c 0150A0E1 		mov	r5, r1
 520:../uvc.c      **** #if 1 //old fusion
 601              		.loc 1 520 0
 602 0430 0130A0E1 		mov	r3, r1
 603 0434 0400A0E3 		mov	r0, #4
 604              	.LVL71:
 605 0438 90119FE5 		ldr	r1, .L61
 606              	.LVL72:
 607 043c FEFFFFEB 		bl	CyU3PDebugPrint
 608              	.LVL73:
 522:../uvc.c      ****     {
 609              		.loc 1 522 0
 610 0440 050054E3 		cmp	r4, #5
 611 0444 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 612 0448 590000EA 		b	.L44
 613              	.L46:
 614 044c CC040000 		.word	.L45
 615 0450 3C050000 		.word	.L47
 616 0454 B8040000 		.word	.L48
 617 0458 B4050000 		.word	.L44
 618 045c 64040000 		.word	.L49
 619 0460 CC040000 		.word	.L45
 620              	.L49:
 525:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 621              		.loc 1 525 0
 622 0464 68119FE5 		ldr	r1, .L61+4
 623 0468 0420A0E1 		mov	r2, r4
 624 046c 0530A0E1 		mov	r3, r5
 625 0470 0400A0E3 		mov	r0, #4
 626              	.L60:
 535:../uvc.c      ****             streamingStarted = CyFalse;
 627              		.loc 1 535 0
 628 0474 5C419FE5 		ldr	r4, .L61+8
 533:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 629              		.loc 1 533 0
 630 0478 FEFFFFEB 		bl	CyU3PDebugPrint
 631              	.LVL74:
 534:../uvc.c      ****             gpif_initialized = 0;
 632              		.loc 1 534 0
 633 047c 0100A0E3 		mov	r0, #1
 634 0480 FEFFFFEB 		bl	CyU3PGpifDisable
 635              	.LVL75:
 535:../uvc.c      ****             streamingStarted = CyFalse;
 636              		.loc 1 535 0
 637 0484 00C0A0E3 		mov	ip, #0
 638              	.LBB34:
 639              	.LBB35:
 503:../uvc.c      **** 	{
 640              		.loc 1 503 0
 641 0488 00C08DE5 		str	ip, [sp]
 642 048c 0400A0E1 		mov	r0, r4
 643 0490 0110A0E3 		mov	r1, #1
 644 0494 0220A0E3 		mov	r2, #2
 645 0498 0C308DE2 		add	r3, sp, #12
 646              	.LBE35:
 647              	.LBE34:
 535:../uvc.c      ****             streamingStarted = CyFalse;
 648              		.loc 1 535 0
 649 049c 84C084E5 		str	ip, [r4, #132]
 536:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 650              		.loc 1 536 0
 651 04a0 80C084E5 		str	ip, [r4, #128]
 652              	.LBB37:
 653              	.LBB36:
 503:../uvc.c      **** 	{
 654              		.loc 1 503 0
 655 04a4 FEFFFFEB 		bl	_txe_event_flags_get
 656              	.LVL76:
 657 04a8 005050E2 		subs	r5, r0, #0
 658 04ac 3600000A 		beq	.L58
 659              	.L43:
 660              	.LBE36:
 661              	.LBE37:
 642:../uvc.c      **** 
 662              		.loc 1 642 0
 663 04b0 14D08DE2 		add	sp, sp, #20
 664              		@ sp needed
 665 04b4 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 666              	.L48:
 533:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 667              		.loc 1 533 0
 668 04b8 0420A0E1 		mov	r2, r4
 669 04bc 0530A0E1 		mov	r3, r5
 670 04c0 0400A0E3 		mov	r0, #4
 671 04c4 10119FE5 		ldr	r1, .L61+12
 672 04c8 E9FFFFEA 		b	.L60
 673              	.L45:
 553:../uvc.c      ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 674              		.loc 1 553 0
 675 04cc 04519FE5 		ldr	r5, .L61+8
 554:../uvc.c      ****                 glIsConfigured = CyTrue;
 676              		.loc 1 554 0
 677 04d0 053054E2 		subs	r3, r4, #5
 678 04d4 004073E2 		rsbs	r4, r3, #0
 679 04d8 0340B4E0 		adcs	r4, r4, r3
 561:../uvc.c      ****             {
 680              		.loc 1 561 0
 681 04dc 903095E5 		ldr	r3, [r5, #144]
 553:../uvc.c      ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 682              		.loc 1 553 0
 683 04e0 00C0A0E3 		mov	ip, #0
 561:../uvc.c      ****             {
 684              		.loc 1 561 0
 685 04e4 0C0053E1 		cmp	r3, ip
 686 04e8 8C4085E5 		str	r4, [r5, #140]
 553:../uvc.c      ****             if (evtype == CY_U3P_USB_EVENT_SETCONF)
 687              		.loc 1 553 0
 688 04ec 80C085E5 		str	ip, [r5, #128]
 561:../uvc.c      ****             {
 689              		.loc 1 561 0
 690 04f0 EEFFFF0A 		beq	.L43
 691              	.LBB38:
 692              	.LBB39:
 503:../uvc.c      **** 	{
 693              		.loc 1 503 0
 694 04f4 00C08DE5 		str	ip, [sp]
 695 04f8 0500A0E1 		mov	r0, r5
 696 04fc 0110A0E3 		mov	r1, #1
 697 0500 0220A0E3 		mov	r2, #2
 698 0504 0C308DE2 		add	r3, sp, #12
 699              	.LBE39:
 700              	.LBE38:
 563:../uvc.c      ****                 //esUVCUvcApplnStop ();
 701              		.loc 1 563 0
 702 0508 94C085E5 		str	ip, [r5, #148]
 703              	.LBB43:
 704              	.LBB42:
 503:../uvc.c      **** 	{
 705              		.loc 1 503 0
 706 050c FEFFFFEB 		bl	_txe_event_flags_get
 707              	.LVL77:
 708 0510 004050E2 		subs	r4, r0, #0
 709 0514 E5FFFF1A 		bne	.L43
 710              	.LBB40:
 711              	.LBB41:
 506:../uvc.c      **** 
 712              		.loc 1 506 0
 713 0518 0500A0E1 		mov	r0, r5
 714 051c 0110E0E3 		mvn	r1, #1
 715 0520 0220A0E3 		mov	r2, #2
 716 0524 FEFFFFEB 		bl	_txe_event_flags_set
 717              	.LVL78:
 509:../uvc.c      **** 	}
 718              		.loc 1 509 0
 719 0528 0500A0E1 		mov	r0, r5
 720 052c 0420A0E1 		mov	r2, r4
 721 0530 0210A0E3 		mov	r1, #2
 722 0534 FEFFFFEB 		bl	_txe_event_flags_set
 723              	.LVL79:
 724 0538 DCFFFFEA 		b	.L43
 725              	.L47:
 726              	.LBE41:
 727              	.LBE40:
 728              	.LBE42:
 729              	.LBE43:
 541:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 730              		.loc 1 541 0
 731 053c 0420A0E1 		mov	r2, r4
 732 0540 0530A0E1 		mov	r3, r5
 543:../uvc.c      ****             isUsbConnected = CyFalse;
 733              		.loc 1 543 0
 734 0544 8C409FE5 		ldr	r4, .L61+8
 541:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 735              		.loc 1 541 0
 736 0548 90109FE5 		ldr	r1, .L61+16
 737 054c 0400A0E3 		mov	r0, #4
 738 0550 FEFFFFEB 		bl	CyU3PDebugPrint
 739              	.LVL80:
 542:../uvc.c      ****             gpif_initialized = 0;
 740              		.loc 1 542 0
 741 0554 0100A0E3 		mov	r0, #1
 742 0558 FEFFFFEB 		bl	CyU3PGpifDisable
 743              	.LVL81:
 543:../uvc.c      ****             isUsbConnected = CyFalse;
 744              		.loc 1 543 0
 745 055c 00C0A0E3 		mov	ip, #0
 746              	.LBB44:
 747              	.LBB45:
 503:../uvc.c      **** 	{
 748              		.loc 1 503 0
 749 0560 00C08DE5 		str	ip, [sp]
 750 0564 0400A0E1 		mov	r0, r4
 751 0568 0110A0E3 		mov	r1, #1
 752 056c 0220A0E3 		mov	r2, #2
 753 0570 0C308DE2 		add	r3, sp, #12
 754              	.LBE45:
 755              	.LBE44:
 543:../uvc.c      ****             isUsbConnected = CyFalse;
 756              		.loc 1 543 0
 757 0574 84C084E5 		str	ip, [r4, #132]
 544:../uvc.c      ****             streamingStarted = CyFalse;
 758              		.loc 1 544 0
 759 0578 88C084E5 		str	ip, [r4, #136]
 545:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 760              		.loc 1 545 0
 761 057c 80C084E5 		str	ip, [r4, #128]
 762              	.LBB49:
 763              	.LBB48:
 503:../uvc.c      **** 	{
 764              		.loc 1 503 0
 765 0580 FEFFFFEB 		bl	_txe_event_flags_get
 766              	.LVL82:
 767 0584 005050E2 		subs	r5, r0, #0
 768 0588 C8FFFF1A 		bne	.L43
 769              	.L58:
 770              	.LBB46:
 771              	.LBB47:
 506:../uvc.c      **** 
 772              		.loc 1 506 0
 773 058c 0400A0E1 		mov	r0, r4
 774 0590 0110E0E3 		mvn	r1, #1
 775 0594 0220A0E3 		mov	r2, #2
 776 0598 FEFFFFEB 		bl	_txe_event_flags_set
 777              	.LVL83:
 509:../uvc.c      **** 	}
 778              		.loc 1 509 0
 779 059c 0400A0E1 		mov	r0, r4
 780 05a0 0520A0E1 		mov	r2, r5
 781 05a4 0210A0E3 		mov	r1, #2
 782 05a8 FEFFFFEB 		bl	_txe_event_flags_set
 783              	.LVL84:
 784              	.LBE47:
 785              	.LBE46:
 786              	.LBE48:
 787              	.LBE49:
 642:../uvc.c      **** 
 788              		.loc 1 642 0
 789 05ac 14D08DE2 		add	sp, sp, #20
 790              		@ sp needed
 791 05b0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 792              	.L44:
 576:../uvc.c      ****             break;
 793              		.loc 1 576 0
 794 05b4 0420A0E1 		mov	r2, r4
 795 05b8 0530A0E1 		mov	r3, r5
 796 05bc 20109FE5 		ldr	r1, .L61+20
 797 05c0 0400A0E3 		mov	r0, #4
 798 05c4 FEFFFFEB 		bl	CyU3PDebugPrint
 799              	.LVL85:
 642:../uvc.c      **** 
 800              		.loc 1 642 0
 801 05c8 14D08DE2 		add	sp, sp, #20
 802              		@ sp needed
 803 05cc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 804              	.L62:
 805              		.align	2
 806              	.L61:
 807 05d0 80000000 		.word	.LC3
 808 05d4 9C000000 		.word	.LC4
 809 05d8 00000000 		.word	.LANCHOR0
 810 05dc BC000000 		.word	.LC5
 811 05e0 E0000000 		.word	.LC6
 812 05e4 00010000 		.word	.LC7
 813              		.cfi_endproc
 814              	.LFE5:
 816              		.align	2
 818              	CyFxUVCApplnUSBSetupCB:
 819              	.LFB6:
 650:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 820              		.loc 1 650 0
 821              		.cfi_startproc
 822              		@ args = 0, pretend = 0, frame = 8
 823              		@ frame_needed = 0, uses_anonymous_args = 0
 824              	.LVL86:
 825 05e8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 826              	.LCFI6:
 827              		.cfi_def_cfa_offset 36
 828              		.cfi_offset 4, -36
 829              		.cfi_offset 5, -32
 830              		.cfi_offset 6, -28
 831              		.cfi_offset 7, -24
 832              		.cfi_offset 8, -20
 833              		.cfi_offset 9, -16
 834              		.cfi_offset 10, -12
 835              		.cfi_offset 11, -8
 836              		.cfi_offset 14, -4
 655:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 837              		.loc 1 655 0
 838 05ec EC429FE5 		ldr	r4, .L97
 656:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 839              		.loc 1 656 0
 840 05f0 EC729FE5 		ldr	r7, .L97+4
 659:../uvc.c      **** 
 841              		.loc 1 659 0
 842 05f4 ECB29FE5 		ldr	fp, .L97+8
 658:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 843              		.loc 1 658 0
 844 05f8 EC829FE5 		ldr	r8, .L97+12
 650:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 845              		.loc 1 650 0
 846 05fc 01E0A0E1 		mov	lr, r1
 656:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 847              		.loc 1 656 0
 848 0600 FFAC00E2 		and	r10, r0, #65280
 849 0604 0118A0E1 		mov	r1, r1, asl #16
 850              	.LVL87:
 657:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 851              		.loc 1 657 0
 852 0608 E0929FE5 		ldr	r9, .L97+16
 650:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 853              		.loc 1 650 0
 854 060c 1CD04DE2 		sub	sp, sp, #28
 855              	.LCFI7:
 856              		.cfi_def_cfa_offset 64
 650:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 857              		.loc 1 650 0
 858 0610 00C0A0E1 		mov	ip, r0
 657:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 859              		.loc 1 657 0
 860 0614 2068A0E1 		mov	r6, r0, lsr #16
 659:../uvc.c      **** 
 861              		.loc 1 659 0
 862 0618 2E58A0E1 		mov	r5, lr, lsr #16
 656:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 863              		.loc 1 656 0
 864 061c 2AA4A0E1 		mov	r10, r10, lsr #8
 865 0620 2118A0E1 		mov	r1, r1, lsr #16
 662:../uvc.c      **** #endif
 866              		.loc 1 662 0
 867 0624 04108DE5 		str	r1, [sp, #4]
 868 0628 00608DE5 		str	r6, [sp]
 869 062c 08508DE5 		str	r5, [sp, #8]
 870 0630 FF2000E2 		and	r2, r0, #255
 655:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 871              		.loc 1 655 0
 872 0634 00C0C4E5 		strb	ip, [r4]
 662:../uvc.c      **** #endif
 873              		.loc 1 662 0
 874 0638 0A30A0E1 		mov	r3, r10
 875 063c 0400A0E3 		mov	r0, #4
 876              	.LVL88:
 877 0640 AC129FE5 		ldr	r1, .L97+20
 656:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 878              		.loc 1 656 0
 879 0644 00A0C7E5 		strb	r10, [r7]
 659:../uvc.c      **** 
 880              		.loc 1 659 0
 881 0648 B050CBE1 		strh	r5, [fp]	@ movhi
 658:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 882              		.loc 1 658 0
 883 064c B0E0C8E1 		strh	lr, [r8]	@ movhi
 657:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 884              		.loc 1 657 0
 885 0650 B060C9E1 		strh	r6, [r9]	@ movhi
 662:../uvc.c      **** #endif
 886              		.loc 1 662 0
 887 0654 FEFFFFEB 		bl	CyU3PDebugPrint
 888              	.LVL89:
 666:../uvc.c      ****     {
 889              		.loc 1 666 0
 890 0658 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 891 065c 020054E3 		cmp	r4, #2
 892 0660 4D00000A 		beq	.L65
 893 0664 0600009A 		bls	.L94
 894 0668 210054E3 		cmp	r4, #33
 895 066c 3C00000A 		beq	.L68
 896 0670 A10054E3 		cmp	r4, #161
 897 0674 3A00000A 		beq	.L68
 898              	.L82:
 651:../uvc.c      ****     uint32_t status;
 899              		.loc 1 651 0
 900 0678 0000A0E3 		mov	r0, #0
 901              	.LVL90:
 902              	.L64:
 793:../uvc.c      **** 
 903              		.loc 1 793 0
 904 067c 1CD08DE2 		add	sp, sp, #28
 905              		@ sp needed
 906 0680 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 907              	.LVL91:
 908              	.L94:
 666:../uvc.c      ****     {
 909              		.loc 1 666 0
 910 0684 010054E3 		cmp	r4, #1
 911 0688 FAFFFF1A 		bne	.L82
 706:../uvc.c      ****             {
 912              		.loc 1 706 0
 913 068c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 914 0690 0B0053E3 		cmp	r3, #11
 915 0694 F7FFFF1A 		bne	.L82
 710:../uvc.c      ****                 {
 916              		.loc 1 710 0
 917 0698 B040D8E1 		ldrh	r4, [r8]
 918 069c 010054E3 		cmp	r4, #1
 919 06a0 F4FFFF1A 		bne	.L82
 710:../uvc.c      ****                 {
 920              		.loc 1 710 0 is_stmt 0 discriminator 1
 921 06a4 B050D9E1 		ldrh	r5, [r9]
 922 06a8 000055E3 		cmp	r5, #0
 923 06ac F1FFFF1A 		bne	.L82
 715:../uvc.c      ****                     streamingStarted = CyFalse;
 924              		.loc 1 715 0 is_stmt 1
 925 06b0 40629FE5 		ldr	r6, .L97+24
 713:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 926              		.loc 1 713 0
 927 06b4 40129FE5 		ldr	r1, .L97+28
 928 06b8 0400A0E3 		mov	r0, #4
 929 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 930              	.LVL92:
 714:../uvc.c      ****                     gpif_initialized = 0;
 931              		.loc 1 714 0
 932 06c0 0400A0E1 		mov	r0, r4
 933 06c4 FEFFFFEB 		bl	CyU3PGpifDisable
 934              	.LVL93:
 718:../uvc.c      ****                     CyU3PBusyWait (100);
 935              		.loc 1 718 0
 936 06c8 0410A0E1 		mov	r1, r4
 937 06cc 8300A0E3 		mov	r0, #131
 715:../uvc.c      ****                     streamingStarted = CyFalse;
 938              		.loc 1 715 0
 939 06d0 845086E5 		str	r5, [r6, #132]
 716:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 940              		.loc 1 716 0
 941 06d4 805086E5 		str	r5, [r6, #128]
 718:../uvc.c      ****                     CyU3PBusyWait (100);
 942              		.loc 1 718 0
 943 06d8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 944              	.LVL94:
 719:../uvc.c      **** 
 945              		.loc 1 719 0
 946 06dc 6400A0E3 		mov	r0, #100
 947 06e0 FEFFFFEB 		bl	CyFx3BusyWait
 948              	.LVL95:
 722:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 949              		.loc 1 722 0
 950 06e4 14029FE5 		ldr	r0, .L97+32
 951 06e8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 952              	.LVL96:
 723:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 953              		.loc 1 723 0
 954 06ec 8300A0E3 		mov	r0, #131
 955 06f0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 956              	.LVL97:
 724:../uvc.c      ****                     CyU3PBusyWait (100);
 957              		.loc 1 724 0
 958 06f4 0510A0E1 		mov	r1, r5
 959 06f8 8300A0E3 		mov	r0, #131
 960 06fc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 961              	.LVL98:
 725:../uvc.c      **** 
 962              		.loc 1 725 0
 963 0700 6400A0E3 		mov	r0, #100
 964 0704 FEFFFFEB 		bl	CyFx3BusyWait
 965              	.LVL99:
 728:../uvc.c      ****                     uvcHandleReq = CyTrue;
 966              		.loc 1 728 0
 967 0708 0420A0E1 		mov	r2, r4
 968 070c 0510A0E1 		mov	r1, r5
 969 0710 8300A0E3 		mov	r0, #131
 970 0714 FEFFFFEB 		bl	CyU3PUsbStall
 971              	.LVL100:
 731:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 972              		.loc 1 731 0
 973 0718 FEFFFFEB 		bl	CyU3PUsbAckSetup
 974              	.LVL101:
 975              	.LBB58:
 976              	.LBB59:
 503:../uvc.c      **** 	{
 977              		.loc 1 503 0
 978 071c 00508DE5 		str	r5, [sp]
 979 0720 0410A0E1 		mov	r1, r4
 980              	.LBE59:
 981              	.LBE58:
 733:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 982              		.loc 1 733 0
 983 0724 944086E5 		str	r4, [r6, #148]
 984              	.LBB63:
 985              	.LBB62:
 503:../uvc.c      **** 	{
 986              		.loc 1 503 0
 987 0728 0600A0E1 		mov	r0, r6
 988 072c 0220A0E3 		mov	r2, #2
 989 0730 14308DE2 		add	r3, sp, #20
 990 0734 FEFFFFEB 		bl	_txe_event_flags_get
 991              	.LVL102:
 992 0738 004050E2 		subs	r4, r0, #0
 993 073c 1300001A 		bne	.L93
 994              	.LBB60:
 995              	.LBB61:
 506:../uvc.c      **** 
 996              		.loc 1 506 0
 997 0740 0600A0E1 		mov	r0, r6
 998 0744 0110E0E3 		mvn	r1, #1
 999 0748 0220A0E3 		mov	r2, #2
 1000 074c FEFFFFEB 		bl	_txe_event_flags_set
 1001              	.LVL103:
 509:../uvc.c      **** 	}
 1002              		.loc 1 509 0
 1003 0750 0600A0E1 		mov	r0, r6
 1004 0754 0420A0E1 		mov	r2, r4
 1005 0758 0210A0E3 		mov	r1, #2
 1006 075c FEFFFFEB 		bl	_txe_event_flags_set
 1007              	.LVL104:
 1008 0760 0A0000EA 		b	.L93
 1009              	.LVL105:
 1010              	.L68:
 1011              	.LBE61:
 1012              	.LBE60:
 1013              	.LBE62:
 1014              	.LBE63:
 671:../uvc.c      ****             {
 1015              		.loc 1 671 0
 1016 0764 0040D8E5 		ldrb	r4, [r8]	@ zero_extendqisi2
 1017 0768 000054E3 		cmp	r4, #0
 1018 076c 1700000A 		beq	.L69
 1019 0770 010054E3 		cmp	r4, #1
 1020 0774 BFFFFF1A 		bne	.L82
 1021              	.LVL106:
 689:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1022              		.loc 1 689 0
 1023 0778 0020A0E3 		mov	r2, #0
 1024 077c 74019FE5 		ldr	r0, .L97+24
 1025 0780 0810A0E3 		mov	r1, #8
 1026 0784 FEFFFFEB 		bl	_txe_event_flags_set
 1027              	.LVL107:
 691:../uvc.c      ****                         {
 1028              		.loc 1 691 0
 1029 0788 002050E2 		subs	r2, r0, #0
 1030 078c 1D00001A 		bne	.L95
 1031              	.LVL108:
 1032              	.L93:
 675:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1033              		.loc 1 675 0
 1034 0790 0100A0E3 		mov	r0, #1
 1035              	.LVL109:
 793:../uvc.c      **** 
 1036              		.loc 1 793 0
 1037 0794 1CD08DE2 		add	sp, sp, #28
 1038              		@ sp needed
 1039 0798 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1040              	.LVL110:
 1041              	.L65:
 741:../uvc.c      ****             {
 1042              		.loc 1 741 0
 1043 079c 0050D7E5 		ldrb	r5, [r7]	@ zero_extendqisi2
 1044 07a0 010055E3 		cmp	r5, #1
 1045 07a4 B3FFFF1A 		bne	.L82
 743:../uvc.c      ****                 {
 1046              		.loc 1 743 0
 1047 07a8 B060D8E1 		ldrh	r6, [r8]
 1048 07ac 830056E3 		cmp	r6, #131
 1049 07b0 B0FFFF1A 		bne	.L82
 749:../uvc.c      ****                     {
 1050              		.loc 1 749 0
 1051 07b4 3C819FE5 		ldr	r8, .L97+24
 1052 07b8 807098E5 		ldr	r7, [r8, #128]
 1053 07bc 010057E3 		cmp	r7, #1
 1054 07c0 1900000A 		beq	.L96
 1055              	.LVL111:
 781:../uvc.c      ****                     }
 1056              		.loc 1 781 0
 1057 07c4 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1058              	.LVL112:
 780:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1059              		.loc 1 780 0
 1060 07c8 0500A0E1 		mov	r0, r5
 1061 07cc AAFFFFEA 		b	.L64
 1062              	.LVL113:
 1063              	.L69:
 676:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1064              		.loc 1 676 0
 1065 07d0 0420A0E1 		mov	r2, r4
 1066 07d4 1C019FE5 		ldr	r0, .L97+24
 1067 07d8 0410A0E3 		mov	r1, #4
 1068 07dc FEFFFFEB 		bl	_txe_event_flags_set
 1069              	.LVL114:
 678:../uvc.c      ****                         {
 1070              		.loc 1 678 0
 1071 07e0 002050E2 		subs	r2, r0, #0
 1072 07e4 E9FFFF0A 		beq	.L93
 680:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1073              		.loc 1 680 0
 1074 07e8 14119FE5 		ldr	r1, .L97+36
 1075 07ec 0400A0E3 		mov	r0, #4
 1076              	.LVL115:
 1077 07f0 FEFFFFEB 		bl	CyU3PDebugPrint
 1078              	.LVL116:
 681:../uvc.c      ****                         }
 1079              		.loc 1 681 0
 1080 07f4 0400A0E1 		mov	r0, r4
 1081 07f8 0420A0E1 		mov	r2, r4
 1082 07fc 0110A0E3 		mov	r1, #1
 1083 0800 FEFFFFEB 		bl	CyU3PUsbStall
 1084              	.LVL117:
 1085 0804 E1FFFFEA 		b	.L93
 1086              	.LVL118:
 1087              	.L95:
 694:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1088              		.loc 1 694 0
 1089 0808 F8109FE5 		ldr	r1, .L97+40
 1090 080c 0400A0E3 		mov	r0, #4
 1091              	.LVL119:
 1092 0810 FEFFFFEB 		bl	CyU3PDebugPrint
 1093              	.LVL120:
 695:../uvc.c      ****                         }
 1094              		.loc 1 695 0
 1095 0814 0000A0E3 		mov	r0, #0
 1096 0818 0020A0E1 		mov	r2, r0
 1097 081c 0410A0E1 		mov	r1, r4
 1098 0820 FEFFFFEB 		bl	CyU3PUsbStall
 1099              	.LVL121:
 688:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1100              		.loc 1 688 0
 1101 0824 0400A0E1 		mov	r0, r4
 1102 0828 93FFFFEA 		b	.L64
 1103              	.LVL122:
 1104              	.L96:
 751:../uvc.c      **** 
 1105              		.loc 1 751 0
 1106 082c D8109FE5 		ldr	r1, .L97+44
 1107 0830 0400A0E3 		mov	r0, #4
 1108 0834 FEFFFFEB 		bl	CyU3PDebugPrint
 1109              	.LVL123:
 754:../uvc.c      ****                         gpif_initialized = 0;
 1110              		.loc 1 754 0
 1111 0838 0700A0E1 		mov	r0, r7
 1112 083c FEFFFFEB 		bl	CyU3PGpifDisable
 1113              	.LVL124:
 755:../uvc.c      ****                         streamingStarted = CyFalse;
 1114              		.loc 1 755 0
 1115 0840 0050A0E3 		mov	r5, #0
 759:../uvc.c      ****                         CyU3PBusyWait (100);
 1116              		.loc 1 759 0
 1117 0844 0710A0E1 		mov	r1, r7
 1118 0848 0600A0E1 		mov	r0, r6
 755:../uvc.c      ****                         streamingStarted = CyFalse;
 1119              		.loc 1 755 0
 1120 084c 845088E5 		str	r5, [r8, #132]
 756:../uvc.c      **** 
 1121              		.loc 1 756 0
 1122 0850 805088E5 		str	r5, [r8, #128]
 759:../uvc.c      ****                         CyU3PBusyWait (100);
 1123              		.loc 1 759 0
 1124 0854 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1125              	.LVL125:
 760:../uvc.c      **** 
 1126              		.loc 1 760 0
 1127 0858 6400A0E3 		mov	r0, #100
 1128 085c FEFFFFEB 		bl	CyFx3BusyWait
 1129              	.LVL126:
 763:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1130              		.loc 1 763 0
 1131 0860 98009FE5 		ldr	r0, .L97+32
 1132 0864 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1133              	.LVL127:
 764:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1134              		.loc 1 764 0
 1135 0868 0600A0E1 		mov	r0, r6
 1136 086c FEFFFFEB 		bl	CyU3PUsbFlushEp
 1137              	.LVL128:
 765:../uvc.c      ****                         CyU3PBusyWait (100);
 1138              		.loc 1 765 0
 1139 0870 0510A0E1 		mov	r1, r5
 1140 0874 0600A0E1 		mov	r0, r6
 1141 0878 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1142              	.LVL129:
 766:../uvc.c      **** 
 1143              		.loc 1 766 0
 1144 087c 6400A0E3 		mov	r0, #100
 1145 0880 FEFFFFEB 		bl	CyFx3BusyWait
 1146              	.LVL130:
 769:../uvc.c      **** 
 1147              		.loc 1 769 0
 1148 0884 0510A0E1 		mov	r1, r5
 1149 0888 0720A0E1 		mov	r2, r7
 1150 088c 0600A0E1 		mov	r0, r6
 1151 0890 FEFFFFEB 		bl	CyU3PUsbStall
 1152              	.LVL131:
 773:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1153              		.loc 1 773 0
 1154 0894 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1155              	.LVL132:
 1156              	.LBB64:
 1157              	.LBB65:
 503:../uvc.c      **** 	{
 1158              		.loc 1 503 0
 1159 0898 00508DE5 		str	r5, [sp]
 1160 089c 0710A0E1 		mov	r1, r7
 1161 08a0 0800A0E1 		mov	r0, r8
 1162 08a4 0420A0E1 		mov	r2, r4
 1163 08a8 14308DE2 		add	r3, sp, #20
 1164              	.LBE65:
 1165              	.LBE64:
 775:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1166              		.loc 1 775 0
 1167 08ac 947088E5 		str	r7, [r8, #148]
 1168              	.LBB69:
 1169              	.LBB68:
 503:../uvc.c      **** 	{
 1170              		.loc 1 503 0
 1171 08b0 FEFFFFEB 		bl	_txe_event_flags_get
 1172              	.LVL133:
 1173 08b4 005050E2 		subs	r5, r0, #0
 1174 08b8 B4FFFF1A 		bne	.L93
 1175              	.LBB66:
 1176              	.LBB67:
 506:../uvc.c      **** 
 1177              		.loc 1 506 0
 1178 08bc 0420A0E1 		mov	r2, r4
 1179 08c0 0800A0E1 		mov	r0, r8
 1180 08c4 0110E0E3 		mvn	r1, #1
 1181 08c8 FEFFFFEB 		bl	_txe_event_flags_set
 1182              	.LVL134:
 509:../uvc.c      **** 	}
 1183              		.loc 1 509 0
 1184 08cc 0800A0E1 		mov	r0, r8
 1185 08d0 0410A0E1 		mov	r1, r4
 1186 08d4 0520A0E1 		mov	r2, r5
 1187 08d8 FEFFFFEB 		bl	_txe_event_flags_set
 1188              	.LVL135:
 1189 08dc ABFFFFEA 		b	.L93
 1190              	.L98:
 1191              		.align	2
 1192              	.L97:
 1193 08e0 00000000 		.word	bmReqType
 1194 08e4 00000000 		.word	bRequest
 1195 08e8 00000000 		.word	wLength
 1196 08ec 00000000 		.word	wIndex
 1197 08f0 00000000 		.word	wValue
 1198 08f4 18010000 		.word	.LC8
 1199 08f8 00000000 		.word	.LANCHOR0
 1200 08fc D4010000 		.word	.LC11
 1201 0900 00000000 		.word	glChHandleUVCStream
 1202 0904 68010000 		.word	.LC9
 1203 0908 A0010000 		.word	.LC10
 1204 090c EC010000 		.word	.LC12
 1205              	.LBE67:
 1206              	.LBE66:
 1207              	.LBE68:
 1208              	.LBE69:
 1209              		.cfi_endproc
 1210              	.LFE6:
 1212              		.align	2
 1213              		.global	I2CCmdHandler
 1215              	I2CCmdHandler:
 1216              	.LFB0:
 293:../uvc.c      **** ;
 1217              		.loc 1 293 0
 1218              		.cfi_startproc
 1219              		@ args = 0, pretend = 0, frame = 0
 1220              		@ frame_needed = 0, uses_anonymous_args = 0
 1221              		@ link register save eliminated.
 1222 0910 1EFF2FE1 		bx	lr
 1223              		.cfi_endproc
 1224              	.LFE0:
 1226              		.align	2
 1227              		.global	ControlHandle
 1229              	ControlHandle:
 1230              	.LFB1:
 302:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1231              		.loc 1 302 0
 1232              		.cfi_startproc
 1233              		@ args = 0, pretend = 0, frame = 8
 1234              		@ frame_needed = 0, uses_anonymous_args = 0
 1235              	.LVL136:
 309:../uvc.c      ****     	//RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1236              		.loc 1 309 0
 1237 0914 230050E3 		cmp	r0, #35
 302:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 1238              		.loc 1 302 0
 1239 0918 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1240              	.LCFI8:
 1241              		.cfi_def_cfa_offset 36
 1242              		.cfi_offset 4, -36
 1243              		.cfi_offset 5, -32
 1244              		.cfi_offset 6, -28
 1245              		.cfi_offset 7, -24
 1246              		.cfi_offset 8, -20
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 10, -12
 1249              		.cfi_offset 11, -8
 1250              		.cfi_offset 14, -4
 1251 091c 0040A0E1 		mov	r4, r0
 1252              	.LVL137:
 1253 0920 1CD04DE2 		sub	sp, sp, #28
 1254              	.LCFI9:
 1255              		.cfi_def_cfa_offset 64
 309:../uvc.c      ****     	//RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1256              		.loc 1 309 0
 1257 0924 0600008A 		bhi	.L101
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1258              		.loc 1 315 0
 1259 0928 CC229FE5 		ldr	r2, .L118
 1260 092c 803080E0 		add	r3, r0, r0, asl #1
 1261 0930 8331A0E1 		mov	r3, r3, asl #3
 1262 0934 03C082E0 		add	ip, r2, r3
 1263 0938 0380D2E7 		ldrb	r8, [r2, r3]	@ zero_extendqisi2
 1264              	.LVL138:
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1265              		.loc 1 317 0
 1266 093c 0F70DCE5 		ldrb	r7, [ip, #15]	@ zero_extendqisi2
 1267              	.LVL139:
 318:../uvc.c      ****     }
 1268              		.loc 1 318 0
 1269 0940 0260DCE5 		ldrb	r6, [ip, #2]	@ zero_extendqisi2
 1270              	.LVL140:
 1271              	.L101:
 324:../uvc.c      ****     /*
 1272              		.loc 1 324 0
 1273 0944 B4C29FE5 		ldr	ip, .L118+4
 1274 0948 0050DCE5 		ldrb	r5, [ip]	@ zero_extendqisi2
 1275              	.LVL141:
 332:../uvc.c      **** 		 {
 1276              		.loc 1 332 0
 1277 094c 830055E3 		cmp	r5, #131
 1278 0950 8F00000A 		beq	.L103
 1279 0954 1500009A 		bls	.L117
 1280 0958 850055E3 		cmp	r5, #133
 1281 095c 8100000A 		beq	.L108
 1282 0960 6E00003A 		bcc	.L109
 1283 0964 860055E3 		cmp	r5, #134
 1284 0968 4400000A 		beq	.L110
 1285 096c 870055E3 		cmp	r5, #135
 1286 0970 4F00001A 		bne	.L102
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1287              		.loc 1 406 0
 1288 0974 80329FE5 		ldr	r3, .L118
 1289 0978 844084E0 		add	r4, r4, r4, asl #1
 1290 097c 844183E0 		add	r4, r3, r4, asl #3
 1291 0980 7C729FE5 		ldr	r7, .L118+8
 1292              	.LVL142:
 1293 0984 0B20D4E5 		ldrb	r2, [r4, #11]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 1294              		.loc 1 407 0
 1295 0988 0C30D4E5 		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 1296              	.L116:
 409:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1297              		.loc 1 409 0
 1298 098c 981087E2 		add	r1, r7, #152
 1299 0990 0600A0E1 		mov	r0, r6
 1300              	.LVL143:
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1301              		.loc 1 406 0
 1302 0994 9820C7E5 		strb	r2, [r7, #152]
 407:../uvc.c      **** 			 }
 1303              		.loc 1 407 0
 1304 0998 9930C7E5 		strb	r3, [r7, #153]
 409:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1305              		.loc 1 409 0
 1306 099c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1307              	.LVL144:
 411:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 1308              		.loc 1 411 0
 1309 09a0 FF20A0E3 		mov	r2, #255
 1310 09a4 9810D7E5 		ldrb	r1, [r7, #152]	@ zero_extendqisi2
 1311 09a8 0230A0E1 		mov	r3, r2
 1312 09ac 220000EA 		b	.L112
 1313              	.LVL145:
 1314              	.L117:
 332:../uvc.c      **** 		 {
 1315              		.loc 1 332 0
 1316 09b0 810055E3 		cmp	r5, #129
 1317 09b4 4600000A 		beq	.L105
 1318 09b8 2900008A 		bhi	.L106
 1319 09bc 010055E3 		cmp	r5, #1
 1320 09c0 3B00001A 		bne	.L102
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 1321              		.loc 1 413 0
 1322 09c4 38629FE5 		ldr	r6, .L118+8
 1323              	.LVL146:
 1324 09c8 2000A0E3 		mov	r0, #32
 1325              	.LVL147:
 1326 09cc 981086E2 		add	r1, r6, #152
 1327 09d0 16208DE2 		add	r2, sp, #22
 1328 09d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1329              	.LVL148:
 415:../uvc.c      **** 			   {
 1330              		.loc 1 415 0
 1331 09d8 009050E2 		subs	r9, r0, #0
 1332 09dc 7300001A 		bne	.L115
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 1333              		.loc 1 429 0
 1334 09e0 20B29FE5 		ldr	fp, .L118+12
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1335              		.loc 1 417 0
 1336 09e4 98A0D6E5 		ldrb	r10, [r6, #152]	@ zero_extendqisi2
 1337              	.LVL149:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 1338              		.loc 1 429 0
 1339 09e8 0010E0E3 		mvn	r1, #0
 1340 09ec 1C009BE5 		ldr	r0, [fp, #28]
 1341              	.LVL150:
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 1342              		.loc 1 420 0
 1343 09f0 9A60D6E5 		ldrb	r6, [r6, #154]	@ zero_extendqisi2
 1344              	.LVL151:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 1345              		.loc 1 429 0
 1346 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1347              	.LVL152:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1348              		.loc 1 430 0
 1349 09f8 0410A0E1 		mov	r1, r4
 1350 09fc 0820A0E1 		mov	r2, r8
 1351 0a00 0730A0E1 		mov	r3, r7
 1352 0a04 00A08DE5 		str	r10, [sp]
 1353 0a08 04908DE5 		str	r9, [sp, #4]
 1354 0a0c 0B00A0E1 		mov	r0, fp
 1355 0a10 FEFFFFEB 		bl	cmdSet
 1356              	.LVL153:
 431:../uvc.c      **** 
 1357              		.loc 1 431 0
 1358 0a14 1C009BE5 		ldr	r0, [fp, #28]
 1359 0a18 FEFFFFEB 		bl	_txe_mutex_put
 1360              	.LVL154:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 1361              		.loc 1 433 0
 1362 0a1c D8319FE5 		ldr	r3, .L118
 1363 0a20 844084E0 		add	r4, r4, r4, asl #1
 1364              	.LVL155:
 1365 0a24 844183E0 		add	r4, r3, r4, asl #3
 1366 0a28 0620A0E1 		mov	r2, r6
 1367 0a2c 0A30A0E1 		mov	r3, r10
 435:../uvc.c      **** 					 }
 1368              		.loc 1 435 0
 1369 0a30 FF10A0E3 		mov	r1, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 1370              		.loc 1 433 0
 1371 0a34 0DA0C4E5 		strb	r10, [r4, #13]
 434:../uvc.c      **** 							 break;
 1372              		.loc 1 434 0
 1373 0a38 1050C4E5 		strb	r5, [r4, #16]
 1374              	.LVL156:
 1375              	.L112:
 449:../uvc.c      **** }
 1376              		.loc 1 449 0
 1377 0a3c FF00A0E3 		mov	r0, #255
 1378 0a40 00208DE5 		str	r2, [sp]
 1379 0a44 04108DE5 		str	r1, [sp, #4]
 1380 0a48 08008DE5 		str	r0, [sp, #8]
 1381 0a4c 0520A0E1 		mov	r2, r5
 1382 0a50 B4119FE5 		ldr	r1, .L118+16
 1383 0a54 0400A0E3 		mov	r0, #4
 1384 0a58 FEFFFFEB 		bl	CyU3PDebugPrint
 1385              	.LVL157:
 450:../uvc.c      **** /************** CT control requests handler *************************/
 1386              		.loc 1 450 0
 1387 0a5c 1CD08DE2 		add	sp, sp, #28
 1388              		@ sp needed
 1389 0a60 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1390              	.LVL158:
 1391              	.L106:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1392              		.loc 1 372 0
 1393 0a64 90319FE5 		ldr	r3, .L118
 1394 0a68 844084E0 		add	r4, r4, r4, asl #1
 1395 0a6c 844183E0 		add	r4, r3, r4, asl #3
 1396 0a70 8C719FE5 		ldr	r7, .L118+8
 1397              	.LVL159:
 1398 0a74 0320D4E5 		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 1399              		.loc 1 373 0
 1400 0a78 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1401 0a7c C2FFFFEA 		b	.L116
 1402              	.LVL160:
 1403              	.L110:
 398:../uvc.c      **** 		 	 }
 1404              		.loc 1 398 0
 1405 0a80 74319FE5 		ldr	r3, .L118
 1406 0a84 844084E0 		add	r4, r4, r4, asl #1
 1407 0a88 74619FE5 		ldr	r6, .L118+8
 1408              	.LVL161:
 1409 0a8c 844183E0 		add	r4, r3, r4, asl #3
 1410 0a90 0930D4E5 		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 1411 0a94 0610A0E1 		mov	r1, r6
 1412 0a98 9830E1E5 		strb	r3, [r1, #152]!
 400:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1413              		.loc 1 400 0
 1414 0a9c 0100A0E3 		mov	r0, #1
 1415              	.LVL162:
 1416 0aa0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1417              	.LVL163:
 403:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 1418              		.loc 1 403 0
 1419 0aa4 FF20A0E3 		mov	r2, #255
 1420 0aa8 9810D6E5 		ldrb	r1, [r6, #152]	@ zero_extendqisi2
 1421 0aac 0230A0E1 		mov	r3, r2
 1422 0ab0 E1FFFFEA 		b	.L112
 1423              	.LVL164:
 1424              	.L102:
 446:../uvc.c      **** 			  break;
 1425              		.loc 1 446 0
 1426 0ab4 0000A0E3 		mov	r0, #0
 1427              	.LVL165:
 1428 0ab8 0020A0E1 		mov	r2, r0
 1429 0abc 0110A0E3 		mov	r1, #1
 1430 0ac0 FEFFFFEB 		bl	CyU3PUsbStall
 1431              	.LVL166:
 447:../uvc.c      **** 		 }
 1432              		.loc 1 447 0
 1433 0ac4 FF10A0E3 		mov	r1, #255
 1434 0ac8 0120A0E1 		mov	r2, r1
 1435 0acc 0130A0E1 		mov	r3, r1
 1436 0ad0 D9FFFFEA 		b	.L112
 1437              	.LVL167:
 1438              	.L105:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 1439              		.loc 1 348 0
 1440 0ad4 28919FE5 		ldr	r9, .L118+8
 1441 0ad8 04A089E0 		add	r10, r9, r4
 1442 0adc 2C30DAE5 		ldrb	r3, [r10, #44]	@ zero_extendqisi2
 1443 0ae0 000053E3 		cmp	r3, #0
 1444 0ae4 3900000A 		beq	.L113
 1445 0ae8 0C319FE5 		ldr	r3, .L118
 1446 0aec 844084E0 		add	r4, r4, r4, asl #1
 1447 0af0 844183E0 		add	r4, r3, r4, asl #3
 1448 0af4 0D70D4E5 		ldrb	r7, [r4, #13]	@ zero_extendqisi2
 1449              	.LVL168:
 1450              	.L114:
 359:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1451              		.loc 1 359 0
 1452 0af8 0030A0E3 		mov	r3, #0
 364:../uvc.c      **** 
 1453              		.loc 1 364 0
 1454 0afc 0C119FE5 		ldr	r1, .L118+20
 1455 0b00 0600A0E1 		mov	r0, r6
 359:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 1456              		.loc 1 359 0
 1457 0b04 9930C9E5 		strb	r3, [r9, #153]
 1458              	.LVL169:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1459              		.loc 1 358 0
 1460 0b08 9870C9E5 		strb	r7, [r9, #152]
 364:../uvc.c      **** 
 1461              		.loc 1 364 0
 1462 0b0c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1463              	.LVL170:
 369:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 1464              		.loc 1 369 0
 1465 0b10 FF20A0E3 		mov	r2, #255
 1466 0b14 0710A0E1 		mov	r1, r7
 1467 0b18 0230A0E1 		mov	r3, r2
 1468 0b1c C6FFFFEA 		b	.L112
 1469              	.LVL171:
 1470              	.L109:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1471              		.loc 1 388 0
 1472 0b20 D4309FE5 		ldr	r3, .L118
 1473 0b24 844084E0 		add	r4, r4, r4, asl #1
 1474 0b28 D4709FE5 		ldr	r7, .L118+8
 1475              	.LVL172:
 1476 0b2c 844183E0 		add	r4, r3, r4, asl #3
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1477              		.loc 1 389 0
 1478 0b30 0820D4E5 		ldrb	r2, [r4, #8]	@ zero_extendqisi2
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1479              		.loc 1 388 0
 1480 0b34 07C0D4E5 		ldrb	ip, [r4, #7]	@ zero_extendqisi2
 390:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1481              		.loc 1 390 0
 1482 0b38 0030A0E3 		mov	r3, #0
 393:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1483              		.loc 1 393 0
 1484 0b3c 981087E2 		add	r1, r7, #152
 1485 0b40 0600A0E1 		mov	r0, r6
 1486              	.LVL173:
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1487              		.loc 1 389 0
 1488 0b44 9920C7E5 		strb	r2, [r7, #153]
 390:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1489              		.loc 1 390 0
 1490 0b48 9A30C7E5 		strb	r3, [r7, #154]
 391:../uvc.c      **** 		 	 }
 1491              		.loc 1 391 0
 1492 0b4c 9B30C7E5 		strb	r3, [r7, #155]
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1493              		.loc 1 388 0
 1494 0b50 98C0C7E5 		strb	ip, [r7, #152]
 393:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1495              		.loc 1 393 0
 1496 0b54 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1497              	.LVL174:
 395:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 1498              		.loc 1 395 0
 1499 0b58 FF20A0E3 		mov	r2, #255
 1500 0b5c 9810D7E5 		ldrb	r1, [r7, #152]	@ zero_extendqisi2
 1501 0b60 0230A0E1 		mov	r3, r2
 1502 0b64 B4FFFFEA 		b	.L112
 1503              	.LVL175:
 1504              	.L108:
 336:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1505              		.loc 1 336 0
 1506 0b68 94409FE5 		ldr	r4, .L118+8
 337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1507              		.loc 1 337 0
 1508 0b6c 0030A0E3 		mov	r3, #0
 338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1509              		.loc 1 338 0
 1510 0b70 981084E2 		add	r1, r4, #152
 1511 0b74 0200A0E3 		mov	r0, #2
 1512              	.LVL176:
 337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1513              		.loc 1 337 0
 1514 0b78 9930C4E5 		strb	r3, [r4, #153]
 336:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1515              		.loc 1 336 0
 1516 0b7c 9860C4E5 		strb	r6, [r4, #152]
 338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1517              		.loc 1 338 0
 1518 0b80 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1519              	.LVL177:
 340:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 1520              		.loc 1 340 0
 1521 0b84 FF20A0E3 		mov	r2, #255
 1522 0b88 9810D4E5 		ldrb	r1, [r4, #152]	@ zero_extendqisi2
 1523 0b8c 0230A0E1 		mov	r3, r2
 1524 0b90 A9FFFFEA 		b	.L112
 1525              	.LVL178:
 1526              	.L103:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1527              		.loc 1 380 0
 1528 0b94 60309FE5 		ldr	r3, .L118
 1529 0b98 844084E0 		add	r4, r4, r4, asl #1
 1530 0b9c 844183E0 		add	r4, r3, r4, asl #3
 1531 0ba0 5C709FE5 		ldr	r7, .L118+8
 1532              	.LVL179:
 1533 0ba4 0520D4E5 		ldrb	r2, [r4, #5]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 1534              		.loc 1 381 0
 1535 0ba8 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 1536 0bac 76FFFFEA 		b	.L116
 1537              	.LVL180:
 1538              	.L115:
 438:../uvc.c      **** 			   }
 1539              		.loc 1 438 0
 1540 0bb0 0920A0E1 		mov	r2, r9
 1541 0bb4 58109FE5 		ldr	r1, .L118+24
 1542 0bb8 0400A0E3 		mov	r0, #4
 1543              	.LVL181:
 1544 0bbc FEFFFFEB 		bl	CyU3PDebugPrint
 1545              	.LVL182:
 1546 0bc0 FF10A0E3 		mov	r1, #255
 1547 0bc4 0120A0E1 		mov	r2, r1
 1548 0bc8 0130A0E1 		mov	r3, r1
 1549 0bcc 9AFFFFEA 		b	.L112
 1550              	.LVL183:
 1551              	.L113:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 1552              		.loc 1 352 0
 1553 0bd0 0710A0E1 		mov	r1, r7
 1554 0bd4 0800A0E1 		mov	r0, r8
 1555              	.LVL184:
 1556 0bd8 FEFFFFEB 		bl	SensorGetControl
 1557              	.LVL185:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 1558              		.loc 1 353 0
 1559 0bdc 18309FE5 		ldr	r3, .L118
 1560 0be0 844084E0 		add	r4, r4, r4, asl #1
 1561              	.LVL186:
 1562 0be4 844183E0 		add	r4, r3, r4, asl #3
 355:../uvc.c      **** 		 	 		 }
 1563              		.loc 1 355 0
 1564 0be8 0130A0E3 		mov	r3, #1
 1565 0bec 2C30CAE5 		strb	r3, [r10, #44]
 1566 0bf0 0070A0E1 		mov	r7, r0
 1567              	.LVL187:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 1568              		.loc 1 353 0
 1569 0bf4 0D00C4E5 		strb	r0, [r4, #13]
 1570 0bf8 BEFFFFEA 		b	.L114
 1571              	.L119:
 1572              		.align	2
 1573              	.L118:
 1574 0bfc 00000000 		.word	.LANCHOR1
 1575 0c00 00000000 		.word	bRequest
 1576 0c04 00000000 		.word	.LANCHOR0
 1577 0c08 00000000 		.word	cmdQu
 1578 0c0c 40020000 		.word	.LC14
 1579 0c10 98000000 		.word	.LANCHOR0+152
 1580 0c14 10020000 		.word	.LC13
 1581              		.cfi_endproc
 1582              	.LFE1:
 1584              		.align	2
 1585              		.global	CyFxUVCAddHeader
 1587              	CyFxUVCAddHeader:
 1588              	.LFB2:
 461:../uvc.c      ****     /* Copy header to buffer */
 1589              		.loc 1 461 0
 1590              		.cfi_startproc
 1591              		@ args = 0, pretend = 0, frame = 0
 1592              		@ frame_needed = 0, uses_anonymous_args = 0
 1593              	.LVL188:
 1594 0c18 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 1595              	.LCFI10:
 1596              		.cfi_def_cfa_offset 16
 1597              		.cfi_offset 3, -16
 1598              		.cfi_offset 4, -12
 1599              		.cfi_offset 5, -8
 1600              		.cfi_offset 14, -4
 461:../uvc.c      ****     /* Copy header to buffer */
 1601              		.loc 1 461 0
 1602 0c1c 0040A0E1 		mov	r4, r0
 1603 0c20 0150A0E1 		mov	r5, r1
 463:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1604              		.loc 1 463 0
 1605 0c24 30009FE5 		ldr	r0, .L125
 1606              	.LVL189:
 1607 0c28 0010E0E3 		mvn	r1, #0
 1608              	.LVL190:
 1609 0c2c FEFFFFEB 		bl	_txe_mutex_get
 1610              	.LVL191:
 464:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1611              		.loc 1 464 0
 1612 0c30 0400A0E1 		mov	r0, r4
 1613 0c34 24109FE5 		ldr	r1, .L125+4
 1614 0c38 0C20A0E3 		mov	r2, #12
 1615 0c3c FEFFFFEB 		bl	CyU3PMemCopy
 1616              	.LVL192:
 465:../uvc.c      **** 
 1617              		.loc 1 465 0
 1618 0c40 14009FE5 		ldr	r0, .L125
 1619 0c44 FEFFFFEB 		bl	_txe_mutex_put
 1620              	.LVL193:
 468:../uvc.c      ****     {
 1621              		.loc 1 468 0
 1622 0c48 020015E3 		tst	r5, #2
 470:../uvc.c      ****     }
 1623              		.loc 1 470 0
 1624 0c4c 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 1625 0c50 02308313 		orrne	r3, r3, #2
 1626 0c54 0130C415 		strneb	r3, [r4, #1]
 1627 0c58 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 1628              	.L126:
 1629              		.align	2
 1630              	.L125:
 1631 0c5c 00000000 		.word	imgHdMux
 1632 0c60 00030000 		.word	.LANCHOR1+768
 1633              		.cfi_endproc
 1634              	.LFE2:
 1636              		.align	2
 1637              		.global	CyFxAppErrorHandler
 1639              	CyFxAppErrorHandler:
 1640              	.LFB3:
 480:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 1641              		.loc 1 480 0
 1642              		.cfi_startproc
 1643              		@ Volatile: function does not return.
 1644              		@ args = 0, pretend = 0, frame = 0
 1645              		@ frame_needed = 0, uses_anonymous_args = 0
 1646              	.LVL194:
 1647 0c64 08402DE9 		stmfd	sp!, {r3, lr}
 1648              	.LCFI11:
 1649              		.cfi_def_cfa_offset 8
 1650              		.cfi_offset 3, -8
 1651              		.cfi_offset 14, -4
 1652              	.LVL195:
 1653              	.L128:
 490:../uvc.c      ****         CyU3PThreadSleep (1000);
 1654              		.loc 1 490 0 discriminator 1
 1655 0c68 10109FE5 		ldr	r1, .L129
 1656 0c6c 0400A0E3 		mov	r0, #4
 1657 0c70 FEFFFFEB 		bl	CyU3PDebugPrint
 1658              	.LVL196:
 491:../uvc.c      ****     }
 1659              		.loc 1 491 0 discriminator 1
 1660 0c74 FA0FA0E3 		mov	r0, #1000
 1661 0c78 FEFFFFEB 		bl	_tx_thread_sleep
 1662              	.LVL197:
 1663 0c7c F9FFFFEA 		b	.L128
 1664              	.L130:
 1665              		.align	2
 1666              	.L129:
 1667 0c80 90020000 		.word	.LC15
 1668              		.cfi_endproc
 1669              	.LFE3:
 1671              		.align	2
 1672              		.global	UVCAppEP0Thread_Entry
 1674              	UVCAppEP0Thread_Entry:
 1675              	.LFB21:
2304:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 1676              		.loc 1 2304 0
 1677              		.cfi_startproc
 1678              		@ args = 0, pretend = 0, frame = 48
 1679              		@ frame_needed = 0, uses_anonymous_args = 0
 1680              	.LVL198:
 1681 0c84 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1682              	.LCFI12:
 1683              		.cfi_def_cfa_offset 36
 1684              		.cfi_offset 4, -36
 1685              		.cfi_offset 5, -32
 1686              		.cfi_offset 6, -28
 1687              		.cfi_offset 7, -24
 1688              		.cfi_offset 8, -20
 1689              		.cfi_offset 9, -16
 1690              		.cfi_offset 10, -12
 1691              		.cfi_offset 11, -8
 1692              		.cfi_offset 14, -4
 1693 0c88 F4AF9FE5 		ldr	r10, .L438
 1694 0c8c F47F9FE5 		ldr	r7, .L438+4
 1695 0c90 F46F9FE5 		ldr	r6, .L438+8
2380:../uvc.c      ****                 {
 1696              		.loc 1 2380 0
 1697 0c94 F45F9FE5 		ldr	r5, .L438+12
 1698              	.LBB100:
 1699              	.LBB101:
1970:../uvc.c      ****     {
 1700              		.loc 1 1970 0
 1701 0c98 F4BF9FE5 		ldr	fp, .L438+16
 1702              	.LBE101:
 1703              	.LBE100:
2304:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 1704              		.loc 1 2304 0
 1705 0c9c 5CD04DE2 		sub	sp, sp, #92
 1706              	.LCFI13:
 1707              		.cfi_def_cfa_offset 128
 1708              	.LVL199:
2326:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 1709              		.loc 1 2326 0
 1710 0ca0 0A40A0E1 		mov	r4, r10
 1711              	.LVL200:
 1712              	.L346:
 1713 0ca4 0030E0E3 		mvn	r3, #0
 1714 0ca8 00308DE5 		str	r3, [sp]
 1715 0cac D00F9FE5 		ldr	r0, .L438
 1716 0cb0 4C10A0E3 		mov	r1, #76
 1717 0cb4 0120A0E3 		mov	r2, #1
 1718 0cb8 40308DE2 		add	r3, sp, #64
 1719 0cbc FEFFFFEB 		bl	_txe_event_flags_get
 1720              	.LVL201:
 1721 0cc0 000050E3 		cmp	r0, #0
 1722 0cc4 5300001A 		bne	.L133
2330:../uvc.c      ****             {
 1723              		.loc 1 2330 0
 1724 0cc8 883094E5 		ldr	r3, [r4, #136]
 1725 0ccc 000053E3 		cmp	r3, #0
 1726 0cd0 7A00000A 		beq	.L406
 1727              	.L135:
2348:../uvc.c      ****             {
 1728              		.loc 1 2348 0
 1729 0cd4 40309DE5 		ldr	r3, [sp, #64]
 1730 0cd8 040013E3 		tst	r3, #4
 1731 0cdc 1B00000A 		beq	.L137
2350:../uvc.c      ****                 {
 1732              		.loc 1 2350 0
 1733 0ce0 B020D5E1 		ldrh	r2, [r5]
 1734 0ce4 2224A0E1 		mov	r2, r2, lsr #8
 1735 0ce8 030052E3 		cmp	r2, #3
 1736 0cec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1737 0cf0 110000EA 		b	.L138
 1738              	.L140:
 1739 0cf4 3C0D0000 		.word	.L138
 1740 0cf8 200E0000 		.word	.L141
 1741 0cfc 3C0E0000 		.word	.L142
 1742 0d00 3C0D0000 		.word	.L138
 1743              	.L146:
 1744              	.LBB109:
 1745              	.LBB110:
1831:../uvc.c      ****     {
 1746              		.loc 1 1831 0
 1747 0d04 0A0C52E3 		cmp	r2, #2560
 1748 0d08 A101000A 		beq	.L152
 1749 0d0c 0101009A 		bls	.L407
 1750 0d10 0D0C52E3 		cmp	r2, #3328
 1751 0d14 9E01000A 		beq	.L152
 1752 0d18 0E0C52E3 		cmp	r2, #3584
 1753 0d1c C401000A 		beq	.L156
 1754 0d20 030B52E3 		cmp	r2, #3072
 1755 0d24 7301000A 		beq	.L408
 1756              	.L144:
1884:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1757              		.loc 1 1884 0
 1758 0d28 683F9FE5 		ldr	r3, .L438+20
 1759 0d2c 0400A0E3 		mov	r0, #4
 1760 0d30 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1761 0d34 601F9FE5 		ldr	r1, .L438+24
 1762 0d38 FEFFFFEB 		bl	CyU3PDebugPrint
 1763              	.LVL202:
 1764              	.L138:
 1765              	.LBE110:
 1766              	.LBE109:
2371:../uvc.c      ****                         break;
 1767              		.loc 1 2371 0
 1768 0d3c 0000A0E3 		mov	r0, #0
 1769 0d40 0020A0E1 		mov	r2, r0
 1770 0d44 0110A0E3 		mov	r1, #1
 1771 0d48 FEFFFFEB 		bl	CyU3PUsbStall
 1772              	.LVL203:
 1773 0d4c 40309DE5 		ldr	r3, [sp, #64]
 1774              	.L137:
2376:../uvc.c      ****             {
 1775              		.loc 1 2376 0
 1776 0d50 080013E3 		tst	r3, #8
 1777 0d54 0700000A 		beq	.L291
2380:../uvc.c      ****                 {
 1778              		.loc 1 2380 0
 1779 0d58 B030D5E1 		ldrh	r3, [r5]
 1780 0d5c 010053E3 		cmp	r3, #1
 1781 0d60 7C00000A 		beq	.L292
 1782              	.L293:
 1783              	.LBB291:
 1784              	.LBB102:
2293:../uvc.c      ****             break;
 1785              		.loc 1 2293 0
 1786 0d64 0000A0E3 		mov	r0, #0
 1787 0d68 0020A0E1 		mov	r2, r0
 1788 0d6c 0110A0E3 		mov	r1, #1
 1789 0d70 FEFFFFEB 		bl	CyU3PUsbStall
 1790              	.LVL204:
 1791              	.L306:
 1792 0d74 40309DE5 		ldr	r3, [sp, #64]
 1793              	.L291:
 1794              	.LBE102:
 1795              	.LBE291:
2391:../uvc.c      ****             {
 1796              		.loc 1 2391 0
 1797 0d78 400013E3 		tst	r3, #64
 1798 0d7c 2500000A 		beq	.L133
2396:../uvc.c      **** 
 1799              		.loc 1 2396 0
 1800 0d80 1800A0E3 		mov	r0, #24
 1801 0d84 48108DE2 		add	r1, sp, #72
 1802              	.LVL205:
 1803 0d88 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 1804              	.LVL206:
2401:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 1805              		.loc 1 2401 0
 1806 0d8c 48309DE5 		ldr	r3, [sp, #72]
 1807 0d90 000053E3 		cmp	r3, #0
 1808 0d94 4F00001A 		bne	.L409
2425:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 1809              		.loc 1 2425 0
 1810 0d98 3F23D7E5 		ldrb	r2, [r7, #831]	@ zero_extendqisi2
 1811 0d9c 000052E3 		cmp	r2, #0
 1812 0da0 1C00000A 		beq	.L133
2427:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 1813              		.loc 1 2427 0
 1814 0da4 002096E5 		ldr	r2, [r6]
 1815 0da8 0210A0E3 		mov	r1, #2
 1816 0dac 0010C2E5 		strb	r1, [r2]
2428:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 1817              		.loc 1 2428 0
 1818 0db0 001096E5 		ldr	r1, [r6]
 1819 0db4 0120A0E3 		mov	r2, #1
 1820 0db8 0120C1E5 		strb	r2, [r1, #1]
2429:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 1821              		.loc 1 2429 0
 1822 0dbc 001096E5 		ldr	r1, [r6]
2433:../uvc.c      **** 					interStabuf.status = 0;
 1823              		.loc 1 2433 0
 1824 0dc0 01CBA0E3 		mov	ip, #1024
2429:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 1825              		.loc 1 2429 0
 1826 0dc4 0230C1E5 		strb	r3, [r1, #2]
2430:../uvc.c      **** 
 1827              		.loc 1 2430 0
 1828 0dc8 001096E5 		ldr	r1, [r6]
2436:../uvc.c      **** 
 1829              		.loc 1 2436 0
 1830 0dcc 0490A0E3 		mov	r9, #4
2430:../uvc.c      **** 
 1831              		.loc 1 2430 0
 1832 0dd0 0320C1E5 		strb	r2, [r1, #3]
2432:../uvc.c      **** 					interStabuf.size   = 1024;
 1833              		.loc 1 2432 0
 1834 0dd4 002096E5 		ldr	r2, [r6]
2439:../uvc.c      **** 
 1835              		.loc 1 2439 0
 1836 0dd8 0010E0E3 		mvn	r1, #0
 1837 0ddc BC0E9FE5 		ldr	r0, .L438+28
2434:../uvc.c      **** 
 1838              		.loc 1 2434 0
 1839 0de0 B435CDE1 		strh	r3, [sp, #84]	@ movhi
2432:../uvc.c      **** 					interStabuf.size   = 1024;
 1840              		.loc 1 2432 0
 1841 0de4 4C208DE5 		str	r2, [sp, #76]
2433:../uvc.c      **** 					interStabuf.status = 0;
 1842              		.loc 1 2433 0
 1843 0de8 B2C5CDE1 		strh	ip, [sp, #82]	@ movhi
2436:../uvc.c      **** 
 1844              		.loc 1 2436 0
 1845 0dec B095CDE1 		strh	r9, [sp, #80]	@ movhi
2439:../uvc.c      **** 
 1846              		.loc 1 2439 0
 1847 0df0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 1848              	.LVL207:
2442:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 1849              		.loc 1 2442 0
 1850 0df4 A40E9FE5 		ldr	r0, .L438+28
 1851 0df8 4C108DE2 		add	r1, sp, #76
 1852 0dfc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 1853              	.LVL208:
2443:../uvc.c      **** 					{
 1854              		.loc 1 2443 0
 1855 0e00 000050E3 		cmp	r0, #0
 1856 0e04 9703001A 		bne	.L410
2449:../uvc.c      **** 					stiflag = 0xFF;
 1857              		.loc 1 2449 0
 1858 0e08 781E9FE5 		ldr	r1, .L438+4
2450:../uvc.c      **** 				}
 1859              		.loc 1 2450 0
 1860 0e0c FF30A0E3 		mov	r3, #255
2449:../uvc.c      **** 					stiflag = 0xFF;
 1861              		.loc 1 2449 0
 1862 0e10 3F03C1E5 		strb	r0, [r1, #831]
2450:../uvc.c      **** 				}
 1863              		.loc 1 2450 0
 1864 0e14 74308AE5 		str	r3, [r10, #116]
 1865              	.LVL209:
 1866              	.L133:
2604:../uvc.c      ****     }
 1867              		.loc 1 2604 0
 1868 0e18 FEFFFFEB 		bl	_txe_thread_relinquish
 1869              	.LVL210:
2605:../uvc.c      **** }
 1870              		.loc 1 2605 0
 1871 0e1c A0FFFFEA 		b	.L346
 1872              	.L141:
 1873              	.LBB292:
 1874              	.LBB293:
1906:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 1875              		.loc 1 1906 0
 1876 0e20 703E9FE5 		ldr	r3, .L438+20
 1877 0e24 701E9FE5 		ldr	r1, .L438+24
 1878 0e28 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 1879 0e2c B020DBE1 		ldrh	r2, [fp]
 1880 0e30 0400A0E3 		mov	r0, #4
 1881 0e34 FEFFFFEB 		bl	CyU3PDebugPrint
 1882              	.LVL211:
 1883 0e38 BFFFFFEA 		b	.L138
 1884              	.L142:
 1885              	.LBE293:
 1886              	.LBE292:
 1887              	.LBB294:
 1888              	.LBB283:
1831:../uvc.c      ****     {
 1889              		.loc 1 1831 0
 1890 0e3c B020DBE1 		ldrh	r2, [fp]
 1891 0e40 060C52E3 		cmp	r2, #1536
 1892 0e44 6601000A 		beq	.L145
 1893 0e48 ADFFFF8A 		bhi	.L146
 1894 0e4c 030C52E3 		cmp	r2, #768
 1895 0e50 3B01000A 		beq	.L147
 1896 0e54 9100008A 		bhi	.L148
 1897 0e58 010C52E3 		cmp	r2, #256
 1898 0e5c 9A01000A 		beq	.L149
 1899 0e60 020C52E3 		cmp	r2, #512
 1900 0e64 AFFFFF1A 		bne	.L144
 1901              	.L168:
 1902              	.LVL212:
 1903              	.LBB111:
 1904              	.LBB112:
 324:../uvc.c      ****     /*
 1905              		.loc 1 324 0
 1906 0e68 282E9FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1907              		.loc 1 315 0
 1908 0e6c 7032D7E5 		ldrb	r3, [r7, #624]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 1909              		.loc 1 324 0
 1910 0e70 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1911              		.loc 1 315 0
 1912 0e74 34308DE5 		str	r3, [sp, #52]
 1913              	.LVL213:
 332:../uvc.c      **** 		 {
 1914              		.loc 1 332 0
 1915 0e78 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1916              		.loc 1 317 0
 1917 0e7c 7F32D7E5 		ldrb	r3, [r7, #639]	@ zero_extendqisi2
 1918              	.LVL214:
 318:../uvc.c      ****     }
 1919              		.loc 1 318 0
 1920 0e80 7292D7E5 		ldrb	r9, [r7, #626]	@ zero_extendqisi2
 1921              	.LVL215:
 332:../uvc.c      **** 		 {
 1922              		.loc 1 332 0
 1923 0e84 5904000A 		beq	.L172
 1924 0e88 8B02009A 		bls	.L411
 1925 0e8c 850058E3 		cmp	r8, #133
 1926 0e90 B700000A 		beq	.L281
 1927 0e94 C303003A 		bcc	.L178
 1928 0e98 860058E3 		cmp	r8, #134
 1929 0e9c 4504000A 		beq	.L179
 1930 0ea0 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1931              		.loc 1 406 0
 1932 0ea4 7B22D705 		ldreqb	r2, [r7, #635]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 1933              		.loc 1 407 0
 1934 0ea8 7C32D705 		ldreqb	r3, [r7, #636]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 1935              		.loc 1 332 0
 1936 0eac 9100001A 		bne	.L275
 1937              	.LVL216:
 1938              	.L397:
 1939              	.LBE112:
 1940              	.LBE111:
 1941              	.LBB120:
 1942              	.LBB121:
 375:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 1943              		.loc 1 375 0
 1944 0eb0 0900A0E1 		mov	r0, r9
 1945 0eb4 281E9FE5 		ldr	r1, .L438+96
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1946              		.loc 1 372 0
 1947 0eb8 9820CAE5 		strb	r2, [r10, #152]
 1948 0ebc B00000EA 		b	.L396
 1949              	.L406:
 1950              	.LBE121:
 1951              	.LBE120:
 1952              	.LBE283:
 1953              	.LBE294:
2332:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 1954              		.loc 1 2332 0
 1955 0ec0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1956              	.LVL217:
2333:../uvc.c      ****                 {
 1957              		.loc 1 2333 0
 1958 0ec4 000050E3 		cmp	r0, #0
2335:../uvc.c      ****                 }
 1959              		.loc 1 2335 0
 1960 0ec8 0130A013 		movne	r3, #1
2332:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 1961              		.loc 1 2332 0
 1962 0ecc B800C4E5 		strb	r0, [r4, #184]
2335:../uvc.c      ****                 }
 1963              		.loc 1 2335 0
 1964 0ed0 88308415 		strne	r3, [r4, #136]
 1965 0ed4 7EFFFFEA 		b	.L135
 1966              	.L409:
2401:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 1967              		.loc 1 2401 0 discriminator 1
 1968 0ed8 3F33D7E5 		ldrb	r3, [r7, #831]	@ zero_extendqisi2
 1969 0edc 000053E3 		cmp	r3, #0
 1970 0ee0 CCFFFF1A 		bne	.L133
2403:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 1971              		.loc 1 2403 0
 1972 0ee4 002096E5 		ldr	r2, [r6]
 1973 0ee8 0210A0E3 		mov	r1, #2
 1974 0eec 0010C2E5 		strb	r1, [r2]
2404:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 1975              		.loc 1 2404 0
 1976 0ef0 002096E5 		ldr	r2, [r6]
 1977 0ef4 0180A0E3 		mov	r8, #1
 1978 0ef8 0180C2E5 		strb	r8, [r2, #1]
2405:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 1979              		.loc 1 2405 0
 1980 0efc 001096E5 		ldr	r1, [r6]
2409:../uvc.c      **** 					interStabuf.status = 0;
 1981              		.loc 1 2409 0
 1982 0f00 012BA0E3 		mov	r2, #1024
2405:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 1983              		.loc 1 2405 0
 1984 0f04 0230C1E5 		strb	r3, [r1, #2]
2406:../uvc.c      **** 
 1985              		.loc 1 2406 0
 1986 0f08 001096E5 		ldr	r1, [r6]
2412:../uvc.c      **** 
 1987              		.loc 1 2412 0
 1988 0f0c 0490A0E3 		mov	r9, #4
2406:../uvc.c      **** 
 1989              		.loc 1 2406 0
 1990 0f10 0330C1E5 		strb	r3, [r1, #3]
2408:../uvc.c      **** 					interStabuf.size   = 1024;
 1991              		.loc 1 2408 0
 1992 0f14 001096E5 		ldr	r1, [r6]
2415:../uvc.c      **** 
 1993              		.loc 1 2415 0
 1994 0f18 800D9FE5 		ldr	r0, .L438+28
2408:../uvc.c      **** 					interStabuf.size   = 1024;
 1995              		.loc 1 2408 0
 1996 0f1c 4C108DE5 		str	r1, [sp, #76]
2415:../uvc.c      **** 
 1997              		.loc 1 2415 0
 1998 0f20 0010E0E3 		mvn	r1, #0
2410:../uvc.c      **** 
 1999              		.loc 1 2410 0
 2000 0f24 B435CDE1 		strh	r3, [sp, #84]	@ movhi
2409:../uvc.c      **** 					interStabuf.status = 0;
 2001              		.loc 1 2409 0
 2002 0f28 B225CDE1 		strh	r2, [sp, #82]	@ movhi
2412:../uvc.c      **** 
 2003              		.loc 1 2412 0
 2004 0f2c B095CDE1 		strh	r9, [sp, #80]	@ movhi
2415:../uvc.c      **** 
 2005              		.loc 1 2415 0
 2006 0f30 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 2007              	.LVL218:
2418:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 2008              		.loc 1 2418 0
 2009 0f34 640D9FE5 		ldr	r0, .L438+28
 2010 0f38 4C108DE2 		add	r1, sp, #76
 2011 0f3c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 2012              	.LVL219:
2419:../uvc.c      **** 					{
 2013              		.loc 1 2419 0
 2014 0f40 000050E3 		cmp	r0, #0
 2015 0f44 2D02001A 		bne	.L412
2424:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 2016              		.loc 1 2424 0
 2017 0f48 383D9FE5 		ldr	r3, .L438+4
 2018 0f4c 3F83C3E5 		strb	r8, [r3, #831]
2604:../uvc.c      ****     }
 2019              		.loc 1 2604 0
 2020 0f50 FEFFFFEB 		bl	_txe_thread_relinquish
 2021              	.LVL220:
 2022 0f54 52FFFFEA 		b	.L346
 2023              	.L292:
 2024              	.LVL221:
 2025              	.LBB295:
 2026              	.LBB103:
1970:../uvc.c      ****     {
 2027              		.loc 1 1970 0
 2028 0f58 B020DBE1 		ldrh	r2, [fp]
 2029 0f5c 030C52E3 		cmp	r2, #768
 2030 0f60 2100000A 		beq	.L294
 2031 0f64 1200008A 		bhi	.L295
 2032 0f68 010C52E3 		cmp	r2, #256
 2033 0f6c 3000000A 		beq	.L296
 2034 0f70 020C52E3 		cmp	r2, #512
 2035 0f74 7AFFFF1A 		bne	.L293
2024:../uvc.c      ****             {
 2036              		.loc 1 2024 0
 2037 0f78 183D9FE5 		ldr	r3, .L438+20
 2038 0f7c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 2039 0f80 810053E3 		cmp	r3, #129
 2040 0f84 3200000A 		beq	.L334
 2041 0f88 8501009A 		bls	.L413
 2042 0f8c 850053E3 		cmp	r3, #133
 2043 0f90 1F00000A 		beq	.L330
 2044 0f94 860053E3 		cmp	r3, #134
 2045 0f98 71FFFF1A 		bne	.L293
 2046              	.L399:
2241:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2047              		.loc 1 2241 0
 2048 0f9c 0330A0E3 		mov	r3, #3
2242:../uvc.c      ****                         break;
 2049              		.loc 1 2242 0
 2050 0fa0 3C1D9FE5 		ldr	r1, .L438+96
 2051 0fa4 0100A0E3 		mov	r0, #1
2241:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2052              		.loc 1 2241 0
 2053 0fa8 9830CAE5 		strb	r3, [r10, #152]
2242:../uvc.c      ****                         break;
 2054              		.loc 1 2242 0
 2055 0fac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2056              	.LVL222:
 2057 0fb0 6FFFFFEA 		b	.L306
 2058              	.L295:
1970:../uvc.c      ****     {
 2059              		.loc 1 1970 0
 2060 0fb4 010B52E3 		cmp	r2, #1024
 2061 0fb8 2900000A 		beq	.L298
 2062 0fbc 050C52E3 		cmp	r2, #1280
 2063 0fc0 67FFFF1A 		bne	.L293
2238:../uvc.c      ****                 {
 2064              		.loc 1 2238 0
 2065 0fc4 CC2C9FE5 		ldr	r2, .L438+20
 2066 0fc8 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 2067 0fcc 810052E3 		cmp	r2, #129
 2068 0fd0 1F00000A 		beq	.L334
 2069 0fd4 5A01009A 		bls	.L414
 2070 0fd8 850052E3 		cmp	r2, #133
 2071 0fdc 9001000A 		beq	.L337
 2072 0fe0 860052E3 		cmp	r2, #134
 2073 0fe4 ECFFFF0A 		beq	.L399
 2074 0fe8 5DFFFFEA 		b	.L293
 2075              	.L294:
2101:../uvc.c      ****                 {
 2076              		.loc 1 2101 0
 2077 0fec A42C9FE5 		ldr	r2, .L438+20
 2078 0ff0 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 2079 0ff4 830052E3 		cmp	r2, #131
 2080 0ff8 9100009A 		bls	.L415
 2081 0ffc 860052E3 		cmp	r2, #134
 2082 1000 2000000A 		beq	.L400
 2083 1004 870052E3 		cmp	r2, #135
 2084 1008 B300000A 		beq	.L321
 2085              	.L405:
 2086 100c 850052E3 		cmp	r2, #133
 2087 1010 53FFFF1A 		bne	.L293
 2088              	.L330:
2163:../uvc.c      ****                         glEp0Buffer[1] = 0;
 2089              		.loc 1 2163 0
 2090 1014 1A20A0E3 		mov	r2, #26
2164:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2091              		.loc 1 2164 0
 2092 1018 0030A0E3 		mov	r3, #0
2165:../uvc.c      ****                         break;
 2093              		.loc 1 2165 0
 2094 101c C01C9FE5 		ldr	r1, .L438+96
 2095 1020 0200A0E3 		mov	r0, #2
2163:../uvc.c      ****                         glEp0Buffer[1] = 0;
 2096              		.loc 1 2163 0
 2097 1024 9820CAE5 		strb	r2, [r10, #152]
2164:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2098              		.loc 1 2164 0
 2099 1028 9930CAE5 		strb	r3, [r10, #153]
2165:../uvc.c      ****                         break;
 2100              		.loc 1 2165 0
 2101 102c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2102              	.LVL223:
 2103 1030 4FFFFFEA 		b	.L306
 2104              	.L296:
1973:../uvc.c      ****             {
 2105              		.loc 1 1973 0
 2106 1034 5C2C9FE5 		ldr	r2, .L438+20
 2107 1038 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 2108 103c 830052E3 		cmp	r2, #131
 2109 1040 5F00009A 		bls	.L416
 2110 1044 860052E3 		cmp	r2, #134
 2111 1048 0E00000A 		beq	.L400
 2112 104c 870052E3 		cmp	r2, #135
 2113 1050 EDFFFF1A 		bne	.L405
 2114              	.L334:
2252:../uvc.c      ****                         }
 2115              		.loc 1 2252 0
 2116 1054 481C9FE5 		ldr	r1, .L438+32
 2117 1058 1A00A0E3 		mov	r0, #26
 2118 105c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2119              	.LVL224:
 2120 1060 43FFFFEA 		b	.L306
 2121              	.L298:
2156:../uvc.c      ****                 {
 2122              		.loc 1 2156 0
 2123 1064 2C2C9FE5 		ldr	r2, .L438+20
 2124 1068 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
 2125 106c 810052E3 		cmp	r2, #129
 2126 1070 9900000A 		beq	.L321
 2127 1074 2701009A 		bls	.L417
 2128 1078 850052E3 		cmp	r2, #133
 2129 107c E4FFFF0A 		beq	.L330
 2130 1080 860052E3 		cmp	r2, #134
 2131 1084 36FFFF1A 		bne	.L293
 2132              	.L400:
2160:../uvc.c      ****                         break;
 2133              		.loc 1 2160 0
 2134 1088 0300A0E1 		mov	r0, r3
 2135 108c 501C9FE5 		ldr	r1, .L438+96
2159:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2136              		.loc 1 2159 0
 2137 1090 0330A0E3 		mov	r3, #3
 2138 1094 9830CAE5 		strb	r3, [r10, #152]
2160:../uvc.c      ****                         break;
 2139              		.loc 1 2160 0
 2140 1098 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2141              	.LVL225:
 2142 109c 34FFFFEA 		b	.L306
 2143              	.LVL226:
 2144              	.L148:
 2145              	.LBE103:
 2146              	.LBE295:
 2147              	.LBB296:
 2148              	.LBB284:
1831:../uvc.c      ****     {
 2149              		.loc 1 1831 0
 2150 10a0 010B52E3 		cmp	r2, #1024
 2151 10a4 29FFFF0A 		beq	.L137
 2152 10a8 050C52E3 		cmp	r2, #1280
 2153 10ac 1DFFFF1A 		bne	.L144
 2154              	.L194:
 2155              	.LVL227:
 2156              	.LBB136:
 2157              	.LBB137:
 324:../uvc.c      ****     /*
 2158              		.loc 1 324 0
 2159 10b0 E02B9FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2160              		.loc 1 315 0
 2161 10b4 6030D7E5 		ldrb	r3, [r7, #96]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2162              		.loc 1 324 0
 2163 10b8 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2164              		.loc 1 315 0
 2165 10bc 34308DE5 		str	r3, [sp, #52]
 2166              	.LVL228:
 332:../uvc.c      **** 		 {
 2167              		.loc 1 332 0
 2168 10c0 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2169              		.loc 1 317 0
 2170 10c4 6F30D7E5 		ldrb	r3, [r7, #111]	@ zero_extendqisi2
 2171              	.LVL229:
 318:../uvc.c      ****     }
 2172              		.loc 1 318 0
 2173 10c8 6290D7E5 		ldrb	r9, [r7, #98]	@ zero_extendqisi2
 2174              	.LVL230:
 332:../uvc.c      **** 		 {
 2175              		.loc 1 332 0
 2176 10cc EB03000A 		beq	.L198
 2177 10d0 4302009A 		bls	.L418
 2178 10d4 850058E3 		cmp	r8, #133
 2179 10d8 2500000A 		beq	.L281
 2180 10dc 4203003A 		bcc	.L204
 2181 10e0 860058E3 		cmp	r8, #134
 2182 10e4 B503000A 		beq	.L205
 2183 10e8 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2184              		.loc 1 406 0
 2185 10ec 6B20D705 		ldreqb	r2, [r7, #107]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2186              		.loc 1 407 0
 2187 10f0 6C30D705 		ldreqb	r3, [r7, #108]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2188              		.loc 1 332 0
 2189 10f4 6DFFFF0A 		beq	.L397
 2190              	.LVL231:
 2191              	.L275:
 2192              	.LBE137:
 2193              	.LBE136:
 2194              	.LBB145:
 2195              	.LBB122:
 446:../uvc.c      **** 			  break;
 2196              		.loc 1 446 0
 2197 10f8 0000A0E3 		mov	r0, #0
 2198 10fc 0020A0E1 		mov	r2, r0
 2199 1100 0110A0E3 		mov	r1, #1
 2200 1104 FEFFFFEB 		bl	CyU3PUsbStall
 2201              	.LVL232:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2202              		.loc 1 320 0
 2203 1108 FF30A0E3 		mov	r3, #255
 2204 110c 0390A0E1 		mov	r9, r3
 2205 1110 03C0A0E1 		mov	ip, r3
 2206 1114 1F0000EA 		b	.L285
 2207              	.L407:
 2208              	.LBE122:
 2209              	.LBE145:
1831:../uvc.c      ****     {
 2210              		.loc 1 1831 0
 2211 1118 070C52E3 		cmp	r2, #1792
 2212 111c D700000A 		beq	.L154
 2213 1120 020B52E3 		cmp	r2, #2048
 2214 1124 FFFEFF1A 		bne	.L144
 2215              	.L233:
 2216              	.LVL233:
 2217              	.LBB146:
 2218              	.LBB147:
 324:../uvc.c      ****     /*
 2219              		.loc 1 324 0
 2220 1128 682B9FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2221              		.loc 1 315 0
 2222 112c A830D7E5 		ldrb	r3, [r7, #168]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2223              		.loc 1 324 0
 2224 1130 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2225              		.loc 1 315 0
 2226 1134 34308DE5 		str	r3, [sp, #52]
 2227              	.LVL234:
 332:../uvc.c      **** 		 {
 2228              		.loc 1 332 0
 2229 1138 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2230              		.loc 1 317 0
 2231 113c B730D7E5 		ldrb	r3, [r7, #183]	@ zero_extendqisi2
 2232              	.LVL235:
 318:../uvc.c      ****     }
 2233              		.loc 1 318 0
 2234 1140 AA90D7E5 		ldrb	r9, [r7, #170]	@ zero_extendqisi2
 2235              	.LVL236:
 332:../uvc.c      **** 		 {
 2236              		.loc 1 332 0
 2237 1144 A503000A 		beq	.L237
 2238 1148 6201009A 		bls	.L419
 2239 114c 850058E3 		cmp	r8, #133
 2240 1150 0700000A 		beq	.L281
 2241 1154 2703003A 		bcc	.L243
 2242 1158 860058E3 		cmp	r8, #134
 2243 115c 9903000A 		beq	.L244
 2244 1160 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2245              		.loc 1 406 0
 2246 1164 B320D705 		ldreqb	r2, [r7, #179]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2247              		.loc 1 407 0
 2248 1168 B430D705 		ldreqb	r3, [r7, #180]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2249              		.loc 1 332 0
 2250 116c 4FFFFF0A 		beq	.L397
 2251 1170 E0FFFFEA 		b	.L275
 2252              	.LVL237:
 2253              	.L281:
 2254              	.LBE147:
 2255              	.LBE146:
 2256              	.LBB155:
 2257              	.LBB123:
 338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2258              		.loc 1 338 0
 2259 1174 681B9FE5 		ldr	r1, .L438+96
 337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2260              		.loc 1 337 0
 2261 1178 0030A0E3 		mov	r3, #0
 338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2262              		.loc 1 338 0
 2263 117c 0200A0E3 		mov	r0, #2
 336:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2264              		.loc 1 336 0
 2265 1180 9890CAE5 		strb	r9, [r10, #152]
 2266              	.L396:
 373:../uvc.c      **** 			 }
 2267              		.loc 1 373 0
 2268 1184 9930CAE5 		strb	r3, [r10, #153]
 375:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2269              		.loc 1 375 0
 2270 1188 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2271              	.LVL238:
 376:../uvc.c      **** 			  break;
 2272              		.loc 1 376 0
 2273 118c 9830DAE5 		ldrb	r3, [r10, #152]	@ zero_extendqisi2
 2274              	.LVL239:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2275              		.loc 1 320 0
 2276 1190 FF90A0E3 		mov	r9, #255
 2277 1194 09C0A0E1 		mov	ip, r9
 2278              	.LVL240:
 2279              	.L285:
 449:../uvc.c      **** }
 2280              		.loc 1 449 0
 2281 1198 FF10A0E3 		mov	r1, #255
 2282 119c 04308DE5 		str	r3, [sp, #4]
 2283 11a0 08108DE5 		str	r1, [sp, #8]
 2284 11a4 0C30A0E1 		mov	r3, ip
 2285              	.LVL241:
 2286 11a8 00908DE5 		str	r9, [sp]
 2287 11ac 0820A0E1 		mov	r2, r8
 2288 11b0 0400A0E3 		mov	r0, #4
 2289 11b4 EC1A9FE5 		ldr	r1, .L438+36
 2290 11b8 FEFFFFEB 		bl	CyU3PDebugPrint
 2291              	.LVL242:
 2292 11bc 40309DE5 		ldr	r3, [sp, #64]
 2293 11c0 E2FEFFEA 		b	.L137
 2294              	.LVL243:
 2295              	.L416:
 2296              	.LBE123:
 2297              	.LBE155:
 2298              	.LBE284:
 2299              	.LBE296:
 2300              	.LBB297:
 2301              	.LBB104:
1973:../uvc.c      ****             {
 2302              		.loc 1 1973 0
 2303 11c4 810052E3 		cmp	r2, #129
 2304 11c8 A1FFFF2A 		bcs	.L334
 2305 11cc 010052E3 		cmp	r2, #1
 2306 11d0 E3FEFF1A 		bne	.L293
1998:../uvc.c      ****                             glCommitCtrl, &readCount);
 2307              		.loc 1 1998 0
 2308 11d4 2000A0E3 		mov	r0, #32
 2309 11d8 CC1A9FE5 		ldr	r1, .L438+40
 2310 11dc 38208DE2 		add	r2, sp, #56
 2311 11e0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2312              	.LVL244:
2000:../uvc.c      ****                     {
 2313              		.loc 1 2000 0
 2314 11e4 000050E3 		cmp	r0, #0
 2315 11e8 E1FEFF1A 		bne	.L306
2008:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 2316              		.loc 1 2008 0
 2317 11ec C0E0D4E5 		ldrb	lr, [r4, #192]	@ zero_extendqisi2
2010:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 2318              		.loc 1 2010 0
 2319 11f0 C200D4E5 		ldrb	r0, [r4, #194]	@ zero_extendqisi2
 2320              	.LVL245:
2011:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 2321              		.loc 1 2011 0
 2322 11f4 C310D4E5 		ldrb	r1, [r4, #195]	@ zero_extendqisi2
2007:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 2323              		.loc 1 2007 0
 2324 11f8 BF80D4E5 		ldrb	r8, [r4, #191]	@ zero_extendqisi2
2009:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 2325              		.loc 1 2009 0
 2326 11fc C1C0D4E5 		ldrb	ip, [r4, #193]	@ zero_extendqisi2
2012:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 2327              		.loc 1 2012 0
 2328 1200 BC30D4E5 		ldrb	r3, [r4, #188]	@ zero_extendqisi2
2008:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 2329              		.loc 1 2008 0
 2330 1204 10E3C7E5 		strb	lr, [r7, #784]
2012:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 2331              		.loc 1 2012 0
 2332 1208 0C008DE5 		str	r0, [sp, #12]
 2333 120c 10108DE5 		str	r1, [sp, #16]
 2334 1210 00418DE8 		stmia	sp, {r8, lr}
 2335 1214 B823DDE1 		ldrh	r2, [sp, #56]
 2336 1218 08C08DE5 		str	ip, [sp, #8]
2006:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 2337              		.loc 1 2006 0
 2338 121c BEE0D4E5 		ldrb	lr, [r4, #190]	@ zero_extendqisi2
2010:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 2339              		.loc 1 2010 0
 2340 1220 1203C7E5 		strb	r0, [r7, #786]
2011:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC Prob(set) control %d %d %d %d %d %d %d\r\n
 2341              		.loc 1 2011 0
 2342 1224 1313C7E5 		strb	r1, [r7, #787]
2012:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 2343              		.loc 1 2012 0
 2344 1228 0400A0E3 		mov	r0, #4
 2345 122c 7C1A9FE5 		ldr	r1, .L438+44
2007:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 2346              		.loc 1 2007 0
 2347 1230 0F83C7E5 		strb	r8, [r7, #783]
2009:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 2348              		.loc 1 2009 0
 2349 1234 11C3C7E5 		strb	ip, [r7, #785]
2006:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 2350              		.loc 1 2006 0
 2351 1238 0EE3C7E5 		strb	lr, [r7, #782]
2012:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[3], glCommitCtrl[4], glCommitCtrl[5], g
 2352              		.loc 1 2012 0
 2353 123c FEFFFFEB 		bl	CyU3PDebugPrint
 2354              	.LVL246:
 2355 1240 CBFEFFEA 		b	.L306
 2356              	.LVL247:
 2357              	.L415:
2101:../uvc.c      ****                 {
 2358              		.loc 1 2101 0
 2359 1244 810052E3 		cmp	r2, #129
 2360 1248 2300002A 		bcs	.L321
 2361 124c 010052E3 		cmp	r2, #1
 2362 1250 C3FEFF1A 		bne	.L293
2126:../uvc.c      ****                                 glCommitCtrl, &readCount);
 2363              		.loc 1 2126 0
 2364 1254 501A9FE5 		ldr	r1, .L438+40
 2365 1258 2000A0E3 		mov	r0, #32
 2366 125c 38208DE2 		add	r2, sp, #56
 2367 1260 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2368              	.LVL248:
2128:../uvc.c      ****                         {
 2369              		.loc 1 2128 0
 2370 1264 000050E3 		cmp	r0, #0
2142:../uvc.c      ****                             CyU3PDebugPrint (4, "%d %d %d %d %d %d %d %d %d %d %d\r\n",
 2371              		.loc 1 2142 0
 2372 1268 0400A003 		moveq	r0, #4
 2373              	.LVL249:
 2374 126c 401A9F05 		ldreq	r1, .L438+48
2128:../uvc.c      ****                         {
 2375              		.loc 1 2128 0
 2376 1270 BFFEFF1A 		bne	.L306
 2377              	.L401:
2185:../uvc.c      ****                             CyU3PDebugPrint (4, "%d %d %d %d %d %d %d %d %d %d %d\r\n",
 2378              		.loc 1 2185 0
 2379 1274 B823DDE1 		ldrh	r2, [sp, #56]
 2380 1278 FEFFFFEB 		bl	CyU3PDebugPrint
 2381              	.LVL250:
2186:../uvc.c      ****                             		glCommitCtrl[0], glCommitCtrl[1],  glCommitCtrl[2], glCommitCtrl[3],
 2382              		.loc 1 2186 0
 2383 127c BE10D4E5 		ldrb	r1, [r4, #190]	@ zero_extendqisi2
 2384 1280 BFE0D4E5 		ldrb	lr, [r4, #191]	@ zero_extendqisi2
 2385 1284 C0C0D4E5 		ldrb	ip, [r4, #192]	@ zero_extendqisi2
 2386 1288 C100D4E5 		ldrb	r0, [r4, #193]	@ zero_extendqisi2
 2387 128c BC20D4E5 		ldrb	r2, [r4, #188]	@ zero_extendqisi2
 2388 1290 BD30D4E5 		ldrb	r3, [r4, #189]	@ zero_extendqisi2
 2389 1294 00108DE5 		str	r1, [sp]
 2390 1298 C210D4E5 		ldrb	r1, [r4, #194]	@ zero_extendqisi2
 2391 129c 04E08DE5 		str	lr, [sp, #4]
 2392 12a0 C3E0D4E5 		ldrb	lr, [r4, #195]	@ zero_extendqisi2
 2393 12a4 08C08DE5 		str	ip, [sp, #8]
 2394 12a8 C4C0D4E5 		ldrb	ip, [r4, #196]	@ zero_extendqisi2
 2395 12ac 0C008DE5 		str	r0, [sp, #12]
 2396 12b0 C500D4E5 		ldrb	r0, [r4, #197]	@ zero_extendqisi2
 2397 12b4 10108DE5 		str	r1, [sp, #16]
 2398 12b8 C610D4E5 		ldrb	r1, [r4, #198]	@ zero_extendqisi2
 2399 12bc 1C008DE5 		str	r0, [sp, #28]
 2400 12c0 20108DE5 		str	r1, [sp, #32]
 2401 12c4 14E08DE5 		str	lr, [sp, #20]
 2402 12c8 18C08DE5 		str	ip, [sp, #24]
 2403 12cc E4199FE5 		ldr	r1, .L438+52
 2404 12d0 0400A0E3 		mov	r0, #4
 2405 12d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2406              	.LVL251:
 2407 12d8 A5FEFFEA 		b	.L306
 2408              	.LVL252:
 2409              	.L321:
2116:../uvc.c      ****                         {
 2410              		.loc 1 2116 0
 2411 12dc B830DAE5 		ldrb	r3, [r10, #184]	@ zero_extendqisi2
2118:../uvc.c      ****                         }
 2412              		.loc 1 2118 0
 2413 12e0 0B00A0E3 		mov	r0, #11
2116:../uvc.c      ****                         {
 2414              		.loc 1 2116 0
 2415 12e4 030053E3 		cmp	r3, #3
2118:../uvc.c      ****                         }
 2416              		.loc 1 2118 0
 2417 12e8 CC199F05 		ldreq	r1, .L438+56
2122:../uvc.c      ****                         }
 2418              		.loc 1 2122 0
 2419 12ec CC199F15 		ldrne	r1, .L438+60
 2420 12f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2421              	.LVL253:
 2422 12f4 9EFEFFEA 		b	.L306
 2423              	.L259:
 2424              	.LVL254:
 2425              	.L408:
 2426              	.LBE104:
 2427              	.LBE297:
 2428              	.LBB298:
 2429              	.LBB285:
 2430              	.LBB156:
 2431              	.LBB157:
 324:../uvc.c      ****     /*
 2432              		.loc 1 324 0
 2433 12f8 98299FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2434              		.loc 1 315 0
 2435 12fc 0831D7E5 		ldrb	r3, [r7, #264]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2436              		.loc 1 324 0
 2437 1300 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2438              		.loc 1 315 0
 2439 1304 34308DE5 		str	r3, [sp, #52]
 2440              	.LVL255:
 332:../uvc.c      **** 		 {
 2441              		.loc 1 332 0
 2442 1308 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2443              		.loc 1 317 0
 2444 130c 1731D7E5 		ldrb	r3, [r7, #279]	@ zero_extendqisi2
 2445              	.LVL256:
 318:../uvc.c      ****     }
 2446              		.loc 1 318 0
 2447 1310 0A91D7E5 		ldrb	r9, [r7, #266]	@ zero_extendqisi2
 2448              	.LVL257:
 332:../uvc.c      **** 		 {
 2449              		.loc 1 332 0
 2450 1314 4903000A 		beq	.L263
 2451 1318 8C01009A 		bls	.L420
 2452 131c 850058E3 		cmp	r8, #133
 2453 1320 93FFFF0A 		beq	.L281
 2454 1324 C002003A 		bcc	.L269
 2455 1328 860058E3 		cmp	r8, #134
 2456 132c 1003000A 		beq	.L270
 2457 1330 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2458              		.loc 1 406 0
 2459 1334 1321D705 		ldreqb	r2, [r7, #275]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2460              		.loc 1 407 0
 2461 1338 1431D705 		ldreqb	r3, [r7, #276]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2462              		.loc 1 332 0
 2463 133c DBFEFF0A 		beq	.L397
 2464 1340 6CFFFFEA 		b	.L275
 2465              	.L181:
 2466              	.LVL258:
 2467              	.L147:
 2468              	.LBE157:
 2469              	.LBE156:
 2470              	.LBB164:
 2471              	.LBB165:
 324:../uvc.c      ****     /*
 2472              		.loc 1 324 0
 2473 1344 4C299FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2474              		.loc 1 315 0
 2475 1348 3030D7E5 		ldrb	r3, [r7, #48]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2476              		.loc 1 324 0
 2477 134c 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2478              		.loc 1 315 0
 2479 1350 34308DE5 		str	r3, [sp, #52]
 2480              	.LVL259:
 332:../uvc.c      **** 		 {
 2481              		.loc 1 332 0
 2482 1354 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2483              		.loc 1 317 0
 2484 1358 3F30D7E5 		ldrb	r3, [r7, #63]	@ zero_extendqisi2
 2485              	.LVL260:
 318:../uvc.c      ****     }
 2486              		.loc 1 318 0
 2487 135c 3290D7E5 		ldrb	r9, [r7, #50]	@ zero_extendqisi2
 2488              	.LVL261:
 332:../uvc.c      **** 		 {
 2489              		.loc 1 332 0
 2490 1360 3A03000A 		beq	.L185
 2491 1364 E901009A 		bls	.L421
 2492 1368 850058E3 		cmp	r8, #133
 2493 136c 80FFFF0A 		beq	.L281
 2494 1370 C502003A 		bcc	.L191
 2495 1374 860058E3 		cmp	r8, #134
 2496 1378 FF02000A 		beq	.L192
 2497 137c 870058E3 		cmp	r8, #135
 2498 1380 5CFFFF1A 		bne	.L275
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2499              		.loc 1 406 0
 2500 1384 FC389FE5 		ldr	r3, .L438+4
 2501 1388 3B20D3E5 		ldrb	r2, [r3, #59]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2502              		.loc 1 407 0
 2503 138c 3C30D3E5 		ldrb	r3, [r3, #60]	@ zero_extendqisi2
 2504 1390 C6FEFFEA 		b	.L397
 2505              	.L246:
 2506              	.LVL262:
 2507              	.L152:
 2508              	.LBE165:
 2509              	.LBE164:
 2510              	.LBB173:
 2511              	.LBB174:
 324:../uvc.c      ****     /*
 2512              		.loc 1 324 0
 2513 1394 FC289FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2514              		.loc 1 315 0
 2515 1398 D830D7E5 		ldrb	r3, [r7, #216]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2516              		.loc 1 324 0
 2517 139c 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2518              		.loc 1 315 0
 2519 13a0 34308DE5 		str	r3, [sp, #52]
 2520              	.LVL263:
 332:../uvc.c      **** 		 {
 2521              		.loc 1 332 0
 2522 13a4 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2523              		.loc 1 317 0
 2524 13a8 E730D7E5 		ldrb	r3, [r7, #231]	@ zero_extendqisi2
 2525              	.LVL264:
 318:../uvc.c      ****     }
 2526              		.loc 1 318 0
 2527 13ac DA90D7E5 		ldrb	r9, [r7, #218]	@ zero_extendqisi2
 2528              	.LVL265:
 332:../uvc.c      **** 		 {
 2529              		.loc 1 332 0
 2530 13b0 2A03000A 		beq	.L250
 2531 13b4 A100009A 		bls	.L422
 2532 13b8 850058E3 		cmp	r8, #133
 2533 13bc 6CFFFF0A 		beq	.L281
 2534 13c0 6902003A 		bcc	.L256
 2535 13c4 860058E3 		cmp	r8, #134
 2536 13c8 1103000A 		beq	.L257
 2537 13cc 870058E3 		cmp	r8, #135
 2538 13d0 48FFFF1A 		bne	.L275
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2539              		.loc 1 406 0
 2540 13d4 AC389FE5 		ldr	r3, .L438+4
 2541 13d8 E320D3E5 		ldrb	r2, [r3, #227]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2542              		.loc 1 407 0
 2543 13dc E430D3E5 		ldrb	r3, [r3, #228]	@ zero_extendqisi2
 2544 13e0 B2FEFFEA 		b	.L397
 2545              	.L207:
 2546              	.LVL266:
 2547              	.L145:
 2548              	.LBE174:
 2549              	.LBE173:
 2550              	.LBB182:
 2551              	.LBB183:
 324:../uvc.c      ****     /*
 2552              		.loc 1 324 0
 2553 13e4 AC289FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2554              		.loc 1 315 0
 2555 13e8 7830D7E5 		ldrb	r3, [r7, #120]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2556              		.loc 1 324 0
 2557 13ec 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2558              		.loc 1 315 0
 2559 13f0 34308DE5 		str	r3, [sp, #52]
 2560              	.LVL267:
 332:../uvc.c      **** 		 {
 2561              		.loc 1 332 0
 2562 13f4 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2563              		.loc 1 317 0
 2564 13f8 8730D7E5 		ldrb	r3, [r7, #135]	@ zero_extendqisi2
 2565              	.LVL268:
 318:../uvc.c      ****     }
 2566              		.loc 1 318 0
 2567 13fc 7A90D7E5 		ldrb	r9, [r7, #122]	@ zero_extendqisi2
 2568              	.LVL269:
 332:../uvc.c      **** 		 {
 2569              		.loc 1 332 0
 2570 1400 1A03000A 		beq	.L211
 2571 1404 9B01009A 		bls	.L423
 2572 1408 850058E3 		cmp	r8, #133
 2573 140c 58FFFF0A 		beq	.L281
 2574 1410 9202003A 		bcc	.L217
 2575 1414 860058E3 		cmp	r8, #134
 2576 1418 F802000A 		beq	.L218
 2577 141c 870058E3 		cmp	r8, #135
 2578 1420 34FFFF1A 		bne	.L275
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2579              		.loc 1 406 0
 2580 1424 5C389FE5 		ldr	r3, .L438+4
 2581 1428 8320D3E5 		ldrb	r2, [r3, #131]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2582              		.loc 1 407 0
 2583 142c 8430D3E5 		ldrb	r3, [r3, #132]	@ zero_extendqisi2
 2584 1430 9EFEFFEA 		b	.L397
 2585              	.L272:
 2586              	.LVL270:
 2587              	.L156:
 2588              	.LBE183:
 2589              	.LBE182:
 2590              	.LBB191:
 2591              	.LBB124:
 324:../uvc.c      ****     /*
 2592              		.loc 1 324 0
 2593 1434 5C289FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2594              		.loc 1 315 0
 2595 1438 5031D7E5 		ldrb	r3, [r7, #336]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2596              		.loc 1 324 0
 2597 143c 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2598              		.loc 1 315 0
 2599 1440 34308DE5 		str	r3, [sp, #52]
 2600              	.LVL271:
 332:../uvc.c      **** 		 {
 2601              		.loc 1 332 0
 2602 1444 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2603              		.loc 1 317 0
 2604 1448 5F31D7E5 		ldrb	r3, [r7, #351]	@ zero_extendqisi2
 2605              	.LVL272:
 318:../uvc.c      ****     }
 2606              		.loc 1 318 0
 2607 144c 5291D7E5 		ldrb	r9, [r7, #338]	@ zero_extendqisi2
 2608              	.LVL273:
 332:../uvc.c      **** 		 {
 2609              		.loc 1 332 0
 2610 1450 F602000A 		beq	.L276
 2611 1454 C400009A 		bls	.L424
 2612 1458 850058E3 		cmp	r8, #133
 2613 145c 44FFFF0A 		beq	.L281
 2614 1460 8602003A 		bcc	.L282
 2615 1464 860058E3 		cmp	r8, #134
 2616 1468 E702000A 		beq	.L283
 2617 146c 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2618              		.loc 1 406 0
 2619 1470 5B21D705 		ldreqb	r2, [r7, #347]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2620              		.loc 1 407 0
 2621 1474 5C31D705 		ldreqb	r3, [r7, #348]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2622              		.loc 1 332 0
 2623 1478 8CFEFF0A 		beq	.L397
 2624 147c 1DFFFFEA 		b	.L275
 2625              	.L220:
 2626              	.LVL274:
 2627              	.L154:
 2628              	.LBE124:
 2629              	.LBE191:
 2630              	.LBB192:
 2631              	.LBB193:
 324:../uvc.c      ****     /*
 2632              		.loc 1 324 0
 2633 1480 10289FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2634              		.loc 1 315 0
 2635 1484 9030D7E5 		ldrb	r3, [r7, #144]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2636              		.loc 1 324 0
 2637 1488 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2638              		.loc 1 315 0
 2639 148c 34308DE5 		str	r3, [sp, #52]
 2640              	.LVL275:
 332:../uvc.c      **** 		 {
 2641              		.loc 1 332 0
 2642 1490 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2643              		.loc 1 317 0
 2644 1494 9F30D7E5 		ldrb	r3, [r7, #159]	@ zero_extendqisi2
 2645              	.LVL276:
 318:../uvc.c      ****     }
 2646              		.loc 1 318 0
 2647 1498 9290D7E5 		ldrb	r9, [r7, #146]	@ zero_extendqisi2
 2648              	.LVL277:
 332:../uvc.c      **** 		 {
 2649              		.loc 1 332 0
 2650 149c CB02000A 		beq	.L224
 2651 14a0 C001009A 		bls	.L425
 2652 14a4 850058E3 		cmp	r8, #133
 2653 14a8 31FFFF0A 		beq	.L281
 2654 14ac 6F02003A 		bcc	.L230
 2655 14b0 860058E3 		cmp	r8, #134
 2656 14b4 9502000A 		beq	.L231
 2657 14b8 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2658              		.loc 1 406 0
 2659 14bc 9B20D705 		ldreqb	r2, [r7, #155]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2660              		.loc 1 407 0
 2661 14c0 9C30D705 		ldreqb	r3, [r7, #156]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2662              		.loc 1 332 0
 2663 14c4 79FEFF0A 		beq	.L397
 2664 14c8 0AFFFFEA 		b	.L275
 2665              	.LVL278:
 2666              	.L149:
 2667              	.LBE193:
 2668              	.LBE192:
 2669              	.LBB201:
 2670              	.LBB202:
 324:../uvc.c      ****     /*
 2671              		.loc 1 324 0
 2672 14cc C4279FE5 		ldr	r2, .L438+20
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2673              		.loc 1 315 0
 2674 14d0 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 324:../uvc.c      ****     /*
 2675              		.loc 1 324 0
 2676 14d4 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 315:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2677              		.loc 1 315 0
 2678 14d8 34308DE5 		str	r3, [sp, #52]
 2679              	.LVL279:
 332:../uvc.c      **** 		 {
 2680              		.loc 1 332 0
 2681 14dc 830058E3 		cmp	r8, #131
 317:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2682              		.loc 1 317 0
 2683 14e0 0F30D7E5 		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2684              	.LVL280:
 318:../uvc.c      ****     }
 2685              		.loc 1 318 0
 2686 14e4 0290D7E5 		ldrb	r9, [r7, #2]	@ zero_extendqisi2
 2687              	.LVL281:
 332:../uvc.c      **** 		 {
 2688              		.loc 1 332 0
 2689 14e8 CC02000A 		beq	.L159
 2690 14ec CC00009A 		bls	.L426
 2691 14f0 850058E3 		cmp	r8, #133
 2692 14f4 1EFFFF0A 		beq	.L281
 2693 14f8 3702003A 		bcc	.L165
 2694 14fc 860058E3 		cmp	r8, #134
 2695 1500 7902000A 		beq	.L166
 2696 1504 870058E3 		cmp	r8, #135
 406:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2697              		.loc 1 406 0
 2698 1508 0B20D705 		ldreqb	r2, [r7, #11]	@ zero_extendqisi2
 407:../uvc.c      **** 			 }
 2699              		.loc 1 407 0
 2700 150c 0C30D705 		ldreqb	r3, [r7, #12]	@ zero_extendqisi2
 332:../uvc.c      **** 		 {
 2701              		.loc 1 332 0
 2702 1510 66FEFF0A 		beq	.L397
 2703 1514 F7FEFFEA 		b	.L275
 2704              	.LVL282:
 2705              	.L417:
 2706              	.LBE202:
 2707              	.LBE201:
 2708              	.LBE285:
 2709              	.LBE298:
 2710              	.LBB299:
 2711              	.LBB105:
2156:../uvc.c      ****                 {
 2712              		.loc 1 2156 0
 2713 1518 010052E3 		cmp	r2, #1
 2714 151c 10FEFF1A 		bne	.L293
2181:../uvc.c      ****                                 glCommitCtrl, &readCount);
 2715              		.loc 1 2181 0
 2716 1520 2000A0E3 		mov	r0, #32
 2717 1524 80179FE5 		ldr	r1, .L438+40
 2718 1528 38208DE2 		add	r2, sp, #56
 2719 152c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2720              	.LVL283:
2183:../uvc.c      ****                         {
 2721              		.loc 1 2183 0
 2722 1530 000050E3 		cmp	r0, #0
 2723 1534 0EFEFF1A 		bne	.L306
2185:../uvc.c      ****                             CyU3PDebugPrint (4, "%d %d %d %d %d %d %d %d %d %d %d\r\n",
 2724              		.loc 1 2185 0
 2725 1538 0400A0E3 		mov	r0, #4
 2726              	.LVL284:
 2727 153c 80179FE5 		ldr	r1, .L438+64
 2728 1540 4BFFFFEA 		b	.L401
 2729              	.LVL285:
 2730              	.L414:
2238:../uvc.c      ****                 {
 2731              		.loc 1 2238 0
 2732 1544 010052E3 		cmp	r2, #1
 2733 1548 05FEFF1A 		bne	.L293
2263:../uvc.c      ****                                 glCommitCtrl, &readCount);
 2734              		.loc 1 2263 0
 2735 154c 2000A0E3 		mov	r0, #32
 2736 1550 54179FE5 		ldr	r1, .L438+40
 2737 1554 38208DE2 		add	r2, sp, #56
 2738 1558 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2739              	.LVL286:
2265:../uvc.c      ****                         {
 2740              		.loc 1 2265 0
 2741 155c 000050E3 		cmp	r0, #0
 2742 1560 B601001A 		bne	.L339
2269:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 2743              		.loc 1 2269 0
 2744 1564 0020A0E3 		mov	r2, #0
 2745 1568 14079FE5 		ldr	r0, .L438
 2746              	.LVL287:
 2747 156c 8010A0E3 		mov	r1, #128
 2748 1570 FEFFFFEB 		bl	_txe_event_flags_set
 2749              	.LVL288:
2270:../uvc.c      ****                             {
 2750              		.loc 1 2270 0
 2751 1574 002050E2 		subs	r2, r0, #0
2276:../uvc.c      ****                             //stillcont = 0;
 2752              		.loc 1 2276 0
 2753 1578 F030A003 		moveq	r3, #240
 2754 157c 74308405 		streq	r3, [r4, #116]
2270:../uvc.c      ****                             {
 2755              		.loc 1 2270 0
 2756 1580 C202001A 		bne	.L427
 2757              	.LVL289:
 2758              	.L341:
2279:../uvc.c      ****                         }else{
 2759              		.loc 1 2279 0
 2760 1584 BD10DAE5 		ldrb	r1, [r10, #189]	@ zero_extendqisi2
 2761 1588 B823DDE1 		ldrh	r2, [sp, #56]
 2762 158c 00108DE5 		str	r1, [sp]
 2763 1590 BC30DAE5 		ldrb	r3, [r10, #188]	@ zero_extendqisi2
 2764 1594 2C179FE5 		ldr	r1, .L438+68
 2765 1598 0400A0E3 		mov	r0, #4
 2766 159c FEFFFFEB 		bl	CyU3PDebugPrint
 2767              	.LVL290:
 2768 15a0 F3FDFFEA 		b	.L306
 2769              	.LVL291:
 2770              	.L413:
2024:../uvc.c      ****             {
 2771              		.loc 1 2024 0
 2772 15a4 010053E3 		cmp	r3, #1
 2773 15a8 EDFDFF1A 		bne	.L293
2049:../uvc.c      ****                             glCommitCtrl, &readCount);
 2774              		.loc 1 2049 0
 2775 15ac 2000A0E3 		mov	r0, #32
 2776 15b0 F4169FE5 		ldr	r1, .L438+40
 2777 15b4 38208DE2 		add	r2, sp, #56
 2778 15b8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2779              	.LVL292:
2051:../uvc.c      ****                     {
 2780              		.loc 1 2051 0
 2781 15bc 000050E3 		cmp	r0, #0
 2782 15c0 EBFDFF1A 		bne	.L306
2053:../uvc.c      ****                         {
 2783              		.loc 1 2053 0
 2784 15c4 BF80DAE5 		ldrb	r8, [r10, #191]	@ zero_extendqisi2
 2785 15c8 DC30DAE5 		ldrb	r3, [r10, #220]	@ zero_extendqisi2
 2786 15cc 080053E1 		cmp	r3, r8
 2787 15d0 0500000A 		beq	.L315
2055:../uvc.c      ****                          {
 2788              		.loc 1 2055 0
 2789 15d4 010058E3 		cmp	r8, #1
 2790 15d8 B002000A 		beq	.L317
 2791 15dc 020058E3 		cmp	r8, #2
 2792 15e0 2D02000A 		beq	.L318
 2793              	.LVL293:
 2794              	.L316:
2070:../uvc.c      ****                         }
 2795              		.loc 1 2070 0
 2796 15e4 BF30DAE5 		ldrb	r3, [r10, #191]	@ zero_extendqisi2
 2797 15e8 DC30CAE5 		strb	r3, [r10, #220]
 2798              	.L315:
2072:../uvc.c      **** 
 2799              		.loc 1 2072 0
 2800 15ec D8169FE5 		ldr	r1, .L438+72
 2801 15f0 DC20DAE5 		ldrb	r2, [r10, #220]	@ zero_extendqisi2
 2802 15f4 0400A0E3 		mov	r0, #4
 2803 15f8 FEFFFFEB 		bl	CyU3PDebugPrint
 2804              	.LVL294:
2085:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 2805              		.loc 1 2085 0
 2806 15fc 0020A0E3 		mov	r2, #0
 2807 1600 7C069FE5 		ldr	r0, .L438
 2808 1604 0110A0E3 		mov	r1, #1
 2809 1608 FEFFFFEB 		bl	_txe_event_flags_set
 2810              	.LVL295:
2086:../uvc.c      ****                         {
 2811              		.loc 1 2086 0
 2812 160c 002050E2 		subs	r2, r0, #0
 2813 1610 D7FDFF0A 		beq	.L306
2088:../uvc.c      ****                         }
 2814              		.loc 1 2088 0
 2815 1614 B4169FE5 		ldr	r1, .L438+76
 2816 1618 0400A0E3 		mov	r0, #4
 2817              	.LVL296:
 2818 161c FEFFFFEB 		bl	CyU3PDebugPrint
 2819              	.LVL297:
 2820 1620 D3FDFFEA 		b	.L306
 2821              	.LVL298:
 2822              	.L337:
2246:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2823              		.loc 1 2246 0
 2824 1624 0020A0E3 		mov	r2, #0
2247:../uvc.c      ****                         break;
 2825              		.loc 1 2247 0
 2826 1628 B4169FE5 		ldr	r1, .L438+96
 2827 162c 0200A0E3 		mov	r0, #2
2245:../uvc.c      ****                         glEp0Buffer[1] = 0;
 2828              		.loc 1 2245 0
 2829 1630 9830CAE5 		strb	r3, [r10, #152]
2246:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2830              		.loc 1 2246 0
 2831 1634 9920CAE5 		strb	r2, [r10, #153]
2247:../uvc.c      ****                         break;
 2832              		.loc 1 2247 0
 2833 1638 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2834              	.LVL299:
 2835 163c CCFDFFEA 		b	.L306
 2836              	.LVL300:
 2837              	.L422:
 2838              	.LBE105:
 2839              	.LBE299:
 2840              	.LBB300:
 2841              	.LBB286:
 2842              	.LBB210:
 2843              	.LBB175:
 332:../uvc.c      **** 		 {
 2844              		.loc 1 332 0
 2845 1640 810058E3 		cmp	r8, #129
 2846 1644 0002000A 		beq	.L252
 2847 1648 3202008A 		bhi	.L253
 2848 164c 010058E3 		cmp	r8, #1
 2849 1650 A8FEFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2850              		.loc 1 413 0
 2851 1654 38208DE2 		add	r2, sp, #56
 2852 1658 2000A0E3 		mov	r0, #32
 2853 165c 80169FE5 		ldr	r1, .L438+96
 2854 1660 28308DE5 		str	r3, [sp, #40]
 2855 1664 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2856              	.LVL301:
 415:../uvc.c      **** 			   {
 2857              		.loc 1 415 0
 2858 1668 002050E2 		subs	r2, r0, #0
 2859 166c 1702001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2860              		.loc 1 429 0
 2861 1670 5C169FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2862              		.loc 1 417 0
 2863 1674 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 2864              	.LVL302:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2865              		.loc 1 429 0
 2866 1678 1C0091E5 		ldr	r0, [r1, #28]
 2867              	.LVL303:
 2868 167c 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2869              		.loc 1 420 0
 2870 1680 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 2871              	.LVL304:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2872              		.loc 1 429 0
 2873 1684 30208DE5 		str	r2, [sp, #48]
 2874 1688 2CC08DE5 		str	ip, [sp, #44]
 2875 168c FEFFFFEB 		bl	_txe_mutex_get
 2876              	.LVL305:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2877              		.loc 1 430 0
 2878 1690 2CC09DE5 		ldr	ip, [sp, #44]
 2879 1694 30209DE5 		ldr	r2, [sp, #48]
 2880 1698 00C08DE5 		str	ip, [sp]
 2881 169c 28309DE5 		ldr	r3, [sp, #40]
 2882 16a0 0910A0E3 		mov	r1, #9
 2883 16a4 04208DE5 		str	r2, [sp, #4]
 2884 16a8 24069FE5 		ldr	r0, .L438+80
 2885 16ac 34209DE5 		ldr	r2, [sp, #52]
 2886 16b0 FEFFFFEB 		bl	cmdSet
 2887              	.LVL306:
 431:../uvc.c      **** 
 2888              		.loc 1 431 0
 2889 16b4 18269FE5 		ldr	r2, .L438+80
 2890 16b8 1C0092E5 		ldr	r0, [r2, #28]
 2891 16bc FEFFFFEB 		bl	_txe_mutex_put
 2892              	.LVL307:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2893              		.loc 1 433 0
 2894 16c0 2CC09DE5 		ldr	ip, [sp, #44]
 2895 16c4 BC159FE5 		ldr	r1, .L438+4
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2896              		.loc 1 320 0
 2897 16c8 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2898              		.loc 1 433 0
 2899 16cc E5C0C1E5 		strb	ip, [r1, #229]
 434:../uvc.c      **** 							 break;
 2900              		.loc 1 434 0
 2901 16d0 E880C1E5 		strb	r8, [r1, #232]
 2902 16d4 AFFEFFEA 		b	.L285
 2903              	.LVL308:
 2904              	.L419:
 2905              	.LBE175:
 2906              	.LBE210:
 2907              	.LBB211:
 2908              	.LBB148:
 332:../uvc.c      **** 		 {
 2909              		.loc 1 332 0
 2910 16d8 810058E3 		cmp	r8, #129
 2911 16dc 9801000A 		beq	.L239
 2912 16e0 1002008A 		bhi	.L240
 2913 16e4 010058E3 		cmp	r8, #1
 2914 16e8 82FEFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2915              		.loc 1 413 0
 2916 16ec 38208DE2 		add	r2, sp, #56
 2917 16f0 2000A0E3 		mov	r0, #32
 2918 16f4 E8159FE5 		ldr	r1, .L438+96
 2919 16f8 28308DE5 		str	r3, [sp, #40]
 2920 16fc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2921              	.LVL309:
 415:../uvc.c      **** 			   {
 2922              		.loc 1 415 0
 2923 1700 002050E2 		subs	r2, r0, #0
 2924 1704 F101001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2925              		.loc 1 429 0
 2926 1708 C4159FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2927              		.loc 1 417 0
 2928 170c 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 2929              	.LVL310:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2930              		.loc 1 429 0
 2931 1710 1C0091E5 		ldr	r0, [r1, #28]
 2932              	.LVL311:
 2933 1714 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2934              		.loc 1 420 0
 2935 1718 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 2936              	.LVL312:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2937              		.loc 1 429 0
 2938 171c 30208DE5 		str	r2, [sp, #48]
 2939 1720 2CC08DE5 		str	ip, [sp, #44]
 2940 1724 FEFFFFEB 		bl	_txe_mutex_get
 2941              	.LVL313:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2942              		.loc 1 430 0
 2943 1728 2CC09DE5 		ldr	ip, [sp, #44]
 2944 172c 30209DE5 		ldr	r2, [sp, #48]
 2945 1730 00C08DE5 		str	ip, [sp]
 2946 1734 28309DE5 		ldr	r3, [sp, #40]
 2947 1738 04208DE5 		str	r2, [sp, #4]
 2948 173c 0710A0E3 		mov	r1, #7
 2949 1740 34209DE5 		ldr	r2, [sp, #52]
 2950 1744 88059FE5 		ldr	r0, .L438+80
 2951 1748 FEFFFFEB 		bl	cmdSet
 2952              	.LVL314:
 431:../uvc.c      **** 
 2953              		.loc 1 431 0
 2954 174c 80259FE5 		ldr	r2, .L438+80
 2955 1750 1C0092E5 		ldr	r0, [r2, #28]
 2956 1754 FEFFFFEB 		bl	_txe_mutex_put
 2957              	.LVL315:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2958              		.loc 1 433 0
 2959 1758 2CC09DE5 		ldr	ip, [sp, #44]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2960              		.loc 1 320 0
 2961 175c FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2962              		.loc 1 433 0
 2963 1760 B5C0C7E5 		strb	ip, [r7, #181]
 434:../uvc.c      **** 							 break;
 2964              		.loc 1 434 0
 2965 1764 B880C7E5 		strb	r8, [r7, #184]
 2966 1768 8AFEFFEA 		b	.L285
 2967              	.LVL316:
 2968              	.L424:
 2969              	.LBE148:
 2970              	.LBE211:
 2971              	.LBB212:
 2972              	.LBB125:
 332:../uvc.c      **** 		 {
 2973              		.loc 1 332 0
 2974 176c 810058E3 		cmp	r8, #129
 2975 1770 A301000A 		beq	.L278
 2976 1774 EE01008A 		bhi	.L279
 2977 1778 010058E3 		cmp	r8, #1
 2978 177c 5DFEFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2979              		.loc 1 413 0
 2980 1780 38208DE2 		add	r2, sp, #56
 2981 1784 2000A0E3 		mov	r0, #32
 2982 1788 54159FE5 		ldr	r1, .L438+96
 2983 178c 28308DE5 		str	r3, [sp, #40]
 2984 1790 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2985              	.LVL317:
 415:../uvc.c      **** 			   {
 2986              		.loc 1 415 0
 2987 1794 002050E2 		subs	r2, r0, #0
 2988 1798 CC01001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2989              		.loc 1 429 0
 2990 179c 30159FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2991              		.loc 1 417 0
 2992 17a0 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 2993              	.LVL318:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2994              		.loc 1 429 0
 2995 17a4 1C0091E5 		ldr	r0, [r1, #28]
 2996              	.LVL319:
 2997 17a8 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2998              		.loc 1 420 0
 2999 17ac 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3000              	.LVL320:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3001              		.loc 1 429 0
 3002 17b0 30208DE5 		str	r2, [sp, #48]
 3003 17b4 2CC08DE5 		str	ip, [sp, #44]
 3004 17b8 FEFFFFEB 		bl	_txe_mutex_get
 3005              	.LVL321:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3006              		.loc 1 430 0
 3007 17bc 2CC09DE5 		ldr	ip, [sp, #44]
 3008 17c0 30209DE5 		ldr	r2, [sp, #48]
 3009 17c4 00C08DE5 		str	ip, [sp]
 3010 17c8 28309DE5 		ldr	r3, [sp, #40]
 3011 17cc 04208DE5 		str	r2, [sp, #4]
 3012 17d0 0E10A0E3 		mov	r1, #14
 3013 17d4 34209DE5 		ldr	r2, [sp, #52]
 3014 17d8 F4049FE5 		ldr	r0, .L438+80
 3015 17dc FEFFFFEB 		bl	cmdSet
 3016              	.LVL322:
 431:../uvc.c      **** 
 3017              		.loc 1 431 0
 3018 17e0 EC249FE5 		ldr	r2, .L438+80
 3019 17e4 1C0092E5 		ldr	r0, [r2, #28]
 3020 17e8 FEFFFFEB 		bl	_txe_mutex_put
 3021              	.LVL323:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3022              		.loc 1 433 0
 3023 17ec 2CC09DE5 		ldr	ip, [sp, #44]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3024              		.loc 1 320 0
 3025 17f0 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3026              		.loc 1 433 0
 3027 17f4 5DC1C7E5 		strb	ip, [r7, #349]
 434:../uvc.c      **** 							 break;
 3028              		.loc 1 434 0
 3029 17f8 6081C7E5 		strb	r8, [r7, #352]
 3030 17fc 65FEFFEA 		b	.L285
 3031              	.LVL324:
 3032              	.L412:
 3033 1800 0030A0E1 		mov	r3, r0
 3034              	.LBE125:
 3035              	.LBE212:
 3036              	.LBE286:
 3037              	.LBE300:
2421:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 3038              		.loc 1 2421 0
 3039 1804 0320A0E1 		mov	r2, r3
 3040 1808 0900A0E1 		mov	r0, r9
 3041              	.LVL325:
 3042 180c C4149FE5 		ldr	r1, .L438+84
 3043 1810 28308DE5 		str	r3, [sp, #40]
 3044 1814 FEFFFFEB 		bl	CyU3PDebugPrint
 3045              	.LVL326:
2422:../uvc.c      **** 					}
 3046              		.loc 1 2422 0
 3047 1818 28309DE5 		ldr	r3, [sp, #40]
 3048 181c 0300A0E1 		mov	r0, r3
 3049 1820 FEFFFFEB 		bl	CyFxAppErrorHandler
 3050              	.LVL327:
 3051              	.L426:
 3052              	.LBB301:
 3053              	.LBB287:
 3054              	.LBB213:
 3055              	.LBB203:
 332:../uvc.c      **** 		 {
 3056              		.loc 1 332 0
 3057 1824 810058E3 		cmp	r8, #129
 3058 1828 6101000A 		beq	.L161
 3059 182c C901008A 		bhi	.L162
 3060 1830 010058E3 		cmp	r8, #1
 3061 1834 2FFEFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3062              		.loc 1 413 0
 3063 1838 38208DE2 		add	r2, sp, #56
 3064 183c 2000A0E3 		mov	r0, #32
 3065 1840 9C149FE5 		ldr	r1, .L438+96
 3066 1844 28308DE5 		str	r3, [sp, #40]
 3067 1848 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3068              	.LVL328:
 415:../uvc.c      **** 			   {
 3069              		.loc 1 415 0
 3070 184c 002050E2 		subs	r2, r0, #0
 3071 1850 9E01001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3072              		.loc 1 429 0
 3073 1854 78149FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3074              		.loc 1 417 0
 3075 1858 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3076              	.LVL329:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3077              		.loc 1 429 0
 3078 185c 1C0091E5 		ldr	r0, [r1, #28]
 3079              	.LVL330:
 3080 1860 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3081              		.loc 1 420 0
 3082 1864 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3083              	.LVL331:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3084              		.loc 1 429 0
 3085 1868 30208DE5 		str	r2, [sp, #48]
 3086 186c 2CC08DE5 		str	ip, [sp, #44]
 3087 1870 FEFFFFEB 		bl	_txe_mutex_get
 3088              	.LVL332:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3089              		.loc 1 430 0
 3090 1874 2CC09DE5 		ldr	ip, [sp, #44]
 3091 1878 30209DE5 		ldr	r2, [sp, #48]
 3092 187c 00C08DE5 		str	ip, [sp]
 3093 1880 0210A0E1 		mov	r1, r2
 3094 1884 28309DE5 		ldr	r3, [sp, #40]
 3095 1888 04208DE5 		str	r2, [sp, #4]
 3096 188c 40049FE5 		ldr	r0, .L438+80
 3097 1890 34209DE5 		ldr	r2, [sp, #52]
 3098 1894 FEFFFFEB 		bl	cmdSet
 3099              	.LVL333:
 431:../uvc.c      **** 
 3100              		.loc 1 431 0
 3101 1898 34249FE5 		ldr	r2, .L438+80
 3102 189c 1C0092E5 		ldr	r0, [r2, #28]
 3103 18a0 FEFFFFEB 		bl	_txe_mutex_put
 3104              	.LVL334:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3105              		.loc 1 433 0
 3106 18a4 2CC09DE5 		ldr	ip, [sp, #44]
 434:../uvc.c      **** 							 break;
 3107              		.loc 1 434 0
 3108 18a8 0130A0E3 		mov	r3, #1
 3109 18ac 1030C7E5 		strb	r3, [r7, #16]
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3110              		.loc 1 433 0
 3111 18b0 0DC0C7E5 		strb	ip, [r7, #13]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3112              		.loc 1 320 0
 3113 18b4 FF30A0E3 		mov	r3, #255
 3114 18b8 36FEFFEA 		b	.L285
 3115              	.LVL335:
 3116              	.L411:
 3117              	.LBE203:
 3118              	.LBE213:
 3119              	.LBB214:
 3120              	.LBB113:
 332:../uvc.c      **** 		 {
 3121              		.loc 1 332 0
 3122 18bc 810058E3 		cmp	r8, #129
 3123 18c0 4001000A 		beq	.L174
 3124 18c4 A701008A 		bhi	.L175
 3125 18c8 010058E3 		cmp	r8, #1
 3126 18cc 09FEFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3127              		.loc 1 413 0
 3128 18d0 38208DE2 		add	r2, sp, #56
 3129 18d4 2000A0E3 		mov	r0, #32
 3130 18d8 04149FE5 		ldr	r1, .L438+96
 3131 18dc 28308DE5 		str	r3, [sp, #40]
 3132 18e0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3133              	.LVL336:
 415:../uvc.c      **** 			   {
 3134              		.loc 1 415 0
 3135 18e4 002050E2 		subs	r2, r0, #0
 3136 18e8 7801001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3137              		.loc 1 429 0
 3138 18ec E0139FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3139              		.loc 1 417 0
 3140 18f0 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3141              	.LVL337:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3142              		.loc 1 429 0
 3143 18f4 1C0091E5 		ldr	r0, [r1, #28]
 3144              	.LVL338:
 3145 18f8 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3146              		.loc 1 420 0
 3147 18fc 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3148              	.LVL339:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3149              		.loc 1 429 0
 3150 1900 30208DE5 		str	r2, [sp, #48]
 3151 1904 2CC08DE5 		str	ip, [sp, #44]
 3152 1908 FEFFFFEB 		bl	_txe_mutex_get
 3153              	.LVL340:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3154              		.loc 1 430 0
 3155 190c 2CC09DE5 		ldr	ip, [sp, #44]
 3156 1910 30209DE5 		ldr	r2, [sp, #48]
 3157 1914 00C08DE5 		str	ip, [sp]
 3158 1918 28309DE5 		ldr	r3, [sp, #40]
 3159 191c 04208DE5 		str	r2, [sp, #4]
 3160 1920 1A10A0E3 		mov	r1, #26
 3161 1924 34209DE5 		ldr	r2, [sp, #52]
 3162 1928 A4039FE5 		ldr	r0, .L438+80
 3163 192c FEFFFFEB 		bl	cmdSet
 3164              	.LVL341:
 431:../uvc.c      **** 
 3165              		.loc 1 431 0
 3166 1930 9C239FE5 		ldr	r2, .L438+80
 3167 1934 1C0092E5 		ldr	r0, [r2, #28]
 3168 1938 FEFFFFEB 		bl	_txe_mutex_put
 3169              	.LVL342:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3170              		.loc 1 433 0
 3171 193c 2CC09DE5 		ldr	ip, [sp, #44]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3172              		.loc 1 320 0
 3173 1940 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3174              		.loc 1 433 0
 3175 1944 7DC2C7E5 		strb	ip, [r7, #637]
 434:../uvc.c      **** 							 break;
 3176              		.loc 1 434 0
 3177 1948 8082C7E5 		strb	r8, [r7, #640]
 3178 194c 11FEFFEA 		b	.L285
 3179              	.LVL343:
 3180              	.L420:
 3181              	.LBE113:
 3182              	.LBE214:
 3183              	.LBB215:
 3184              	.LBB158:
 332:../uvc.c      **** 		 {
 3185              		.loc 1 332 0
 3186 1950 810058E3 		cmp	r8, #129
 3187 1954 2F01000A 		beq	.L265
 3188 1958 7801008A 		bhi	.L266
 3189 195c 010058E3 		cmp	r8, #1
 3190 1960 E4FDFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3191              		.loc 1 413 0
 3192 1964 38208DE2 		add	r2, sp, #56
 3193 1968 2000A0E3 		mov	r0, #32
 3194 196c 70139FE5 		ldr	r1, .L438+96
 3195 1970 28308DE5 		str	r3, [sp, #40]
 3196 1974 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3197              	.LVL344:
 415:../uvc.c      **** 			   {
 3198              		.loc 1 415 0
 3199 1978 002050E2 		subs	r2, r0, #0
 3200 197c 5301001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3201              		.loc 1 429 0
 3202 1980 4C139FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3203              		.loc 1 417 0
 3204 1984 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3205              	.LVL345:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3206              		.loc 1 429 0
 3207 1988 1C0091E5 		ldr	r0, [r1, #28]
 3208              	.LVL346:
 3209 198c 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3210              		.loc 1 420 0
 3211 1990 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3212              	.LVL347:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3213              		.loc 1 429 0
 3214 1994 30208DE5 		str	r2, [sp, #48]
 3215 1998 2CC08DE5 		str	ip, [sp, #44]
 3216 199c FEFFFFEB 		bl	_txe_mutex_get
 3217              	.LVL348:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3218              		.loc 1 430 0
 3219 19a0 2CC09DE5 		ldr	ip, [sp, #44]
 3220 19a4 30209DE5 		ldr	r2, [sp, #48]
 3221 19a8 00C08DE5 		str	ip, [sp]
 3222 19ac 28309DE5 		ldr	r3, [sp, #40]
 3223 19b0 04208DE5 		str	r2, [sp, #4]
 3224 19b4 0B10A0E3 		mov	r1, #11
 3225 19b8 34209DE5 		ldr	r2, [sp, #52]
 3226 19bc 10039FE5 		ldr	r0, .L438+80
 3227 19c0 FEFFFFEB 		bl	cmdSet
 3228              	.LVL349:
 431:../uvc.c      **** 
 3229              		.loc 1 431 0
 3230 19c4 08239FE5 		ldr	r2, .L438+80
 3231 19c8 1C0092E5 		ldr	r0, [r2, #28]
 3232 19cc FEFFFFEB 		bl	_txe_mutex_put
 3233              	.LVL350:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3234              		.loc 1 433 0
 3235 19d0 2CC09DE5 		ldr	ip, [sp, #44]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3236              		.loc 1 320 0
 3237 19d4 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3238              		.loc 1 433 0
 3239 19d8 15C1C7E5 		strb	ip, [r7, #277]
 434:../uvc.c      **** 							 break;
 3240              		.loc 1 434 0
 3241 19dc 1881C7E5 		strb	r8, [r7, #280]
 3242 19e0 ECFDFFEA 		b	.L285
 3243              	.LVL351:
 3244              	.L418:
 3245              	.LBE158:
 3246              	.LBE215:
 3247              	.LBB216:
 3248              	.LBB138:
 332:../uvc.c      **** 		 {
 3249              		.loc 1 332 0
 3250 19e4 810058E3 		cmp	r8, #129
 3251 19e8 1201000A 		beq	.L200
 3252 19ec 5601008A 		bhi	.L201
 3253 19f0 010058E3 		cmp	r8, #1
 3254 19f4 BFFDFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3255              		.loc 1 413 0
 3256 19f8 38208DE2 		add	r2, sp, #56
 3257 19fc 2000A0E3 		mov	r0, #32
 3258 1a00 DC129FE5 		ldr	r1, .L438+96
 3259 1a04 28308DE5 		str	r3, [sp, #40]
 3260 1a08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3261              	.LVL352:
 415:../uvc.c      **** 			   {
 3262              		.loc 1 415 0
 3263 1a0c 002050E2 		subs	r2, r0, #0
 3264 1a10 2E01001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3265              		.loc 1 429 0
 3266 1a14 B8129FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3267              		.loc 1 417 0
 3268 1a18 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3269              	.LVL353:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3270              		.loc 1 429 0
 3271 1a1c 1C0091E5 		ldr	r0, [r1, #28]
 3272              	.LVL354:
 3273 1a20 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3274              		.loc 1 420 0
 3275 1a24 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3276              	.LVL355:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3277              		.loc 1 429 0
 3278 1a28 30208DE5 		str	r2, [sp, #48]
 3279 1a2c 2CC08DE5 		str	ip, [sp, #44]
 3280 1a30 FEFFFFEB 		bl	_txe_mutex_get
 3281              	.LVL356:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3282              		.loc 1 430 0
 3283 1a34 2CC09DE5 		ldr	ip, [sp, #44]
 3284 1a38 30209DE5 		ldr	r2, [sp, #48]
 3285 1a3c 00C08DE5 		str	ip, [sp]
 3286 1a40 28309DE5 		ldr	r3, [sp, #40]
 3287 1a44 04208DE5 		str	r2, [sp, #4]
 3288 1a48 0410A0E3 		mov	r1, #4
 3289 1a4c 34209DE5 		ldr	r2, [sp, #52]
 3290 1a50 7C029FE5 		ldr	r0, .L438+80
 3291 1a54 FEFFFFEB 		bl	cmdSet
 3292              	.LVL357:
 431:../uvc.c      **** 
 3293              		.loc 1 431 0
 3294 1a58 74229FE5 		ldr	r2, .L438+80
 3295 1a5c 1C0092E5 		ldr	r0, [r2, #28]
 3296 1a60 FEFFFFEB 		bl	_txe_mutex_put
 3297              	.LVL358:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3298              		.loc 1 433 0
 3299 1a64 2CC09DE5 		ldr	ip, [sp, #44]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3300              		.loc 1 320 0
 3301 1a68 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3302              		.loc 1 433 0
 3303 1a6c 6DC0C7E5 		strb	ip, [r7, #109]
 434:../uvc.c      **** 							 break;
 3304              		.loc 1 434 0
 3305 1a70 7080C7E5 		strb	r8, [r7, #112]
 3306 1a74 C7FDFFEA 		b	.L285
 3307              	.LVL359:
 3308              	.L423:
 3309              	.LBE138:
 3310              	.LBE216:
 3311              	.LBB217:
 3312              	.LBB184:
 332:../uvc.c      **** 		 {
 3313              		.loc 1 332 0
 3314 1a78 810058E3 		cmp	r8, #129
 3315 1a7c 9C00000A 		beq	.L213
 3316 1a80 4001008A 		bhi	.L214
 3317 1a84 010058E3 		cmp	r8, #1
 3318 1a88 9AFDFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3319              		.loc 1 413 0
 3320 1a8c 38208DE2 		add	r2, sp, #56
 3321 1a90 2000A0E3 		mov	r0, #32
 3322 1a94 48129FE5 		ldr	r1, .L438+96
 3323 1a98 28308DE5 		str	r3, [sp, #40]
 3324 1a9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3325              	.LVL360:
 415:../uvc.c      **** 			   {
 3326              		.loc 1 415 0
 3327 1aa0 002050E2 		subs	r2, r0, #0
 3328 1aa4 0901001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3329              		.loc 1 429 0
 3330 1aa8 24129FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3331              		.loc 1 417 0
 3332 1aac 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3333              	.LVL361:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3334              		.loc 1 429 0
 3335 1ab0 1C0091E5 		ldr	r0, [r1, #28]
 3336              	.LVL362:
 3337 1ab4 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3338              		.loc 1 420 0
 3339 1ab8 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3340              	.LVL363:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3341              		.loc 1 429 0
 3342 1abc 30208DE5 		str	r2, [sp, #48]
 3343 1ac0 2CC08DE5 		str	ip, [sp, #44]
 3344 1ac4 FEFFFFEB 		bl	_txe_mutex_get
 3345              	.LVL364:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3346              		.loc 1 430 0
 3347 1ac8 2CC09DE5 		ldr	ip, [sp, #44]
 3348 1acc 30209DE5 		ldr	r2, [sp, #48]
 3349 1ad0 00C08DE5 		str	ip, [sp]
 3350 1ad4 28309DE5 		ldr	r3, [sp, #40]
 3351 1ad8 0510A0E3 		mov	r1, #5
 3352 1adc 04208DE5 		str	r2, [sp, #4]
 3353 1ae0 EC019FE5 		ldr	r0, .L438+80
 3354 1ae4 34209DE5 		ldr	r2, [sp, #52]
 3355 1ae8 FEFFFFEB 		bl	cmdSet
 3356              	.LVL365:
 431:../uvc.c      **** 
 3357              		.loc 1 431 0
 3358 1aec E0219FE5 		ldr	r2, .L438+80
 3359 1af0 1C0092E5 		ldr	r0, [r2, #28]
 3360 1af4 FEFFFFEB 		bl	_txe_mutex_put
 3361              	.LVL366:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3362              		.loc 1 433 0
 3363 1af8 2CC09DE5 		ldr	ip, [sp, #44]
 3364 1afc 84119FE5 		ldr	r1, .L438+4
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3365              		.loc 1 320 0
 3366 1b00 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3367              		.loc 1 433 0
 3368 1b04 85C0C1E5 		strb	ip, [r1, #133]
 434:../uvc.c      **** 							 break;
 3369              		.loc 1 434 0
 3370 1b08 8880C1E5 		strb	r8, [r1, #136]
 3371 1b0c A1FDFFEA 		b	.L285
 3372              	.LVL367:
 3373              	.L421:
 3374              	.LBE184:
 3375              	.LBE217:
 3376              	.LBB218:
 3377              	.LBB166:
 332:../uvc.c      **** 		 {
 3378              		.loc 1 332 0
 3379 1b10 810058E3 		cmp	r8, #129
 3380 1b14 8500000A 		beq	.L187
 3381 1b18 1E01008A 		bhi	.L188
 3382 1b1c 010058E3 		cmp	r8, #1
 3383 1b20 74FDFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3384              		.loc 1 413 0
 3385 1b24 38208DE2 		add	r2, sp, #56
 3386 1b28 2000A0E3 		mov	r0, #32
 3387 1b2c B0119FE5 		ldr	r1, .L438+96
 3388 1b30 28308DE5 		str	r3, [sp, #40]
 3389 1b34 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3390              	.LVL368:
 415:../uvc.c      **** 			   {
 3391              		.loc 1 415 0
 3392 1b38 002050E2 		subs	r2, r0, #0
 3393 1b3c E300001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3394              		.loc 1 429 0
 3395 1b40 8C119FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3396              		.loc 1 417 0
 3397 1b44 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3398              	.LVL369:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3399              		.loc 1 429 0
 3400 1b48 1C0091E5 		ldr	r0, [r1, #28]
 3401              	.LVL370:
 3402 1b4c 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3403              		.loc 1 420 0
 3404 1b50 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3405              	.LVL371:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3406              		.loc 1 429 0
 3407 1b54 30208DE5 		str	r2, [sp, #48]
 3408 1b58 2CC08DE5 		str	ip, [sp, #44]
 3409 1b5c FEFFFFEB 		bl	_txe_mutex_get
 3410              	.LVL372:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3411              		.loc 1 430 0
 3412 1b60 2CC09DE5 		ldr	ip, [sp, #44]
 3413 1b64 30209DE5 		ldr	r2, [sp, #48]
 3414 1b68 00C08DE5 		str	ip, [sp]
 3415 1b6c 28309DE5 		ldr	r3, [sp, #40]
 3416 1b70 0210A0E3 		mov	r1, #2
 3417 1b74 04208DE5 		str	r2, [sp, #4]
 3418 1b78 54019FE5 		ldr	r0, .L438+80
 3419 1b7c 34209DE5 		ldr	r2, [sp, #52]
 3420 1b80 FEFFFFEB 		bl	cmdSet
 3421              	.LVL373:
 431:../uvc.c      **** 
 3422              		.loc 1 431 0
 3423 1b84 48219FE5 		ldr	r2, .L438+80
 3424 1b88 1C0092E5 		ldr	r0, [r2, #28]
 3425 1b8c FEFFFFEB 		bl	_txe_mutex_put
 3426              	.LVL374:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3427              		.loc 1 433 0
 3428 1b90 2CC09DE5 		ldr	ip, [sp, #44]
 3429 1b94 EC109FE5 		ldr	r1, .L438+4
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3430              		.loc 1 320 0
 3431 1b98 FF30A0E3 		mov	r3, #255
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3432              		.loc 1 433 0
 3433 1b9c 3DC0C1E5 		strb	ip, [r1, #61]
 434:../uvc.c      **** 							 break;
 3434              		.loc 1 434 0
 3435 1ba0 4080C1E5 		strb	r8, [r1, #64]
 3436 1ba4 7BFDFFEA 		b	.L285
 3437              	.LVL375:
 3438              	.L425:
 3439              	.LBE166:
 3440              	.LBE218:
 3441              	.LBB219:
 3442              	.LBB194:
 332:../uvc.c      **** 		 {
 3443              		.loc 1 332 0
 3444 1ba8 810058E3 		cmp	r8, #129
 3445 1bac 6900000A 		beq	.L226
 3446 1bb0 FC00008A 		bhi	.L227
 3447 1bb4 010058E3 		cmp	r8, #1
 3448 1bb8 4EFDFF1A 		bne	.L275
 413:../uvc.c      **** 				  glEp0Buffer, &readCount);
 3449              		.loc 1 413 0
 3450 1bbc 38208DE2 		add	r2, sp, #56
 3451 1bc0 2000A0E3 		mov	r0, #32
 3452 1bc4 18119FE5 		ldr	r1, .L438+96
 3453 1bc8 28308DE5 		str	r3, [sp, #40]
 3454 1bcc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3455              	.LVL376:
 415:../uvc.c      **** 			   {
 3456              		.loc 1 415 0
 3457 1bd0 002050E2 		subs	r2, r0, #0
 3458 1bd4 BD00001A 		bne	.L287
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3459              		.loc 1 429 0
 3460 1bd8 F4109FE5 		ldr	r1, .L438+80
 417:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 3461              		.loc 1 417 0
 3462 1bdc 98C0D4E5 		ldrb	ip, [r4, #152]	@ zero_extendqisi2
 3463              	.LVL377:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3464              		.loc 1 429 0
 3465 1be0 1C0091E5 		ldr	r0, [r1, #28]
 3466              	.LVL378:
 3467 1be4 0010E0E3 		mvn	r1, #0
 420:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3468              		.loc 1 420 0
 3469 1be8 9A90D4E5 		ldrb	r9, [r4, #154]	@ zero_extendqisi2
 3470              	.LVL379:
 429:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3471              		.loc 1 429 0
 3472 1bec 30208DE5 		str	r2, [sp, #48]
 3473 1bf0 2CC08DE5 		str	ip, [sp, #44]
 3474 1bf4 FEFFFFEB 		bl	_txe_mutex_get
 3475              	.LVL380:
 430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3476              		.loc 1 430 0
 3477 1bf8 2CC09DE5 		ldr	ip, [sp, #44]
 3478 1bfc 30209DE5 		ldr	r2, [sp, #48]
 3479 1c00 00C08DE5 		str	ip, [sp]
 3480 1c04 28309DE5 		ldr	r3, [sp, #40]
 3481 1c08 04208DE5 		str	r2, [sp, #4]
 3482 1c0c 0610A0E3 		mov	r1, #6
 3483 1c10 34209DE5 		ldr	r2, [sp, #52]
 3484 1c14 B8009FE5 		ldr	r0, .L438+80
 3485 1c18 FEFFFFEB 		bl	cmdSet
 3486              	.LVL381:
 431:../uvc.c      **** 
 3487              		.loc 1 431 0
 3488 1c1c B0209FE5 		ldr	r2, .L438+80
 3489 1c20 1C0092E5 		ldr	r0, [r2, #28]
 3490 1c24 FEFFFFEB 		bl	_txe_mutex_put
 3491              	.LVL382:
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3492              		.loc 1 433 0
 3493 1c28 2CC09DE5 		ldr	ip, [sp, #44]
 434:../uvc.c      **** 							 break;
 3494              		.loc 1 434 0
 3495 1c2c 0130A0E3 		mov	r3, #1
 3496 1c30 A030C7E5 		strb	r3, [r7, #160]
 433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3497              		.loc 1 433 0
 3498 1c34 9DC0C7E5 		strb	ip, [r7, #157]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3499              		.loc 1 320 0
 3500 1c38 FF30A0E3 		mov	r3, #255
 3501 1c3c 55FDFFEA 		b	.L285
 3502              	.LVL383:
 3503              	.L339:
 3504              	.LBE194:
 3505              	.LBE219:
 3506              	.LBE287:
 3507              	.LBE301:
 3508              	.LBB302:
 3509              	.LBB106:
2281:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 3510              		.loc 1 2281 0
 3511 1c40 B823DDE1 		ldrh	r2, [sp, #56]
 3512 1c44 90109FE5 		ldr	r1, .L438+88
 3513 1c48 BC30DAE5 		ldrb	r3, [r10, #188]	@ zero_extendqisi2
 3514 1c4c 0400A0E3 		mov	r0, #4
 3515              	.LVL384:
 3516 1c50 FEFFFFEB 		bl	CyU3PDebugPrint
 3517              	.LVL385:
2282:../uvc.c      ****                         }
 3518              		.loc 1 2282 0
 3519 1c54 0000A0E3 		mov	r0, #0
 3520 1c58 0020A0E1 		mov	r2, r0
 3521 1c5c 0110A0E3 		mov	r1, #1
 3522 1c60 FEFFFFEB 		bl	CyU3PUsbStall
 3523              	.LVL386:
 3524 1c64 42FCFFEA 		b	.L306
 3525              	.LVL387:
 3526              	.L410:
 3527 1c68 0080A0E1 		mov	r8, r0
 3528              	.LBE106:
 3529              	.LBE302:
2445:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 3530              		.loc 1 2445 0
 3531 1c6c 64109FE5 		ldr	r1, .L438+84
 3532 1c70 0900A0E1 		mov	r0, r9
 3533              	.LVL388:
 3534 1c74 0820A0E1 		mov	r2, r8
 3535 1c78 FEFFFFEB 		bl	CyU3PDebugPrint
 3536              	.LVL389:
2446:../uvc.c      **** 					}
 3537              		.loc 1 2446 0
 3538 1c7c 0800A0E1 		mov	r0, r8
 3539 1c80 FEFFFFEB 		bl	CyFxAppErrorHandler
 3540              	.LVL390:
 3541              	.L439:
 3542              		.align	2
 3543              	.L438:
 3544 1c84 00000000 		.word	.LANCHOR0
 3545 1c88 00000000 		.word	.LANCHOR1
 3546 1c8c 00000000 		.word	glInterStaBuffer
 3547 1c90 00000000 		.word	wIndex
 3548 1c94 00000000 		.word	wValue
 3549 1c98 00000000 		.word	bRequest
 3550 1c9c A4020000 		.word	.LC16
 3551 1ca0 00000000 		.word	glChHandleInterStat
 3552 1ca4 0C030000 		.word	.LANCHOR1+780
 3553 1ca8 40020000 		.word	.LC14
 3554 1cac BC000000 		.word	.LANCHOR0+188
 3555 1cb0 D0020000 		.word	.LC17
 3556 1cb4 78030000 		.word	.LC21
 3557 1cb8 A0030000 		.word	.LC22
 3558 1cbc 28030000 		.word	.LANCHOR1+808
 3559 1cc0 34030000 		.word	.LANCHOR1+820
 3560 1cc4 C4030000 		.word	.LC23
 3561 1cc8 10040000 		.word	.LC25
 3562 1ccc 28030000 		.word	.LC19
 3563 1cd0 50030000 		.word	.LC20
 3564 1cd4 00000000 		.word	cmdQu
 3565 1cd8 64040000 		.word	.LC27
 3566 1cdc 3C040000 		.word	.LC26
 3567 1ce0 10020000 		.word	.LC13
 3568 1ce4 98000000 		.word	.LANCHOR0+152
 3569 1ce8 EC030000 		.word	.LC24
 3570 1cec 04030000 		.word	.LC18
 3571 1cf0 00000000 		.word	.LANCHOR1
 3572              	.LVL391:
 3573              	.L213:
 3574              	.LBB303:
 3575              	.LBB288:
 3576              	.LBB220:
 3577              	.LBB185:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3578              		.loc 1 348 0
 3579 1cf4 3120DAE5 		ldrb	r2, [r10, #49]	@ zero_extendqisi2
 3580 1cf8 000052E3 		cmp	r2, #0
 3581 1cfc FB00000A 		beq	.L428
 3582              	.LVL392:
 3583              	.L221:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3584              		.loc 1 358 0
 3585 1d00 8530D7E5 		ldrb	r3, [r7, #133]	@ zero_extendqisi2
 3586              	.LVL393:
 3587              	.L404:
 3588              	.LBE185:
 3589              	.LBE220:
 3590              	.LBB221:
 3591              	.LBB126:
 364:../uvc.c      **** 
 3592              		.loc 1 364 0
 3593 1d04 0900A0E1 		mov	r0, r9
 359:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3594              		.loc 1 359 0
 3595 1d08 0020A0E3 		mov	r2, #0
 364:../uvc.c      **** 
 3596              		.loc 1 364 0
 3597 1d0c 30101FE5 		ldr	r1, .L438+96
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3598              		.loc 1 320 0
 3599 1d10 FF90A0E3 		mov	r9, #255
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3600              		.loc 1 358 0
 3601 1d14 9830CAE5 		strb	r3, [r10, #152]
 364:../uvc.c      **** 
 3602              		.loc 1 364 0
 3603 1d18 28308DE5 		str	r3, [sp, #40]
 359:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3604              		.loc 1 359 0
 3605 1d1c 9920CAE5 		strb	r2, [r10, #153]
 3606              	.LVL394:
 364:../uvc.c      **** 
 3607              		.loc 1 364 0
 3608 1d20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3609              	.LVL395:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3610              		.loc 1 320 0
 3611 1d24 09C0A0E1 		mov	ip, r9
 3612 1d28 28309DE5 		ldr	r3, [sp, #40]
 3613 1d2c 19FDFFEA 		b	.L285
 3614              	.LVL396:
 3615              	.L187:
 3616              	.LBE126:
 3617              	.LBE221:
 3618              	.LBB222:
 3619              	.LBB167:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3620              		.loc 1 348 0
 3621 1d30 2E20DAE5 		ldrb	r2, [r10, #46]	@ zero_extendqisi2
 3622 1d34 000052E3 		cmp	r2, #0
 3623 1d38 1201000A 		beq	.L429
 3624              	.LVL397:
 3625              	.L195:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3626              		.loc 1 358 0
 3627 1d3c 3D30D7E5 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 3628 1d40 EFFFFFEA 		b	.L404
 3629              	.LVL398:
 3630              	.L239:
 3631              	.LBE167:
 3632              	.LBE222:
 3633              	.LBB223:
 3634              	.LBB149:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3635              		.loc 1 348 0
 3636 1d44 3320DAE5 		ldrb	r2, [r10, #51]	@ zero_extendqisi2
 3637 1d48 000052E3 		cmp	r2, #0
 3638 1d4c 1C01000A 		beq	.L430
 3639              	.LVL399:
 3640              	.L247:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3641              		.loc 1 358 0
 3642 1d50 B530D7E5 		ldrb	r3, [r7, #181]	@ zero_extendqisi2
 3643 1d54 EAFFFFEA 		b	.L404
 3644              	.LVL400:
 3645              	.L226:
 3646              	.LBE149:
 3647              	.LBE223:
 3648              	.LBB224:
 3649              	.LBB195:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3650              		.loc 1 348 0
 3651 1d58 3220DAE5 		ldrb	r2, [r10, #50]	@ zero_extendqisi2
 3652 1d5c 000052E3 		cmp	r2, #0
 3653 1d60 F800000A 		beq	.L431
 3654              	.LVL401:
 3655              	.L234:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3656              		.loc 1 358 0
 3657 1d64 9D30D7E5 		ldrb	r3, [r7, #157]	@ zero_extendqisi2
 3658 1d68 E5FFFFEA 		b	.L404
 3659              	.LVL402:
 3660              	.L256:
 3661              	.LBE195:
 3662              	.LBE224:
 3663              	.LBB225:
 3664              	.LBB176:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3665              		.loc 1 388 0
 3666 1d6c 84201FE5 		ldr	r2, .L438+108
 3667 1d70 DF10D2E5 		ldrb	r1, [r2, #223]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3668              		.loc 1 389 0
 3669 1d74 E020D2E5 		ldrb	r2, [r2, #224]	@ zero_extendqisi2
 3670              	.LVL403:
 3671              	.L403:
 3672              	.LBE176:
 3673              	.LBE225:
 3674              	.LBB226:
 3675              	.LBB127:
 390:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3676              		.loc 1 390 0
 3677 1d78 0030A0E3 		mov	r3, #0
 393:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3678              		.loc 1 393 0
 3679 1d7c 0900A0E1 		mov	r0, r9
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3680              		.loc 1 388 0
 3681 1d80 9810CAE5 		strb	r1, [r10, #152]
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3682              		.loc 1 320 0
 3683 1d84 FF90A0E3 		mov	r9, #255
 393:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3684              		.loc 1 393 0
 3685 1d88 AC101FE5 		ldr	r1, .L438+96
 390:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3686              		.loc 1 390 0
 3687 1d8c 9A30CAE5 		strb	r3, [r10, #154]
 391:../uvc.c      **** 		 	 }
 3688              		.loc 1 391 0
 3689 1d90 9B30CAE5 		strb	r3, [r10, #155]
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3690              		.loc 1 389 0
 3691 1d94 9920CAE5 		strb	r2, [r10, #153]
 393:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3692              		.loc 1 393 0
 3693 1d98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3694              	.LVL404:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3695              		.loc 1 320 0
 3696 1d9c 09C0A0E1 		mov	ip, r9
 394:../uvc.c      **** 			  break;
 3697              		.loc 1 394 0
 3698 1da0 9830DAE5 		ldrb	r3, [r10, #152]	@ zero_extendqisi2
 3699              	.LVL405:
 3700 1da4 FBFCFFEA 		b	.L285
 3701              	.LVL406:
 3702              	.L178:
 3703              	.LBE127:
 3704              	.LBE226:
 3705              	.LBB227:
 3706              	.LBB114:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3707              		.loc 1 388 0
 3708 1da8 7712D7E5 		ldrb	r1, [r7, #631]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3709              		.loc 1 389 0
 3710 1dac 7822D7E5 		ldrb	r2, [r7, #632]	@ zero_extendqisi2
 3711 1db0 F0FFFFEA 		b	.L403
 3712              	.LVL407:
 3713              	.L161:
 3714              	.LBE114:
 3715              	.LBE227:
 3716              	.LBB228:
 3717              	.LBB204:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3718              		.loc 1 348 0
 3719 1db4 2C20DAE5 		ldrb	r2, [r10, #44]	@ zero_extendqisi2
 3720 1db8 000052E3 		cmp	r2, #0
 3721 1dbc 0701000A 		beq	.L432
 3722              	.LVL408:
 3723              	.L169:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3724              		.loc 1 358 0
 3725 1dc0 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3726 1dc4 CEFFFFEA 		b	.L404
 3727              	.LVL409:
 3728              	.L174:
 3729              	.LBE204:
 3730              	.LBE228:
 3731              	.LBB229:
 3732              	.LBB115:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3733              		.loc 1 348 0
 3734 1dc8 4620DAE5 		ldrb	r2, [r10, #70]	@ zero_extendqisi2
 3735 1dcc 000052E3 		cmp	r2, #0
 3736 1dd0 CE00000A 		beq	.L433
 3737              	.LVL410:
 3738              	.L182:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3739              		.loc 1 358 0
 3740 1dd4 7D32D7E5 		ldrb	r3, [r7, #637]	@ zero_extendqisi2
 3741 1dd8 C9FFFFEA 		b	.L404
 3742              	.LVL411:
 3743              	.L165:
 3744              	.LBE115:
 3745              	.LBE229:
 3746              	.LBB230:
 3747              	.LBB205:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3748              		.loc 1 388 0
 3749 1ddc F4201FE5 		ldr	r2, .L438+108
 3750 1de0 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3751              		.loc 1 389 0
 3752 1de4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
 3753 1de8 E2FFFFEA 		b	.L403
 3754              	.LVL412:
 3755              	.L204:
 3756              	.LBE205:
 3757              	.LBE230:
 3758              	.LBB231:
 3759              	.LBB139:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3760              		.loc 1 388 0
 3761 1dec 6710D7E5 		ldrb	r1, [r7, #103]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3762              		.loc 1 389 0
 3763 1df0 6820D7E5 		ldrb	r2, [r7, #104]	@ zero_extendqisi2
 3764 1df4 DFFFFFEA 		b	.L403
 3765              	.LVL413:
 3766              	.L243:
 3767              	.LBE139:
 3768              	.LBE231:
 3769              	.LBB232:
 3770              	.LBB150:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3771              		.loc 1 388 0
 3772 1df8 AF10D7E5 		ldrb	r1, [r7, #175]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3773              		.loc 1 389 0
 3774 1dfc B020D7E5 		ldrb	r2, [r7, #176]	@ zero_extendqisi2
 3775 1e00 DCFFFFEA 		b	.L403
 3776              	.LVL414:
 3777              	.L278:
 3778              	.LBE150:
 3779              	.LBE232:
 3780              	.LBB233:
 3781              	.LBB128:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3782              		.loc 1 348 0
 3783 1e04 3A20DAE5 		ldrb	r2, [r10, #58]	@ zero_extendqisi2
 3784 1e08 000052E3 		cmp	r2, #0
 3785 1e0c E500000A 		beq	.L434
 3786              	.LVL415:
 3787              	.L286:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3788              		.loc 1 358 0
 3789 1e10 5D31D7E5 		ldrb	r3, [r7, #349]	@ zero_extendqisi2
 3790 1e14 BAFFFFEA 		b	.L404
 3791              	.LVL416:
 3792              	.L265:
 3793              	.LBE128:
 3794              	.LBE233:
 3795              	.LBB234:
 3796              	.LBB159:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3797              		.loc 1 348 0
 3798 1e18 3720DAE5 		ldrb	r2, [r10, #55]	@ zero_extendqisi2
 3799 1e1c 000052E3 		cmp	r2, #0
 3800 1e20 AB00000A 		beq	.L435
 3801              	.LVL417:
 3802              	.L273:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3803              		.loc 1 358 0
 3804 1e24 1531D7E5 		ldrb	r3, [r7, #277]	@ zero_extendqisi2
 3805 1e28 B5FFFFEA 		b	.L404
 3806              	.LVL418:
 3807              	.L269:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3808              		.loc 1 388 0
 3809 1e2c 0F11D7E5 		ldrb	r1, [r7, #271]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3810              		.loc 1 389 0
 3811 1e30 1021D7E5 		ldrb	r2, [r7, #272]	@ zero_extendqisi2
 3812 1e34 CFFFFFEA 		b	.L403
 3813              	.LVL419:
 3814              	.L200:
 3815              	.LBE159:
 3816              	.LBE234:
 3817              	.LBB235:
 3818              	.LBB140:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3819              		.loc 1 348 0
 3820 1e38 3020DAE5 		ldrb	r2, [r10, #48]	@ zero_extendqisi2
 3821 1e3c 000052E3 		cmp	r2, #0
 3822 1e40 B900000A 		beq	.L436
 3823              	.LVL420:
 3824              	.L208:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3825              		.loc 1 358 0
 3826 1e44 6D30D7E5 		ldrb	r3, [r7, #109]	@ zero_extendqisi2
 3827 1e48 ADFFFFEA 		b	.L404
 3828              	.LVL421:
 3829              	.L252:
 3830              	.LBE140:
 3831              	.LBE235:
 3832              	.LBB236:
 3833              	.LBB177:
 348:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3834              		.loc 1 348 0
 3835 1e4c 3520DAE5 		ldrb	r2, [r10, #53]	@ zero_extendqisi2
 3836 1e50 000052E3 		cmp	r2, #0
 3837 1e54 C300000A 		beq	.L437
 3838              	.LVL422:
 3839              	.L260:
 358:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3840              		.loc 1 358 0
 3841 1e58 E530D7E5 		ldrb	r3, [r7, #229]	@ zero_extendqisi2
 3842 1e5c A8FFFFEA 		b	.L404
 3843              	.LVL423:
 3844              	.L217:
 3845              	.LBE177:
 3846              	.LBE236:
 3847              	.LBB237:
 3848              	.LBB186:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3849              		.loc 1 388 0
 3850 1e60 78211FE5 		ldr	r2, .L438+108
 3851 1e64 7F10D2E5 		ldrb	r1, [r2, #127]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3852              		.loc 1 389 0
 3853 1e68 8020D2E5 		ldrb	r2, [r2, #128]	@ zero_extendqisi2
 3854 1e6c C1FFFFEA 		b	.L403
 3855              	.LVL424:
 3856              	.L230:
 3857              	.LBE186:
 3858              	.LBE237:
 3859              	.LBB238:
 3860              	.LBB196:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3861              		.loc 1 388 0
 3862 1e70 88211FE5 		ldr	r2, .L438+108
 3863 1e74 9710D2E5 		ldrb	r1, [r2, #151]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3864              		.loc 1 389 0
 3865 1e78 9820D2E5 		ldrb	r2, [r2, #152]	@ zero_extendqisi2
 3866 1e7c BDFFFFEA 		b	.L403
 3867              	.LVL425:
 3868              	.L282:
 3869              	.LBE196:
 3870              	.LBE238:
 3871              	.LBB239:
 3872              	.LBB129:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3873              		.loc 1 388 0
 3874 1e80 5711D7E5 		ldrb	r1, [r7, #343]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3875              		.loc 1 389 0
 3876 1e84 5821D7E5 		ldrb	r2, [r7, #344]	@ zero_extendqisi2
 3877 1e88 BAFFFFEA 		b	.L403
 3878              	.LVL426:
 3879              	.L191:
 3880              	.LBE129:
 3881              	.LBE239:
 3882              	.LBB240:
 3883              	.LBB168:
 388:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 3884              		.loc 1 388 0
 3885 1e8c A4211FE5 		ldr	r2, .L438+108
 3886 1e90 3710D2E5 		ldrb	r1, [r2, #55]	@ zero_extendqisi2
 389:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 3887              		.loc 1 389 0
 3888 1e94 3820D2E5 		ldrb	r2, [r2, #56]	@ zero_extendqisi2
 3889 1e98 B6FFFFEA 		b	.L403
 3890              	.LVL427:
 3891              	.L318:
 3892              	.LBE168:
 3893              	.LBE240:
 3894              	.LBE288:
 3895              	.LBE303:
 3896              	.LBB304:
 3897              	.LBB107:
2063:../uvc.c      ****                          		CyU3PThreadSleep(500);
 3898              		.loc 1 2063 0
 3899 1e9c 3010A0E3 		mov	r1, #48
 3900 1ea0 0020A0E3 		mov	r2, #0
 3901 1ea4 5230A0E3 		mov	r3, #82
 3902 1ea8 0B00A0E3 		mov	r0, #11
 3903              	.LVL428:
 3904 1eac FEFFFFEB 		bl	SensorSetIrisControl
 3905              	.LVL429:
2064:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x0, 0x0b)
 3906              		.loc 1 2064 0
 3907 1eb0 7D0FA0E3 		mov	r0, #500
 3908 1eb4 FEFFFFEB 		bl	_tx_thread_sleep
 3909              	.LVL430:
2065:../uvc.c      ****                          		break;
 3910              		.loc 1 2065 0
 3911 1eb8 D4111FE5 		ldr	r1, .L438+104
 3912 1ebc 0020A0E3 		mov	r2, #0
 3913 1ec0 0B30A0E3 		mov	r3, #11
 3914 1ec4 0400A0E3 		mov	r0, #4
 3915 1ec8 FEFFFFEB 		bl	CyU3PDebugPrint
 3916              	.LVL431:
 3917 1ecc C4FDFFEA 		b	.L316
 3918              	.L287:
 3919              	.LBE107:
 3920              	.LBE304:
 3921              	.LBB305:
 3922              	.LBB289:
 3923              	.LBB241:
 3924              	.LBB130:
 438:../uvc.c      **** 			   }
 3925              		.loc 1 438 0
 3926 1ed0 0400A0E3 		mov	r0, #4
 3927 1ed4 FC111FE5 		ldr	r1, .L438+92
 3928 1ed8 FEFFFFEB 		bl	CyU3PDebugPrint
 3929              	.LVL432:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3930              		.loc 1 320 0
 3931 1edc FF30A0E3 		mov	r3, #255
 3932 1ee0 0390A0E1 		mov	r9, r3
 3933 1ee4 03C0A0E1 		mov	ip, r3
 3934 1ee8 AAFCFFEA 		b	.L285
 3935              	.LVL433:
 3936              	.L166:
 3937              	.LBE130:
 3938              	.LBE241:
 3939              	.LBB242:
 3940              	.LBB206:
 398:../uvc.c      **** 		 	 }
 3941              		.loc 1 398 0
 3942 1eec 0930D7E5 		ldrb	r3, [r7, #9]	@ zero_extendqisi2
 3943              	.LVL434:
 3944              	.L402:
 3945              	.LBE206:
 3946              	.LBE242:
 3947              	.LBB243:
 3948              	.LBB131:
 400:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3949              		.loc 1 400 0
 3950 1ef0 0100A0E3 		mov	r0, #1
 3951 1ef4 18121FE5 		ldr	r1, .L438+96
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3952              		.loc 1 320 0
 3953 1ef8 FF90A0E3 		mov	r9, #255
 398:../uvc.c      **** 		 	 }
 3954              		.loc 1 398 0
 3955 1efc 9830CAE5 		strb	r3, [r10, #152]
 400:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 3956              		.loc 1 400 0
 3957 1f00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3958              	.LVL435:
 320:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 3959              		.loc 1 320 0
 3960 1f04 09C0A0E1 		mov	ip, r9
 401:../uvc.c      **** 			  Len = 1;
 3961              		.loc 1 401 0
 3962 1f08 9830DAE5 		ldrb	r3, [r10, #152]	@ zero_extendqisi2
 3963              	.LVL436:
 3964 1f0c A1FCFFEA 		b	.L285
 3965              	.LVL437:
 3966              	.L231:
 3967              	.LBE131:
 3968              	.LBE243:
 3969              	.LBB244:
 3970              	.LBB197:
 398:../uvc.c      **** 		 	 }
 3971              		.loc 1 398 0
 3972 1f10 9930D7E5 		ldrb	r3, [r7, #153]	@ zero_extendqisi2
 3973 1f14 F5FFFFEA 		b	.L402
 3974              	.LVL438:
 3975              	.L253:
 3976              	.LBE197:
 3977              	.LBE244:
 3978              	.LBB245:
 3979              	.LBB178:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 3980              		.loc 1 372 0
 3981 1f18 30321FE5 		ldr	r3, .L438+108
 3982 1f1c DB20D3E5 		ldrb	r2, [r3, #219]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 3983              		.loc 1 373 0
 3984 1f20 DC30D3E5 		ldrb	r3, [r3, #220]	@ zero_extendqisi2
 3985 1f24 E1FBFFEA 		b	.L397
 3986              	.LVL439:
 3987              	.L240:
 3988              	.LBE178:
 3989              	.LBE245:
 3990              	.LBB246:
 3991              	.LBB151:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 3992              		.loc 1 372 0
 3993 1f28 AB20D7E5 		ldrb	r2, [r7, #171]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 3994              		.loc 1 373 0
 3995 1f2c AC30D7E5 		ldrb	r3, [r7, #172]	@ zero_extendqisi2
 3996 1f30 DEFBFFEA 		b	.L397
 3997              	.LVL440:
 3998              	.L279:
 3999              	.LBE151:
 4000              	.LBE246:
 4001              	.LBB247:
 4002              	.LBB132:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4003              		.loc 1 372 0
 4004 1f34 5321D7E5 		ldrb	r2, [r7, #339]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4005              		.loc 1 373 0
 4006 1f38 5431D7E5 		ldrb	r3, [r7, #340]	@ zero_extendqisi2
 4007 1f3c DBFBFFEA 		b	.L397
 4008              	.LVL441:
 4009              	.L266:
 4010              	.LBE132:
 4011              	.LBE247:
 4012              	.LBB248:
 4013              	.LBB160:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4014              		.loc 1 372 0
 4015 1f40 0B21D7E5 		ldrb	r2, [r7, #267]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4016              		.loc 1 373 0
 4017 1f44 0C31D7E5 		ldrb	r3, [r7, #268]	@ zero_extendqisi2
 4018 1f48 D8FBFFEA 		b	.L397
 4019              	.LVL442:
 4020              	.L201:
 4021              	.LBE160:
 4022              	.LBE248:
 4023              	.LBB249:
 4024              	.LBB141:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4025              		.loc 1 372 0
 4026 1f4c 6320D7E5 		ldrb	r2, [r7, #99]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4027              		.loc 1 373 0
 4028 1f50 6430D7E5 		ldrb	r3, [r7, #100]	@ zero_extendqisi2
 4029 1f54 D5FBFFEA 		b	.L397
 4030              	.LVL443:
 4031              	.L162:
 4032              	.LBE141:
 4033              	.LBE249:
 4034              	.LBB250:
 4035              	.LBB207:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4036              		.loc 1 372 0
 4037 1f58 70321FE5 		ldr	r3, .L438+108
 4038 1f5c 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4039              		.loc 1 373 0
 4040 1f60 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 4041 1f64 D1FBFFEA 		b	.L397
 4042              	.LVL444:
 4043              	.L175:
 4044              	.LBE207:
 4045              	.LBE250:
 4046              	.LBB251:
 4047              	.LBB116:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4048              		.loc 1 372 0
 4049 1f68 7322D7E5 		ldrb	r2, [r7, #627]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4050              		.loc 1 373 0
 4051 1f6c 7432D7E5 		ldrb	r3, [r7, #628]	@ zero_extendqisi2
 4052 1f70 CEFBFFEA 		b	.L397
 4053              	.LVL445:
 4054              	.L270:
 4055              	.LBE116:
 4056              	.LBE251:
 4057              	.LBB252:
 4058              	.LBB161:
 398:../uvc.c      **** 		 	 }
 4059              		.loc 1 398 0
 4060 1f74 1131D7E5 		ldrb	r3, [r7, #273]	@ zero_extendqisi2
 4061 1f78 DCFFFFEA 		b	.L402
 4062              	.LVL446:
 4063              	.L192:
 4064              	.LBE161:
 4065              	.LBE252:
 4066              	.LBB253:
 4067              	.LBB169:
 4068 1f7c 94121FE5 		ldr	r1, .L438+108
 4069 1f80 3930D1E5 		ldrb	r3, [r1, #57]	@ zero_extendqisi2
 4070 1f84 D9FFFFEA 		b	.L402
 4071              	.LVL447:
 4072              	.L214:
 4073              	.LBE169:
 4074              	.LBE253:
 4075              	.LBB254:
 4076              	.LBB187:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4077              		.loc 1 372 0
 4078 1f88 A0321FE5 		ldr	r3, .L438+108
 4079 1f8c 7B20D3E5 		ldrb	r2, [r3, #123]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4080              		.loc 1 373 0
 4081 1f90 7C30D3E5 		ldrb	r3, [r3, #124]	@ zero_extendqisi2
 4082 1f94 C5FBFFEA 		b	.L397
 4083              	.LVL448:
 4084              	.L188:
 4085              	.LBE187:
 4086              	.LBE254:
 4087              	.LBB255:
 4088              	.LBB170:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4089              		.loc 1 372 0
 4090 1f98 B0321FE5 		ldr	r3, .L438+108
 4091 1f9c 3320D3E5 		ldrb	r2, [r3, #51]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4092              		.loc 1 373 0
 4093 1fa0 3430D3E5 		ldrb	r3, [r3, #52]	@ zero_extendqisi2
 4094 1fa4 C1FBFFEA 		b	.L397
 4095              	.LVL449:
 4096              	.L227:
 4097              	.LBE170:
 4098              	.LBE255:
 4099              	.LBB256:
 4100              	.LBB198:
 372:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 4101              		.loc 1 372 0
 4102 1fa8 C0321FE5 		ldr	r3, .L438+108
 4103 1fac 9320D3E5 		ldrb	r2, [r3, #147]	@ zero_extendqisi2
 373:../uvc.c      **** 			 }
 4104              		.loc 1 373 0
 4105 1fb0 9430D3E5 		ldrb	r3, [r3, #148]	@ zero_extendqisi2
 4106 1fb4 BDFBFFEA 		b	.L397
 4107              	.LVL450:
 4108              	.L179:
 4109              	.LBE198:
 4110              	.LBE256:
 4111              	.LBB257:
 4112              	.LBB117:
 398:../uvc.c      **** 		 	 }
 4113              		.loc 1 398 0
 4114 1fb8 7932D7E5 		ldrb	r3, [r7, #633]	@ zero_extendqisi2
 4115 1fbc CBFFFFEA 		b	.L402
 4116              	.LVL451:
 4117              	.L205:
 4118              	.LBE117:
 4119              	.LBE257:
 4120              	.LBB258:
 4121              	.LBB142:
 4122 1fc0 6930D7E5 		ldrb	r3, [r7, #105]	@ zero_extendqisi2
 4123 1fc4 C9FFFFEA 		b	.L402
 4124              	.LVL452:
 4125              	.L244:
 4126              	.LBE142:
 4127              	.LBE258:
 4128              	.LBB259:
 4129              	.LBB152:
 4130 1fc8 B130D7E5 		ldrb	r3, [r7, #177]	@ zero_extendqisi2
 4131 1fcc C7FFFFEA 		b	.L402
 4132              	.LVL453:
 4133              	.L224:
 4134              	.LBE152:
 4135              	.LBE259:
 4136              	.LBB260:
 4137              	.LBB199:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4138              		.loc 1 380 0
 4139 1fd0 E8121FE5 		ldr	r1, .L438+108
 4140 1fd4 9520D1E5 		ldrb	r2, [r1, #149]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4141              		.loc 1 381 0
 4142 1fd8 9630D1E5 		ldrb	r3, [r1, #150]	@ zero_extendqisi2
 4143 1fdc B3FBFFEA 		b	.L397
 4144              	.LVL454:
 4145              	.L237:
 4146              	.LBE199:
 4147              	.LBE260:
 4148              	.LBB261:
 4149              	.LBB153:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4150              		.loc 1 380 0
 4151 1fe0 F8121FE5 		ldr	r1, .L438+108
 4152 1fe4 AD20D1E5 		ldrb	r2, [r1, #173]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4153              		.loc 1 381 0
 4154 1fe8 AE30D1E5 		ldrb	r3, [r1, #174]	@ zero_extendqisi2
 4155 1fec AFFBFFEA 		b	.L397
 4156              	.LVL455:
 4157              	.L172:
 4158              	.LBE153:
 4159              	.LBE261:
 4160              	.LBB262:
 4161              	.LBB118:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4162              		.loc 1 380 0
 4163 1ff0 08131FE5 		ldr	r1, .L438+108
 4164 1ff4 7522D1E5 		ldrb	r2, [r1, #629]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4165              		.loc 1 381 0
 4166 1ff8 7632D1E5 		ldrb	r3, [r1, #630]	@ zero_extendqisi2
 4167 1ffc ABFBFFEA 		b	.L397
 4168              	.LVL456:
 4169              	.L218:
 4170              	.LBE118:
 4171              	.LBE262:
 4172              	.LBB263:
 4173              	.LBB188:
 398:../uvc.c      **** 		 	 }
 4174              		.loc 1 398 0
 4175 2000 18131FE5 		ldr	r1, .L438+108
 4176 2004 8130D1E5 		ldrb	r3, [r1, #129]	@ zero_extendqisi2
 4177 2008 B8FFFFEA 		b	.L402
 4178              	.LVL457:
 4179              	.L283:
 4180              	.LBE188:
 4181              	.LBE263:
 4182              	.LBB264:
 4183              	.LBB133:
 4184 200c 5931D7E5 		ldrb	r3, [r7, #345]	@ zero_extendqisi2
 4185 2010 B6FFFFEA 		b	.L402
 4186              	.LVL458:
 4187              	.L257:
 4188              	.LBE133:
 4189              	.LBE264:
 4190              	.LBB265:
 4191              	.LBB179:
 4192 2014 2C131FE5 		ldr	r1, .L438+108
 4193 2018 E130D1E5 		ldrb	r3, [r1, #225]	@ zero_extendqisi2
 4194 201c B3FFFFEA 		b	.L402
 4195              	.LVL459:
 4196              	.L159:
 4197              	.LBE179:
 4198              	.LBE265:
 4199              	.LBB266:
 4200              	.LBB208:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4201              		.loc 1 380 0
 4202 2020 38131FE5 		ldr	r1, .L438+108
 4203 2024 0520D1E5 		ldrb	r2, [r1, #5]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4204              		.loc 1 381 0
 4205 2028 0630D1E5 		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 4206 202c 9FFBFFEA 		b	.L397
 4207              	.LVL460:
 4208              	.L276:
 4209              	.LBE208:
 4210              	.LBE266:
 4211              	.LBB267:
 4212              	.LBB134:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4213              		.loc 1 380 0
 4214 2030 48131FE5 		ldr	r1, .L438+108
 4215 2034 5521D1E5 		ldrb	r2, [r1, #341]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4216              		.loc 1 381 0
 4217 2038 5631D1E5 		ldrb	r3, [r1, #342]	@ zero_extendqisi2
 4218 203c 9BFBFFEA 		b	.L397
 4219              	.LVL461:
 4220              	.L263:
 4221              	.LBE134:
 4222              	.LBE267:
 4223              	.LBB268:
 4224              	.LBB162:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4225              		.loc 1 380 0
 4226 2040 58131FE5 		ldr	r1, .L438+108
 4227 2044 0D21D1E5 		ldrb	r2, [r1, #269]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4228              		.loc 1 381 0
 4229 2048 0E31D1E5 		ldrb	r3, [r1, #270]	@ zero_extendqisi2
 4230 204c 97FBFFEA 		b	.L397
 4231              	.LVL462:
 4232              	.L185:
 4233              	.LBE162:
 4234              	.LBE268:
 4235              	.LBB269:
 4236              	.LBB171:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4237              		.loc 1 380 0
 4238 2050 68131FE5 		ldr	r1, .L438+108
 4239 2054 3520D1E5 		ldrb	r2, [r1, #53]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4240              		.loc 1 381 0
 4241 2058 3630D1E5 		ldrb	r3, [r1, #54]	@ zero_extendqisi2
 4242 205c 93FBFFEA 		b	.L397
 4243              	.LVL463:
 4244              	.L250:
 4245              	.LBE171:
 4246              	.LBE269:
 4247              	.LBB270:
 4248              	.LBB180:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4249              		.loc 1 380 0
 4250 2060 78131FE5 		ldr	r1, .L438+108
 4251 2064 DD20D1E5 		ldrb	r2, [r1, #221]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4252              		.loc 1 381 0
 4253 2068 DE30D1E5 		ldrb	r3, [r1, #222]	@ zero_extendqisi2
 4254 206c 8FFBFFEA 		b	.L397
 4255              	.LVL464:
 4256              	.L211:
 4257              	.LBE180:
 4258              	.LBE270:
 4259              	.LBB271:
 4260              	.LBB189:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4261              		.loc 1 380 0
 4262 2070 88131FE5 		ldr	r1, .L438+108
 4263 2074 7D20D1E5 		ldrb	r2, [r1, #125]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4264              		.loc 1 381 0
 4265 2078 7E30D1E5 		ldrb	r3, [r1, #126]	@ zero_extendqisi2
 4266 207c 8BFBFFEA 		b	.L397
 4267              	.LVL465:
 4268              	.L198:
 4269              	.LBE189:
 4270              	.LBE271:
 4271              	.LBB272:
 4272              	.LBB143:
 380:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 4273              		.loc 1 380 0
 4274 2080 98131FE5 		ldr	r1, .L438+108
 4275 2084 6520D1E5 		ldrb	r2, [r1, #101]	@ zero_extendqisi2
 381:../uvc.c      **** 			 }
 4276              		.loc 1 381 0
 4277 2088 6630D1E5 		ldrb	r3, [r1, #102]	@ zero_extendqisi2
 4278 208c 87FBFFEA 		b	.L397
 4279              	.LVL466:
 4280              	.L427:
 4281              	.LBE143:
 4282              	.LBE272:
 4283              	.LBE289:
 4284              	.LBE305:
 4285              	.LBB306:
 4286              	.LBB108:
2272:../uvc.c      ****                             }
 4287              		.loc 1 2272 0
 4288 2090 B0131FE5 		ldr	r1, .L438+100
 4289 2094 0400A0E3 		mov	r0, #4
 4290              	.LVL467:
 4291 2098 FEFFFFEB 		bl	CyU3PDebugPrint
 4292              	.LVL468:
 4293 209c 38FDFFEA 		b	.L341
 4294              	.LVL469:
 4295              	.L317:
2058:../uvc.c      ****                          		CyU3PThreadSleep(500);
 4296              		.loc 1 2058 0
 4297 20a0 0820A0E1 		mov	r2, r8
 4298 20a4 3010A0E3 		mov	r1, #48
 4299 20a8 5230A0E3 		mov	r3, #82
 4300 20ac 0B00A0E3 		mov	r0, #11
 4301              	.LVL470:
 4302 20b0 FEFFFFEB 		bl	SensorSetIrisControl
 4303              	.LVL471:
2059:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", 0x1, 0x0b)
 4304              		.loc 1 2059 0
 4305 20b4 7D0FA0E3 		mov	r0, #500
 4306 20b8 FEFFFFEB 		bl	_tx_thread_sleep
 4307              	.LVL472:
2060:../uvc.c      ****                          		break;
 4308              		.loc 1 2060 0
 4309 20bc 0820A0E1 		mov	r2, r8
 4310 20c0 DC131FE5 		ldr	r1, .L438+104
 4311 20c4 0B30A0E3 		mov	r3, #11
 4312 20c8 0400A0E3 		mov	r0, #4
 4313 20cc FEFFFFEB 		bl	CyU3PDebugPrint
 4314              	.LVL473:
 4315 20d0 43FDFFEA 		b	.L316
 4316              	.LVL474:
 4317              	.L435:
 4318              	.LBE108:
 4319              	.LBE306:
 4320              	.LBB307:
 4321              	.LBB290:
 4322              	.LBB273:
 4323              	.LBB163:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4324              		.loc 1 352 0
 4325 20d4 0310A0E1 		mov	r1, r3
 4326 20d8 34009DE5 		ldr	r0, [sp, #52]
 4327 20dc FEFFFFEB 		bl	SensorGetControl
 4328              	.LVL475:
 355:../uvc.c      **** 		 	 		 }
 4329              		.loc 1 355 0
 4330 20e0 0130A0E3 		mov	r3, #1
 4331 20e4 3730C4E5 		strb	r3, [r4, #55]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4332              		.loc 1 353 0
 4333 20e8 1501C7E5 		strb	r0, [r7, #277]
 4334 20ec 4CFFFFEA 		b	.L273
 4335              	.LVL476:
 4336              	.L428:
 4337              	.LBE163:
 4338              	.LBE273:
 4339              	.LBB274:
 4340              	.LBB190:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4341              		.loc 1 352 0
 4342 20f0 0310A0E1 		mov	r1, r3
 4343 20f4 34009DE5 		ldr	r0, [sp, #52]
 4344 20f8 FEFFFFEB 		bl	SensorGetControl
 4345              	.LVL477:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4346              		.loc 1 353 0
 4347 20fc 14141FE5 		ldr	r1, .L438+108
 355:../uvc.c      **** 		 	 		 }
 4348              		.loc 1 355 0
 4349 2100 0130A0E3 		mov	r3, #1
 4350 2104 3130C4E5 		strb	r3, [r4, #49]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4351              		.loc 1 353 0
 4352 2108 8500C1E5 		strb	r0, [r1, #133]
 4353 210c FBFEFFEA 		b	.L221
 4354              	.LVL478:
 4355              	.L433:
 4356              	.LBE190:
 4357              	.LBE274:
 4358              	.LBB275:
 4359              	.LBB119:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4360              		.loc 1 352 0
 4361 2110 0310A0E1 		mov	r1, r3
 4362 2114 34009DE5 		ldr	r0, [sp, #52]
 4363 2118 FEFFFFEB 		bl	SensorGetControl
 4364              	.LVL479:
 355:../uvc.c      **** 		 	 		 }
 4365              		.loc 1 355 0
 4366 211c 0130A0E3 		mov	r3, #1
 4367 2120 4630CAE5 		strb	r3, [r10, #70]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4368              		.loc 1 353 0
 4369 2124 7D02C7E5 		strb	r0, [r7, #637]
 4370 2128 29FFFFEA 		b	.L182
 4371              	.LVL480:
 4372              	.L436:
 4373              	.LBE119:
 4374              	.LBE275:
 4375              	.LBB276:
 4376              	.LBB144:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4377              		.loc 1 352 0
 4378 212c 0310A0E1 		mov	r1, r3
 4379 2130 34009DE5 		ldr	r0, [sp, #52]
 4380 2134 FEFFFFEB 		bl	SensorGetControl
 4381              	.LVL481:
 355:../uvc.c      **** 		 	 		 }
 4382              		.loc 1 355 0
 4383 2138 0130A0E3 		mov	r3, #1
 4384 213c 3030CAE5 		strb	r3, [r10, #48]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4385              		.loc 1 353 0
 4386 2140 6D00C7E5 		strb	r0, [r7, #109]
 4387 2144 3EFFFFEA 		b	.L208
 4388              	.LVL482:
 4389              	.L431:
 4390              	.LBE144:
 4391              	.LBE276:
 4392              	.LBB277:
 4393              	.LBB200:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4394              		.loc 1 352 0
 4395 2148 0310A0E1 		mov	r1, r3
 4396 214c 34009DE5 		ldr	r0, [sp, #52]
 4397 2150 FEFFFFEB 		bl	SensorGetControl
 4398              	.LVL483:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4399              		.loc 1 353 0
 4400 2154 6C141FE5 		ldr	r1, .L438+108
 355:../uvc.c      **** 		 	 		 }
 4401              		.loc 1 355 0
 4402 2158 0130A0E3 		mov	r3, #1
 4403 215c 3230C4E5 		strb	r3, [r4, #50]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4404              		.loc 1 353 0
 4405 2160 9D00C1E5 		strb	r0, [r1, #157]
 4406 2164 FEFEFFEA 		b	.L234
 4407              	.LVL484:
 4408              	.L437:
 4409              	.LBE200:
 4410              	.LBE277:
 4411              	.LBB278:
 4412              	.LBB181:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4413              		.loc 1 352 0
 4414 2168 0310A0E1 		mov	r1, r3
 4415 216c 34009DE5 		ldr	r0, [sp, #52]
 4416 2170 FEFFFFEB 		bl	SensorGetControl
 4417              	.LVL485:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4418              		.loc 1 353 0
 4419 2174 8C141FE5 		ldr	r1, .L438+108
 355:../uvc.c      **** 		 	 		 }
 4420              		.loc 1 355 0
 4421 2178 0130A0E3 		mov	r3, #1
 4422 217c 3530C4E5 		strb	r3, [r4, #53]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4423              		.loc 1 353 0
 4424 2180 E500C1E5 		strb	r0, [r1, #229]
 4425 2184 33FFFFEA 		b	.L260
 4426              	.LVL486:
 4427              	.L429:
 4428              	.LBE181:
 4429              	.LBE278:
 4430              	.LBB279:
 4431              	.LBB172:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4432              		.loc 1 352 0
 4433 2188 0310A0E1 		mov	r1, r3
 4434 218c 34009DE5 		ldr	r0, [sp, #52]
 4435 2190 FEFFFFEB 		bl	SensorGetControl
 4436              	.LVL487:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4437              		.loc 1 353 0
 4438 2194 AC141FE5 		ldr	r1, .L438+108
 355:../uvc.c      **** 		 	 		 }
 4439              		.loc 1 355 0
 4440 2198 0130A0E3 		mov	r3, #1
 4441 219c 2E30C4E5 		strb	r3, [r4, #46]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4442              		.loc 1 353 0
 4443 21a0 3D00C1E5 		strb	r0, [r1, #61]
 4444 21a4 E4FEFFEA 		b	.L195
 4445              	.LVL488:
 4446              	.L434:
 4447              	.LBE172:
 4448              	.LBE279:
 4449              	.LBB280:
 4450              	.LBB135:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4451              		.loc 1 352 0
 4452 21a8 0310A0E1 		mov	r1, r3
 4453 21ac 34009DE5 		ldr	r0, [sp, #52]
 4454 21b0 FEFFFFEB 		bl	SensorGetControl
 4455              	.LVL489:
 355:../uvc.c      **** 		 	 		 }
 4456              		.loc 1 355 0
 4457 21b4 0130A0E3 		mov	r3, #1
 4458 21b8 3A30CAE5 		strb	r3, [r10, #58]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4459              		.loc 1 353 0
 4460 21bc 5D01C7E5 		strb	r0, [r7, #349]
 4461 21c0 12FFFFEA 		b	.L286
 4462              	.LVL490:
 4463              	.L430:
 4464              	.LBE135:
 4465              	.LBE280:
 4466              	.LBB281:
 4467              	.LBB154:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4468              		.loc 1 352 0
 4469 21c4 0310A0E1 		mov	r1, r3
 4470 21c8 34009DE5 		ldr	r0, [sp, #52]
 4471 21cc FEFFFFEB 		bl	SensorGetControl
 4472              	.LVL491:
 355:../uvc.c      **** 		 	 		 }
 4473              		.loc 1 355 0
 4474 21d0 0130A0E3 		mov	r3, #1
 4475 21d4 3330CAE5 		strb	r3, [r10, #51]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4476              		.loc 1 353 0
 4477 21d8 B500C7E5 		strb	r0, [r7, #181]
 4478 21dc DBFEFFEA 		b	.L247
 4479              	.LVL492:
 4480              	.L432:
 4481              	.LBE154:
 4482              	.LBE281:
 4483              	.LBB282:
 4484              	.LBB209:
 352:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4485              		.loc 1 352 0
 4486 21e0 0310A0E1 		mov	r1, r3
 4487 21e4 34009DE5 		ldr	r0, [sp, #52]
 4488 21e8 FEFFFFEB 		bl	SensorGetControl
 4489              	.LVL493:
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4490              		.loc 1 353 0
 4491 21ec 04151FE5 		ldr	r1, .L438+108
 355:../uvc.c      **** 		 	 		 }
 4492              		.loc 1 355 0
 4493 21f0 0130A0E3 		mov	r3, #1
 4494 21f4 2C30C4E5 		strb	r3, [r4, #44]
 353:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4495              		.loc 1 353 0
 4496 21f8 0D00C1E5 		strb	r0, [r1, #13]
 4497 21fc EFFEFFEA 		b	.L169
 4498              	.LBE209:
 4499              	.LBE282:
 4500              	.LBE290:
 4501              	.LBE307:
 4502              		.cfi_endproc
 4503              	.LFE21:
 4505              		.align	2
 4506              		.global	CyFxGpifCB
 4508              	CyFxGpifCB:
 4509              	.LFB9:
 974:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 4510              		.loc 1 974 0
 4511              		.cfi_startproc
 4512              		@ args = 0, pretend = 0, frame = 0
 4513              		@ frame_needed = 0, uses_anonymous_args = 0
 975:../uvc.c      ****     {
 4514              		.loc 1 975 0
 4515 2200 010050E3 		cmp	r0, #1
 974:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 4516              		.loc 1 974 0
 4517 2204 10402DE9 		stmfd	sp!, {r4, lr}
 4518              	.LCFI14:
 4519              		.cfi_def_cfa_offset 8
 4520              		.cfi_offset 4, -8
 4521              		.cfi_offset 14, -4
 975:../uvc.c      ****     {
 4522              		.loc 1 975 0
 4523 2208 1080BD18 		ldmnefd	sp!, {r4, pc}
 4524              	.LBB312:
 4525              	.LBB313:
 874:../uvc.c      ****     {
 4526              		.loc 1 874 0
 4527 220c C4309FE5 		ldr	r3, .L458
 4528 2210 B830D3E5 		ldrb	r3, [r3, #184]	@ zero_extendqisi2
 4529 2214 030053E3 		cmp	r3, #3
 4530 2218 1000000A 		beq	.L457
 898:../uvc.c      ****     {
 4531              		.loc 1 898 0
 4532 221c 020053E3 		cmp	r3, #2
 4533 2220 1080BD18 		ldmnefd	sp!, {r4, pc}
 900:../uvc.c      ****         {
 4534              		.loc 1 900 0
 4535 2224 083041E2 		sub	r3, r1, #8
 4536 2228 0A0053E3 		cmp	r3, #10
 4537 222c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4538 2230 200000EA 		b	.L450
 4539              	.L452:
 4540 2234 B0220000 		.word	.L444
 4541 2238 B8220000 		.word	.L450
 4542 223c B8220000 		.word	.L450
 4543 2240 80220000 		.word	.L440
 4544 2244 B8220000 		.word	.L450
 4545 2248 B8220000 		.word	.L450
 4546 224c B8220000 		.word	.L450
 4547 2250 84220000 		.word	.L456
 4548 2254 B8220000 		.word	.L450
 4549 2258 B8220000 		.word	.L450
 4550 225c 80220000 		.word	.L440
 4551              	.L457:
 876:../uvc.c      ****         {
 4552              		.loc 1 876 0
 4553 2260 0B3041E2 		sub	r3, r1, #11
 4554 2264 030053E3 		cmp	r3, #3
 4555 2268 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4556 226c 110000EA 		b	.L450
 4557              	.L445:
 4558 2270 B0220000 		.word	.L444
 4559 2274 84220000 		.word	.L456
 4560 2278 80220000 		.word	.L440
 4561 227c 80220000 		.word	.L440
 4562              	.L440:
 4563 2280 1080BDE8 		ldmfd	sp!, {r4, pc}
 4564              	.L456:
 900:../uvc.c      ****         {
 4565              		.loc 1 900 0
 4566 2284 0110A0E3 		mov	r1, #1
 4567              	.L446:
 957:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 4568              		.loc 1 957 0
 4569 2288 4C009FE5 		ldr	r0, .L458+4
 4570 228c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 958:../uvc.c      ****         {
 4571              		.loc 1 958 0
 4572 2290 004050E2 		subs	r4, r0, #0
 4573 2294 1080BD08 		ldmeqfd	sp!, {r4, pc}
 960:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 4574              		.loc 1 960 0
 4575 2298 0400A0E3 		mov	r0, #4
 4576 229c 3C109FE5 		ldr	r1, .L458+8
 4577 22a0 0420A0E1 		mov	r2, r4
 4578 22a4 FEFFFFEB 		bl	CyU3PDebugPrint
 961:../uvc.c      ****         }
 4579              		.loc 1 961 0
 4580 22a8 0400A0E1 		mov	r0, r4
 4581 22ac FEFFFFEB 		bl	CyFxAppErrorHandler
 4582              	.L444:
 876:../uvc.c      ****         {
 4583              		.loc 1 876 0
 4584 22b0 0010A0E3 		mov	r1, #0
 4585 22b4 F3FFFFEA 		b	.L446
 4586              	.L450:
 946:../uvc.c      ****                 /* Unexpected current state. Return error. */
 4587              		.loc 1 946 0
 4588 22b8 0120A0E1 		mov	r2, r1
 4589 22bc 0100A0E3 		mov	r0, #1
 4590 22c0 1C109FE5 		ldr	r1, .L458+12
 4591 22c4 FEFFFFEB 		bl	CyU3PDebugPrint
 4592              	.LBE313:
 4593              	.LBE312:
 4594              	.LBB314:
 4595              	.LBB315:
 979:../uvc.c      ****     }
 4596              		.loc 1 979 0
 4597 22c8 0400A0E3 		mov	r0, #4
 4598 22cc 14109FE5 		ldr	r1, .L458+16
 4599              	.LBE315:
 4600              	.LBE314:
 981:../uvc.c      **** 
 4601              		.loc 1 981 0
 4602 22d0 1040BDE8 		ldmfd	sp!, {r4, lr}
 4603              	.LBB317:
 4604              	.LBB316:
 979:../uvc.c      ****     }
 4605              		.loc 1 979 0
 4606 22d4 FEFFFFEA 		b	CyU3PDebugPrint
 4607              	.L459:
 4608              		.align	2
 4609              	.L458:
 4610 22d8 00000000 		.word	.LANCHOR0
 4611 22dc 00000000 		.word	glChHandleUVCStream
 4612 22e0 B0040000 		.word	.LC29
 4613 22e4 98040000 		.word	.LC28
 4614 22e8 E0040000 		.word	.LC30
 4615              	.LBE316:
 4616              	.LBE317:
 4617              		.cfi_endproc
 4618              	.LFE9:
 4620              		.align	2
 4621              		.global	CyFxUVCApplnI2CInit
 4623              	CyFxUVCApplnI2CInit:
 4624              	.LFB11:
1037:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
 4625              		.loc 1 1037 0
 4626              		.cfi_startproc
 4627              		@ args = 0, pretend = 0, frame = 16
 4628              		@ frame_needed = 0, uses_anonymous_args = 0
 4629 22ec 10402DE9 		stmfd	sp!, {r4, lr}
 4630              	.LCFI15:
 4631              		.cfi_def_cfa_offset 8
 4632              		.cfi_offset 4, -8
 4633              		.cfi_offset 14, -4
 4634 22f0 10D04DE2 		sub	sp, sp, #16
 4635              	.LCFI16:
 4636              		.cfi_def_cfa_offset 24
1041:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 4637              		.loc 1 1041 0
 4638 22f4 FEFFFFEB 		bl	CyU3PI2cInit
 4639              	.LVL494:
1042:../uvc.c      ****     {
 4640              		.loc 1 1042 0
 4641 22f8 004050E2 		subs	r4, r0, #0
 4642 22fc 0B00001A 		bne	.L463
1049:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 4643              		.loc 1 1049 0
 4644 2300 50209FE5 		ldr	r2, .L465
1051:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 4645              		.loc 1 1051 0
 4646 2304 0030E0E3 		mvn	r3, #0
1054:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 4647              		.loc 1 1054 0
 4648 2308 0410A0E1 		mov	r1, r4
 4649 230c 0D00A0E1 		mov	r0, sp
 4650              	.LVL495:
1049:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 4651              		.loc 1 1049 0
 4652 2310 14008DE8 		stmia	sp, {r2, r4}
1051:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 4653              		.loc 1 1051 0
 4654 2314 08308DE5 		str	r3, [sp, #8]
1052:../uvc.c      **** 
 4655              		.loc 1 1052 0
 4656 2318 BC30CDE1 		strh	r3, [sp, #12]	@ movhi
1054:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 4657              		.loc 1 1054 0
 4658 231c FEFFFFEB 		bl	CyU3PI2cSetConfig
 4659              	.LVL496:
1055:../uvc.c      ****     {
 4660              		.loc 1 1055 0
 4661 2320 004050E2 		subs	r4, r0, #0
 4662 2324 0600001A 		bne	.L464
1060:../uvc.c      **** 
 4663              		.loc 1 1060 0
 4664 2328 10D08DE2 		add	sp, sp, #16
 4665              		@ sp needed
 4666 232c 1080BDE8 		ldmfd	sp!, {r4, pc}
 4667              	.L463:
1044:../uvc.c      ****         CyFxAppErrorHandler (status);
 4668              		.loc 1 1044 0
 4669 2330 0400A0E3 		mov	r0, #4
 4670              	.LVL497:
 4671 2334 20109FE5 		ldr	r1, .L465+4
 4672 2338 FEFFFFEB 		bl	CyU3PDebugPrint
 4673              	.LVL498:
1045:../uvc.c      ****     }
 4674              		.loc 1 1045 0
 4675 233c 0400A0E1 		mov	r0, r4
 4676 2340 FEFFFFEB 		bl	CyFxAppErrorHandler
 4677              	.LVL499:
 4678              	.L464:
1057:../uvc.c      ****         CyFxAppErrorHandler (status);
 4679              		.loc 1 1057 0
 4680 2344 0400A0E3 		mov	r0, #4
 4681              	.LVL500:
 4682 2348 10109FE5 		ldr	r1, .L465+8
 4683 234c FEFFFFEB 		bl	CyU3PDebugPrint
 4684              	.LVL501:
1058:../uvc.c      ****     }
 4685              		.loc 1 1058 0
 4686 2350 0400A0E1 		mov	r0, r4
 4687 2354 FEFFFFEB 		bl	CyFxAppErrorHandler
 4688              	.LVL502:
 4689              	.L466:
 4690              		.align	2
 4691              	.L465:
 4692 2358 A0860100 		.word	100000
 4693 235c F4040000 		.word	.LC31
 4694 2360 10050000 		.word	.LC32
 4695              		.cfi_endproc
 4696              	.LFE11:
 4698              		.align	2
 4699              		.global	UVCAppThread_Entry
 4701              	UVCAppThread_Entry:
 4702              	.LFB15:
1547:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 4703              		.loc 1 1547 0
 4704              		.cfi_startproc
 4705              		@ args = 0, pretend = 0, frame = 128
 4706              		@ frame_needed = 0, uses_anonymous_args = 0
 4707              	.LVL503:
 4708 2364 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 4709              	.LCFI17:
 4710              		.cfi_def_cfa_offset 32
 4711              		.cfi_offset 4, -32
 4712              		.cfi_offset 5, -28
 4713              		.cfi_offset 6, -24
 4714              		.cfi_offset 7, -20
 4715              		.cfi_offset 8, -16
 4716              		.cfi_offset 9, -12
 4717              		.cfi_offset 10, -8
 4718              		.cfi_offset 14, -4
 4719 2368 88D04DE2 		sub	sp, sp, #136
 4720              	.LCFI18:
 4721              		.cfi_def_cfa_offset 168
 4722              	.LBB324:
 4723              	.LBB325:
 992:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4724              		.loc 1 992 0
 4725 236c FEFFFFEB 		bl	CyU3PUartInit
 4726              	.LVL504:
 993:../uvc.c      ****     {
 4727              		.loc 1 993 0
 4728 2370 004050E2 		subs	r4, r0, #0
 4729 2374 E401001A 		bne	.L527
1000:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 4730              		.loc 1 1000 0
 4731 2378 1C299FE5 		ldr	r2, .L556
1001:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 4732              		.loc 1 1001 0
 4733 237c 0130A0E3 		mov	r3, #1
1009:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4734              		.loc 1 1009 0
 4735 2380 0410A0E1 		mov	r1, r4
 4736 2384 60008DE2 		add	r0, sp, #96
 4737              	.LVL505:
1002:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 4738              		.loc 1 1002 0
 4739 2388 7540CDE5 		strb	r4, [sp, #117]
1004:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 4740              		.loc 1 1004 0
 4741 238c 64408DE5 		str	r4, [sp, #100]
1005:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 4742              		.loc 1 1005 0
 4743 2390 68408DE5 		str	r4, [sp, #104]
1000:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 4744              		.loc 1 1000 0
 4745 2394 70208DE5 		str	r2, [sp, #112]
1001:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 4746              		.loc 1 1001 0
 4747 2398 7430CDE5 		strb	r3, [sp, #116]
1003:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 4748              		.loc 1 1003 0
 4749 239c 60308DE5 		str	r3, [sp, #96]
1006:../uvc.c      **** 
 4750              		.loc 1 1006 0
 4751 23a0 6C308DE5 		str	r3, [sp, #108]
1009:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4752              		.loc 1 1009 0
 4753 23a4 FEFFFFEB 		bl	CyU3PUartSetConfig
 4754              	.LVL506:
1010:../uvc.c      ****     {
 4755              		.loc 1 1010 0
 4756 23a8 000050E3 		cmp	r0, #0
 4757 23ac B201001A 		bne	.L526
1016:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4758              		.loc 1 1016 0
 4759 23b0 0000E0E3 		mvn	r0, #0
 4760              	.LVL507:
 4761 23b4 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 4762              	.LVL508:
1017:../uvc.c      ****     {
 4763              		.loc 1 1017 0
 4764 23b8 000050E3 		cmp	r0, #0
 4765 23bc AE01001A 		bne	.L526
1023:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4766              		.loc 1 1023 0
 4767 23c0 0300A0E3 		mov	r0, #3
 4768              	.LVL509:
 4769 23c4 0810A0E3 		mov	r1, #8
 4770 23c8 FEFFFFEB 		bl	CyU3PDebugInit
 4771              	.LVL510:
1024:../uvc.c      ****     {
 4772              		.loc 1 1024 0
 4773 23cc 000050E3 		cmp	r0, #0
 4774 23d0 A901001A 		bne	.L526
1030:../uvc.c      **** }
 4775              		.loc 1 1030 0
 4776 23d4 FEFFFFEB 		bl	CyU3PDebugPreamble
 4777              	.LVL511:
 4778 23d8 0640A0E3 		mov	r4, #6
 4779              	.LVL512:
 4780              	.L473:
 4781              	.LBE325:
 4782              	.LBE324:
1563:../uvc.c      **** 	}
 4783              		.loc 1 1563 0
 4784 23dc 7D0FA0E3 		mov	r0, #500
 4785 23e0 014044E2 		sub	r4, r4, #1
 4786 23e4 FEFFFFEB 		bl	_tx_thread_sleep
 4787              	.LVL513:
1562:../uvc.c      **** 		CyU3PThreadSleep(500);
 4788              		.loc 1 1562 0
 4789 23e8 FF4014E2 		ands	r4, r4, #255
 4790 23ec FAFFFF1A 		bne	.L473
 4791              	.LBB327:
 4792              	.LBB328:
1128:../uvc.c      ****     if (apiRetStatus != 0)
 4793              		.loc 1 1128 0
 4794 23f0 A8689FE5 		ldr	r6, .L556+4
 4795              	.LBE328:
 4796              	.LBE327:
1566:../uvc.c      **** 
 4797              		.loc 1 1566 0
 4798 23f4 FEFFFFEB 		bl	CyFxUVCApplnI2CInit
 4799              	.LVL514:
 4800              	.LBB332:
 4801              	.LBB329:
1128:../uvc.c      ****     if (apiRetStatus != 0)
 4802              		.loc 1 1128 0
 4803 23f8 0410A0E1 		mov	r1, r4
 4804 23fc 0600A0E1 		mov	r0, r6
 4805 2400 2820A0E3 		mov	r2, #40
 4806 2404 FEFFFFEB 		bl	_txe_event_flags_create
 4807              	.LVL515:
1129:../uvc.c      ****     {
 4808              		.loc 1 1129 0
 4809 2408 005050E2 		subs	r5, r0, #0
 4810 240c EC01001A 		bne	.L528
1143:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 4811              		.loc 1 1143 0
 4812 2410 0270A0E3 		mov	r7, #2
1146:../uvc.c      ****     gpioClock.halfDiv    = 0;
 4813              		.loc 1 1146 0
 4814 2414 0380A0E3 		mov	r8, #3
1150:../uvc.c      ****     if (apiRetStatus != 0)
 4815              		.loc 1 1150 0
 4816 2418 14008DE2 		add	r0, sp, #20
 4817              	.LVL516:
 4818 241c 0410A0E1 		mov	r1, r4
1139:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 4819              		.loc 1 1139 0
 4820 2420 884086E5 		str	r4, [r6, #136]
1140:../uvc.c      **** 
 4821              		.loc 1 1140 0
 4822 2424 944086E5 		str	r4, [r6, #148]
1145:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 4823              		.loc 1 1145 0
 4824 2428 1C40CDE5 		strb	r4, [sp, #28]
1147:../uvc.c      **** 
 4825              		.loc 1 1147 0
 4826 242c 18408DE5 		str	r4, [sp, #24]
1143:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 4827              		.loc 1 1143 0
 4828 2430 1470CDE5 		strb	r7, [sp, #20]
1144:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 4829              		.loc 1 1144 0
 4830 2434 1570CDE5 		strb	r7, [sp, #21]
1146:../uvc.c      ****     gpioClock.halfDiv    = 0;
 4831              		.loc 1 1146 0
 4832 2438 1D80CDE5 		strb	r8, [sp, #29]
1150:../uvc.c      ****     if (apiRetStatus != 0)
 4833              		.loc 1 1150 0
 4834 243c FEFFFFEB 		bl	CyU3PGpioInit
 4835              	.LVL517:
1151:../uvc.c      ****     {
 4836              		.loc 1 1151 0
 4837 2440 005050E2 		subs	r5, r0, #0
 4838 2444 D801001A 		bne	.L529
1159:../uvc.c      ****     if (apiRetStatus != 0)
 4839              		.loc 1 1159 0
 4840 2448 1600A0E3 		mov	r0, #22
 4841              	.LVL518:
 4842 244c 0110A0E3 		mov	r1, #1
 4843 2450 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 4844              	.LVL519:
1160:../uvc.c      ****     {
 4845              		.loc 1 1160 0
 4846 2454 005050E2 		subs	r5, r0, #0
 4847 2458 CD01001A 		bne	.L530
1165:../uvc.c      ****     if (apiRetStatus != 0)
 4848              		.loc 1 1165 0
 4849 245c 1400A0E3 		mov	r0, #20
 4850              	.LVL520:
 4851 2460 0110A0E3 		mov	r1, #1
 4852 2464 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 4853              	.LVL521:
1166:../uvc.c      ****     {
 4854              		.loc 1 1166 0
 4855 2468 005050E2 		subs	r5, r0, #0
 4856 246c C201001A 		bne	.L531
1171:../uvc.c      ****     if (apiRetStatus != 0)
 4857              		.loc 1 1171 0
 4858 2470 1800A0E3 		mov	r0, #24
 4859              	.LVL522:
 4860 2474 0110A0E3 		mov	r1, #1
 4861 2478 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 4862              	.LVL523:
1172:../uvc.c      ****     {
 4863              		.loc 1 1172 0
 4864 247c 005050E2 		subs	r5, r0, #0
 4865 2480 FF01001A 		bne	.L532
1179:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 4866              		.loc 1 1179 0
 4867 2484 0150A0E3 		mov	r5, #1
1184:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4868              		.loc 1 1184 0
 4869 2488 30108DE2 		add	r1, sp, #48
 4870 248c 1600A0E3 		mov	r0, #22
 4871              	.LVL524:
1182:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 4872              		.loc 1 1182 0
 4873 2490 3C408DE5 		str	r4, [sp, #60]
1183:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 4874              		.loc 1 1183 0
 4875 2494 4040CDE5 		strb	r4, [sp, #64]
1179:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 4876              		.loc 1 1179 0
 4877 2498 30508DE5 		str	r5, [sp, #48]
1180:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 4878              		.loc 1 1180 0
 4879 249c 34508DE5 		str	r5, [sp, #52]
1181:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 4880              		.loc 1 1181 0
 4881 24a0 38508DE5 		str	r5, [sp, #56]
1184:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4882              		.loc 1 1184 0
 4883 24a4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 4884              	.LVL525:
1185:../uvc.c      ****     {
 4885              		.loc 1 1185 0
 4886 24a8 009050E2 		subs	r9, r0, #0
 4887 24ac EE01001A 		bne	.L533
1198:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4888              		.loc 1 1198 0
 4889 24b0 1400A0E3 		mov	r0, #20
 4890              	.LVL526:
 4891 24b4 30108DE2 		add	r1, sp, #48
1193:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 4892              		.loc 1 1193 0
 4893 24b8 30508DE5 		str	r5, [sp, #48]
1194:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 4894              		.loc 1 1194 0
 4895 24bc 34508DE5 		str	r5, [sp, #52]
1195:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 4896              		.loc 1 1195 0
 4897 24c0 38508DE5 		str	r5, [sp, #56]
1196:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 4898              		.loc 1 1196 0
 4899 24c4 3C408DE5 		str	r4, [sp, #60]
1197:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 4900              		.loc 1 1197 0
 4901 24c8 4040CDE5 		strb	r4, [sp, #64]
1198:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4902              		.loc 1 1198 0
 4903 24cc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 4904              	.LVL527:
1199:../uvc.c      ****     {
 4905              		.loc 1 1199 0
 4906 24d0 009050E2 		subs	r9, r0, #0
 4907 24d4 DE01001A 		bne	.L534
1212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4908              		.loc 1 1212 0
 4909 24d8 30108DE2 		add	r1, sp, #48
 4910 24dc 1800A0E3 		mov	r0, #24
 4911              	.LVL528:
1207:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 4912              		.loc 1 1207 0
 4913 24e0 30408DE5 		str	r4, [sp, #48]
1208:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 4914              		.loc 1 1208 0
 4915 24e4 34408DE5 		str	r4, [sp, #52]
1209:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 4916              		.loc 1 1209 0
 4917 24e8 38408DE5 		str	r4, [sp, #56]
1210:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 4918              		.loc 1 1210 0
 4919 24ec 3C508DE5 		str	r5, [sp, #60]
1211:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 4920              		.loc 1 1211 0
 4921 24f0 4040CDE5 		strb	r4, [sp, #64]
1212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4922              		.loc 1 1212 0
 4923 24f4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 4924              	.LVL529:
1213:../uvc.c      ****     {
 4925              		.loc 1 1213 0
 4926 24f8 009050E2 		subs	r9, r0, #0
 4927 24fc CE01001A 		bne	.L535
1225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4928              		.loc 1 1225 0
 4929 2500 0500A0E1 		mov	r0, r5
 4930              	.LVL530:
 4931 2504 20108DE2 		add	r1, sp, #32
1222:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 4932              		.loc 1 1222 0
 4933 2508 28408DE5 		str	r4, [sp, #40]
1223:../uvc.c      **** 
 4934              		.loc 1 1223 0
 4935 250c 24408DE5 		str	r4, [sp, #36]
1220:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 4936              		.loc 1 1220 0
 4937 2510 B072CDE1 		strh	r7, [sp, #32]	@ movhi
1221:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 4938              		.loc 1 1221 0
 4939 2514 2C80CDE5 		strb	r8, [sp, #44]
1225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4940              		.loc 1 1225 0
 4941 2518 FEFFFFEB 		bl	CyU3PPibInit
 4942              	.LVL531:
1226:../uvc.c      ****     {
 4943              		.loc 1 1226 0
 4944 251c 004050E2 		subs	r4, r0, #0
 4945 2520 BF01001A 		bne	.L536
1233:../uvc.c      **** 
 4946              		.loc 1 1233 0
 4947 2524 78079FE5 		ldr	r0, .L556+8
 4948              	.LVL532:
 4949 2528 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 4950              	.LVL533:
1241:../uvc.c      ****     SensorInit ();
 4951              		.loc 1 1241 0
 4952 252c FEFFFFEB 		bl	SensorReset
 4953              	.LVL534:
1242:../uvc.c      **** 
 4954              		.loc 1 1242 0
 4955 2530 FEFFFFEB 		bl	SensorInit
 4956              	.LVL535:
1245:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 4957              		.loc 1 1245 0
 4958 2534 FEFFFFEB 		bl	CyU3PUsbStart
 4959              	.LVL536:
1246:../uvc.c      ****     {
 4960              		.loc 1 1246 0
 4961 2538 004050E2 		subs	r4, r0, #0
 4962 253c B201001A 		bne	.L537
1252:../uvc.c      **** 
 4963              		.loc 1 1252 0
 4964 2540 0410A0E1 		mov	r1, r4
 4965 2544 5C079FE5 		ldr	r0, .L556+12
 4966              	.LVL537:
 4967 2548 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 4968              	.LVL538:
1255:../uvc.c      **** 
 4969              		.loc 1 1255 0
 4970 254c 58079FE5 		ldr	r0, .L556+16
 4971 2550 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 4972              	.LVL539:
1261:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 4973              		.loc 1 1261 0
 4974 2554 0410A0E1 		mov	r1, r4
 4975 2558 50279FE5 		ldr	r2, .L556+20
 4976 255c 0100A0E3 		mov	r0, #1
 4977 2560 FEFFFFEB 		bl	CyU3PUsbSetDesc
 4978              	.LVL540:
1262:../uvc.c      **** 
 4979              		.loc 1 1262 0
 4980 2564 0410A0E1 		mov	r1, r4
 4981 2568 0400A0E1 		mov	r0, r4
 4982 256c 40279FE5 		ldr	r2, .L556+24
 4983 2570 FEFFFFEB 		bl	CyU3PUsbSetDesc
 4984              	.LVL541:
1265:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 4985              		.loc 1 1265 0
 4986 2574 0410A0E1 		mov	r1, r4
 4987 2578 38279FE5 		ldr	r2, .L556+28
 4988 257c 0200A0E3 		mov	r0, #2
 4989 2580 FEFFFFEB 		bl	CyU3PUsbSetDesc
 4990              	.LVL542:
1266:../uvc.c      **** 
 4991              		.loc 1 1266 0
 4992 2584 0410A0E1 		mov	r1, r4
 4993 2588 2C279FE5 		ldr	r2, .L556+32
 4994 258c 0700A0E3 		mov	r0, #7
 4995 2590 FEFFFFEB 		bl	CyU3PUsbSetDesc
 4996              	.LVL543:
1269:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 4997              		.loc 1 1269 0
 4998 2594 0410A0E1 		mov	r1, r4
 4999 2598 20279FE5 		ldr	r2, .L556+36
 5000 259c 0400A0E3 		mov	r0, #4
 5001 25a0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5002              	.LVL544:
1270:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5003              		.loc 1 1270 0
 5004 25a4 0410A0E1 		mov	r1, r4
 5005 25a8 14279FE5 		ldr	r2, .L556+40
 5006 25ac 0300A0E3 		mov	r0, #3
 5007 25b0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5008              	.LVL545:
1271:../uvc.c      **** 
 5009              		.loc 1 1271 0
 5010 25b4 0410A0E1 		mov	r1, r4
 5011 25b8 08279FE5 		ldr	r2, .L556+44
 5012 25bc 0600A0E3 		mov	r0, #6
 5013 25c0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5014              	.LVL546:
1274:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5015              		.loc 1 1274 0
 5016 25c4 0410A0E1 		mov	r1, r4
 5017 25c8 FC269FE5 		ldr	r2, .L556+48
 5018 25cc 0500A0E3 		mov	r0, #5
 5019 25d0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5020              	.LVL547:
1275:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5021              		.loc 1 1275 0
 5022 25d4 0110A0E3 		mov	r1, #1
 5023 25d8 F0269FE5 		ldr	r2, .L556+52
 5024 25dc 0500A0E3 		mov	r0, #5
 5025 25e0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5026              	.LVL548:
1276:../uvc.c      **** 
 5027              		.loc 1 1276 0
 5028 25e4 0210A0E3 		mov	r1, #2
 5029 25e8 E4269FE5 		ldr	r2, .L556+56
 5030 25ec 0500A0E3 		mov	r0, #5
 5031 25f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
 5032              	.LVL549:
1279:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5033              		.loc 1 1279 0
 5034 25f4 0100A0E3 		mov	r0, #1
 5035 25f8 0010A0E1 		mov	r1, r0
 5036 25fc FEFFFFEB 		bl	CyU3PConnectState
 5037              	.LVL550:
1280:../uvc.c      ****     {
 5038              		.loc 1 1280 0
 5039 2600 004050E2 		subs	r4, r0, #0
 5040 2604 7A01001A 		bne	.L538
1286:../uvc.c      **** 
 5041              		.loc 1 1286 0
 5042 2608 6400A0E3 		mov	r0, #100
 5043              	.LVL551:
 5044 260c FEFFFFEB 		bl	CyFx3BusyWait
 5045              	.LVL552:
1293:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5046              		.loc 1 1293 0
 5047 2610 0150A0E3 		mov	r5, #1
1294:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5048              		.loc 1 1294 0
 5049 2614 0320A0E3 		mov	r2, #3
1295:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5050              		.loc 1 1295 0
 5051 2618 4030A0E3 		mov	r3, #64
1299:../uvc.c      **** 
 5052              		.loc 1 1299 0
 5053 261c 08108DE2 		add	r1, sp, #8
 5054 2620 8200A0E3 		mov	r0, #130
1296:../uvc.c      ****     endPointConfig.streams  = 0;
 5055              		.loc 1 1296 0
 5056 2624 1340CDE5 		strb	r4, [sp, #19]
1297:../uvc.c      ****     endPointConfig.burstLen = 1;
 5057              		.loc 1 1297 0
 5058 2628 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
1293:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5059              		.loc 1 1293 0
 5060 262c 08508DE5 		str	r5, [sp, #8]
1298:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5061              		.loc 1 1298 0
 5062 2630 1250CDE5 		strb	r5, [sp, #18]
1294:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5063              		.loc 1 1294 0
 5064 2634 0C20CDE5 		strb	r2, [sp, #12]
1295:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5065              		.loc 1 1295 0
 5066 2638 B031CDE1 		strh	r3, [sp, #16]	@ movhi
1299:../uvc.c      **** 
 5067              		.loc 1 1299 0
 5068 263c FEFFFFEB 		bl	CyU3PSetEpConfig
 5069              	.LVL553:
1301:../uvc.c      ****     {
 5070              		.loc 1 1301 0
 5071 2640 004050E2 		subs	r4, r0, #0
1304:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5072              		.loc 1 1304 0
 5073 2644 0400A013 		movne	r0, #4
 5074              	.LVL554:
1301:../uvc.c      ****     {
 5075              		.loc 1 1301 0
 5076 2648 3B01001A 		bne	.L524
1309:../uvc.c      ****     dmaInterConfig.count          = 1;
 5077              		.loc 1 1309 0
 5078 264c 84C69FE5 		ldr	ip, .L556+60
 5079 2650 413BA0E3 		mov	r3, #66560
1318:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5080              		.loc 1 1318 0
 5081 2654 1070A0E3 		mov	r7, #16
1320:../uvc.c      ****             &dmaInterConfig);
 5082              		.loc 1 1320 0
 5083 2658 7C069FE5 		ldr	r0, .L556+64
 5084 265c 0410A0E3 		mov	r1, #4
 5085 2660 44208DE2 		add	r2, sp, #68
1309:../uvc.c      ****     dmaInterConfig.count          = 1;
 5086              		.loc 1 1309 0
 5087 2664 4C408DE5 		str	r4, [sp, #76]
 5088 2668 50408DE5 		str	r4, [sp, #80]
1317:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 5089              		.loc 1 1317 0
 5090 266c 5440CDE5 		strb	r4, [sp, #84]
1319:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 5091              		.loc 1 1319 0
 5092 2670 5C408DE5 		str	r4, [sp, #92]
1309:../uvc.c      ****     dmaInterConfig.count          = 1;
 5093              		.loc 1 1309 0
 5094 2674 48C08DE5 		str	ip, [sp, #72]
 5095 2678 44308DE5 		str	r3, [sp, #68]
1318:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 5096              		.loc 1 1318 0
 5097 267c 58708DE5 		str	r7, [sp, #88]
1320:../uvc.c      ****             &dmaInterConfig);
 5098              		.loc 1 1320 0
 5099 2680 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 5100              	.LVL555:
1322:../uvc.c      ****     {
 5101              		.loc 1 1322 0
 5102 2684 004050E2 		subs	r4, r0, #0
 5103 2688 3501001A 		bne	.L539
1329:../uvc.c      ****     if (glInterStaBuffer == 0)
 5104              		.loc 1 1329 0
 5105 268c 010BA0E3 		mov	r0, #1024
 5106              	.LVL556:
 5107 2690 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 5108              	.LVL557:
 5109 2694 44369FE5 		ldr	r3, .L556+68
1330:../uvc.c      ****     {
 5110              		.loc 1 1330 0
 5111 2698 000050E3 		cmp	r0, #0
1329:../uvc.c      ****     if (glInterStaBuffer == 0)
 5112              		.loc 1 1329 0
 5113 269c 000083E5 		str	r0, [r3]
1330:../uvc.c      ****     {
 5114              		.loc 1 1330 0
 5115 26a0 2A01000A 		beq	.L540
1337:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 5116              		.loc 1 1337 0
 5117 26a4 0410A0E1 		mov	r1, r4
 5118 26a8 0420A0E1 		mov	r2, r4
 5119 26ac 3830A0E3 		mov	r3, #56
 5120 26b0 2C069FE5 		ldr	r0, .L556+72
 5121 26b4 FEFFFFEB 		bl	_txe_mutex_create
 5122              	.LVL558:
1342:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 5123              		.loc 1 1342 0
 5124 26b8 28169FE5 		ldr	r1, .L556+76
1343:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 5125              		.loc 1 1343 0
 5126 26bc 28269FE5 		ldr	r2, .L556+80
1350:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 5127              		.loc 1 1350 0
 5128 26c0 28A69FE5 		ldr	r10, .L556+84
1339:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 5129              		.loc 1 1339 0
 5130 26c4 0470A0E3 		mov	r7, #4
1341:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 5131              		.loc 1 1341 0
 5132 26c8 01ECA0E3 		mov	lr, #256
1345:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 5133              		.loc 1 1345 0
 5134 26cc 0CC0A0E3 		mov	ip, #12
1349:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 5135              		.loc 1 1349 0
 5136 26d0 1830A0E3 		mov	r3, #24
1342:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 5137              		.loc 1 1342 0
 5138 26d4 B816CDE1 		strh	r1, [sp, #104]	@ movhi
1343:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 5139              		.loc 1 1343 0
 5140 26d8 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
1338:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 5141              		.loc 1 1338 0
 5142 26dc 0199A0E3 		mov	r9, #16384
1340:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 5143              		.loc 1 1340 0
 5144 26e0 0280A0E3 		mov	r8, #2
1351:../uvc.c      ****             &dmaMultiConfig);
 5145              		.loc 1 1351 0
 5146 26e4 08069FE5 		ldr	r0, .L556+88
 5147 26e8 0710A0E3 		mov	r1, #7
 5148 26ec 60208DE2 		add	r2, sp, #96
1344:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 5149              		.loc 1 1344 0
 5150 26f0 B647CDE1 		strh	r4, [sp, #118]	@ movhi
1347:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 5151              		.loc 1 1347 0
 5152 26f4 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
1348:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 5153              		.loc 1 1348 0
 5154 26f8 7E40CDE5 		strb	r4, [sp, #126]
1350:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 5155              		.loc 1 1350 0
 5156 26fc 84A08DE5 		str	r10, [sp, #132]
1338:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 5157              		.loc 1 1338 0
 5158 2700 B096CDE1 		strh	r9, [sp, #96]	@ movhi
1339:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 5159              		.loc 1 1339 0
 5160 2704 B276CDE1 		strh	r7, [sp, #98]	@ movhi
1346:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 5161              		.loc 1 1346 0
 5162 2708 BA77CDE1 		strh	r7, [sp, #122]	@ movhi
1340:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 5163              		.loc 1 1340 0
 5164 270c B486CDE1 		strh	r8, [sp, #100]	@ movhi
1341:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 5165              		.loc 1 1341 0
 5166 2710 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
1345:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 5167              		.loc 1 1345 0
 5168 2714 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
1349:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 5169              		.loc 1 1349 0
 5170 2718 80308DE5 		str	r3, [sp, #128]
1351:../uvc.c      ****             &dmaMultiConfig);
 5171              		.loc 1 1351 0
 5172 271c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 5173              	.LVL559:
1353:../uvc.c      ****     {
 5174              		.loc 1 1353 0
 5175 2720 004050E2 		subs	r4, r0, #0
 5176 2724 2C01001A 		bne	.L541
1451:../uvc.c      **** 
 5177              		.loc 1 1451 0
 5178 2728 6400A0E3 		mov	r0, #100
 5179              	.LVL560:
 5180 272c FEFFFFEB 		bl	CyFx3BusyWait
 5181              	.LVL561:
1453:../uvc.c      **** 
 5182              		.loc 1 1453 0
 5183 2730 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 5184              	.LVL562:
1468:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5185              		.loc 1 1468 0
 5186 2734 08108DE2 		add	r1, sp, #8
1467:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 5187              		.loc 1 1467 0
 5188 2738 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
1455:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 5189              		.loc 1 1455 0
 5190 273c 08508DE5 		str	r5, [sp, #8]
1456:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 5191              		.loc 1 1456 0
 5192 2740 0C80CDE5 		strb	r8, [sp, #12]
1460:../uvc.c      ****     }
 5193              		.loc 1 1460 0
 5194 2744 030050E3 		cmp	r0, #3
1453:../uvc.c      **** 
 5195              		.loc 1 1453 0
 5196 2748 0030A0E1 		mov	r3, r0
1460:../uvc.c      ****     }
 5197              		.loc 1 1460 0
 5198 274c 01C0A013 		movne	ip, #1
 5199 2750 10C0A003 		moveq	ip, #16
 5200 2754 022CA013 		movne	r2, #512
 5201 2758 012BA003 		moveq	r2, #1024
1468:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5202              		.loc 1 1468 0
 5203 275c 8300A0E3 		mov	r0, #131
1453:../uvc.c      **** 
 5204              		.loc 1 1453 0
 5205 2760 B830C6E5 		strb	r3, [r6, #184]
 5206 2764 12C0CDE5 		strb	ip, [sp, #18]
 5207 2768 B021CDE1 		strh	r2, [sp, #16]	@ movhi
1468:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5208              		.loc 1 1468 0
 5209 276c FEFFFFEB 		bl	CyU3PSetEpConfig
 5210              	.LVL563:
1469:../uvc.c      ****     {
 5211              		.loc 1 1469 0
 5212 2770 004050E2 		subs	r4, r0, #0
 5213              	.LBE329:
 5214              	.LBE332:
1590:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 5215              		.loc 1 1590 0
 5216 2774 24459F05 		ldreq	r4, .L556+4
 5217              	.LBB333:
 5218              	.LBB330:
1469:../uvc.c      ****     {
 5219              		.loc 1 1469 0
 5220 2778 0E00000A 		beq	.L511
 5221 277c ED0000EA 		b	.L555
 5222              	.LVL564:
 5223              	.L544:
 5224              	.LBE330:
 5225              	.LBE333:
1636:../uvc.c      ****             {
 5226              		.loc 1 1636 0
 5227 2780 783094E5 		ldr	r3, [r4, #120]
 5228 2784 050053E1 		cmp	r3, r5
 5229 2788 0300000A 		beq	.L492
1636:../uvc.c      ****             {
 5230              		.loc 1 1636 0 is_stmt 0 discriminator 1
 5231 278c BC27D4E1 		ldrh	r2, [r4, #124]
 5232 2790 BE37D4E1 		ldrh	r3, [r4, #126]
 5233 2794 030052E1 		cmp	r2, r3
 5234 2798 3E00000A 		beq	.L543
 5235              	.L492:
1811:../uvc.c      ****         glIsApplnActive = CyTrue;//gpif->USB is active
 5236              		.loc 1 1811 0 is_stmt 1
 5237 279c FC049FE5 		ldr	r0, .L556+4
 5238 27a0 4010A0E3 		mov	r1, #64
 5239 27a4 0020A0E3 		mov	r2, #0
 5240 27a8 FEFFFFEB 		bl	_txe_event_flags_set
 5241              	.LVL565:
1812:../uvc.c      **** 
 5242              		.loc 1 1812 0
 5243 27ac 0130A0E3 		mov	r3, #1
 5244 27b0 903086E5 		str	r3, [r6, #144]
1815:../uvc.c      ****     }
 5245              		.loc 1 1815 0
 5246 27b4 FEFFFFEB 		bl	_txe_thread_relinquish
 5247              	.LVL566:
 5248              	.L511:
1590:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 5249              		.loc 1 1590 0
 5250 27b8 0050A0E3 		mov	r5, #0
 5251 27bc 00508DE5 		str	r5, [sp]
 5252 27c0 D8049FE5 		ldr	r0, .L556+4
 5253 27c4 0110A0E3 		mov	r1, #1
 5254 27c8 0220A0E3 		mov	r2, #2
 5255 27cc 60308DE2 		add	r3, sp, #96
 5256 27d0 FEFFFFEB 		bl	_txe_event_flags_get
 5257              	.LVL567:
 5258 27d4 007050E2 		subs	r7, r0, #0
 5259 27d8 E8FFFF0A 		beq	.L544
1737:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 5260              		.loc 1 1737 0
 5261 27dc 00508DE5 		str	r5, [sp]
 5262 27e0 B8049FE5 		ldr	r0, .L556+4
 5263 27e4 0210A0E3 		mov	r1, #2
 5264 27e8 0320A0E3 		mov	r2, #3
 5265 27ec 60308DE2 		add	r3, sp, #96
 5266 27f0 FEFFFFEB 		bl	_txe_event_flags_get
 5267              	.LVL568:
 5268 27f4 000050E3 		cmp	r0, #0
 5269 27f8 0C00001A 		bne	.L503
1753:../uvc.c      ****                 {
 5270              		.loc 1 1753 0
 5271 27fc 943094E5 		ldr	r3, [r4, #148]
1740:../uvc.c      ****                 prodCount = 0;
 5272              		.loc 1 1740 0
 5273 2800 780084E5 		str	r0, [r4, #120]
1753:../uvc.c      ****                 {
 5274              		.loc 1 1753 0
 5275 2804 000053E3 		cmp	r3, #0
1741:../uvc.c      ****                 consCount = 0;
 5276              		.loc 1 1741 0
 5277 2808 BC07C4E1 		strh	r0, [r4, #124]	@ movhi
1743:../uvc.c      ****                 if(0&&(prinflag == 0)){
 5278              		.loc 1 1743 0
 5279 280c 900084E5 		str	r0, [r4, #144]
1742:../uvc.c      ****                 glIsApplnActive = CyFalse;//gpif->USB is not active
 5280              		.loc 1 1742 0
 5281 2810 BE07C4E1 		strh	r0, [r4, #126]	@ movhi
1749:../uvc.c      ****                 pb=0;
 5282              		.loc 1 1749 0
 5283 2814 BC06C4E1 		strh	r0, [r4, #108]	@ movhi
1750:../uvc.c      ****                 pbc=0;
 5284              		.loc 1 1750 0
 5285 2818 BE06C4E1 		strh	r0, [r4, #110]	@ movhi
1751:../uvc.c      **** 
 5286              		.loc 1 1751 0
 5287 281c B007C4E1 		strh	r0, [r4, #112]	@ movhi
1753:../uvc.c      ****                 {
 5288              		.loc 1 1753 0
 5289 2820 4600000A 		beq	.L545
 5290              	.L504:
1765:../uvc.c      ****             }
 5291              		.loc 1 1765 0
 5292 2824 0030A0E3 		mov	r3, #0
 5293 2828 943086E5 		str	r3, [r6, #148]
 5294 282c DAFFFFEA 		b	.L492
 5295              	.L503:
1770:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 5296              		.loc 1 1770 0
 5297 2830 0030E0E3 		mvn	r3, #0
 5298 2834 00308DE5 		str	r3, [sp]
 5299 2838 0110A0E3 		mov	r1, #1
 5300 283c 0220A0E3 		mov	r2, #2
 5301 2840 60308DE2 		add	r3, sp, #96
 5302 2844 54049FE5 		ldr	r0, .L556+4
 5303 2848 FEFFFFEB 		bl	_txe_event_flags_get
 5304              	.LVL569:
1774:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5305              		.loc 1 1774 0
 5306 284c 0510A0E1 		mov	r1, r5
 5307 2850 0520A0E1 		mov	r2, r5
 5308 2854 98049FE5 		ldr	r0, .L556+88
 5309 2858 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 5310              	.LVL570:
1775:../uvc.c      ****                 {
 5311              		.loc 1 1775 0
 5312 285c 005050E2 		subs	r5, r0, #0
 5313 2860 9300001A 		bne	.L546
1783:../uvc.c      ****                 {
 5314              		.loc 1 1783 0
 5315 2864 843094E5 		ldr	r3, [r4, #132]
 5316 2868 000053E3 		cmp	r3, #0
 5317 286c 2B00001A 		bne	.L502
 5318              	.LVL571:
 5319              	.LBB334:
 5320              	.LBB335:
1497:../uvc.c      ****     {
 5321              		.loc 1 1497 0
 5322 2870 B830D4E5 		ldrb	r3, [r4, #184]	@ zero_extendqisi2
 5323 2874 030053E3 		cmp	r3, #3
 5324 2878 6800000A 		beq	.L547
1502:../uvc.c      ****     {
 5325              		.loc 1 1502 0
 5326 287c 020053E3 		cmp	r3, #2
 5327 2880 7E00000A 		beq	.L548
 5328              	.LVL572:
 5329              	.L509:
 5330              	.LBE335:
 5331              	.LBE334:
1799:../uvc.c      ****                     CyU3PThreadSleep(200);
 5332              		.loc 1 1799 0
 5333 2884 0130A0E3 		mov	r3, #1
1800:../uvc.c      **** 
 5334              		.loc 1 1800 0
 5335 2888 C800A0E3 		mov	r0, #200
1799:../uvc.c      ****                     CyU3PThreadSleep(200);
 5336              		.loc 1 1799 0
 5337 288c 843086E5 		str	r3, [r6, #132]
1800:../uvc.c      **** 
 5338              		.loc 1 1800 0
 5339 2890 FEFFFFEB 		bl	_tx_thread_sleep
 5340              	.LVL573:
 5341 2894 C0FFFFEA 		b	.L492
 5342              	.L543:
1662:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 5343              		.loc 1 1662 0
 5344 2898 58549FE5 		ldr	r5, .L556+92
1661:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 5345              		.loc 1 1661 0
 5346 289c 40049FE5 		ldr	r0, .L556+72
 5347 28a0 0010E0E3 		mvn	r1, #0
1646:../uvc.c      ****                 consCount = 0;
 5348              		.loc 1 1646 0
 5349 28a4 BC77C4E1 		strh	r7, [r4, #124]	@ movhi
1643:../uvc.c      ****             	pb=0;
 5350              		.loc 1 1643 0
 5351 28a8 BC76C4E1 		strh	r7, [r4, #108]	@ movhi
1647:../uvc.c      ****                 hitFV     = CyFalse;
 5352              		.loc 1 1647 0
 5353 28ac BE77C4E1 		strh	r7, [r4, #126]	@ movhi
1644:../uvc.c      ****             	pbc=0;
 5354              		.loc 1 1644 0
 5355 28b0 BE76C4E1 		strh	r7, [r4, #110]	@ movhi
1645:../uvc.c      ****                 prodCount = 0;
 5356              		.loc 1 1645 0
 5357 28b4 B077C4E1 		strh	r7, [r4, #112]	@ movhi
1648:../uvc.c      **** 
 5358              		.loc 1 1648 0
 5359 28b8 787084E5 		str	r7, [r4, #120]
1661:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 5360              		.loc 1 1661 0
 5361 28bc FEFFFFEB 		bl	_txe_mutex_get
 5362              	.LVL574:
1662:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 5363              		.loc 1 1662 0
 5364 28c0 0133D5E5 		ldrb	r3, [r5, #769]	@ zero_extendqisi2
 5365 28c4 013023E2 		eor	r3, r3, #1
 5366 28c8 0133C5E5 		strb	r3, [r5, #769]
1664:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 5367              		.loc 1 1664 0
 5368 28cc 743094E5 		ldr	r3, [r4, #116]
 5369 28d0 F00053E3 		cmp	r3, #240
 5370 28d4 4500000A 		beq	.L549
 5371              	.L493:
1672:../uvc.c      **** 
 5372              		.loc 1 1672 0
 5373 28d8 743096E5 		ldr	r3, [r6, #116]
 5374 28dc FF0053E3 		cmp	r3, #255
 5375 28e0 1D00000A 		beq	.L550
1684:../uvc.c      ****                     //CyU3PThreadSleep(400);
 5376              		.loc 1 1684 0
 5377 28e4 743094E5 		ldr	r3, [r4, #116]
 5378 28e8 AA0053E3 		cmp	r3, #170
 5379 28ec 2700000A 		beq	.L551
 5380              	.L494:
1712:../uvc.c      ****                 /* Reset the DMA channel. */
 5381              		.loc 1 1712 0
 5382 28f0 EC039FE5 		ldr	r0, .L556+72
 5383 28f4 FEFFFFEB 		bl	_txe_mutex_put
 5384              	.LVL575:
1714:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5385              		.loc 1 1714 0
 5386 28f8 F4039FE5 		ldr	r0, .L556+88
 5387 28fc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 5388              	.LVL576:
1715:../uvc.c      ****                 {
 5389              		.loc 1 1715 0
 5390 2900 005050E2 		subs	r5, r0, #0
 5391 2904 7A00001A 		bne	.L552
1722:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5392              		.loc 1 1722 0
 5393 2908 0510A0E1 		mov	r1, r5
 5394 290c 0520A0E1 		mov	r2, r5
 5395 2910 DC039FE5 		ldr	r0, .L556+88
 5396              	.LVL577:
 5397 2914 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 5398              	.LVL578:
1723:../uvc.c      ****                 {
 5399              		.loc 1 1723 0
 5400 2918 005050E2 		subs	r5, r0, #0
 5401 291c 5E00001A 		bne	.L553
 5402              	.L502:
1731:../uvc.c      ****                 }
 5403              		.loc 1 1731 0
 5404 2920 C0039FE5 		ldr	r0, .L556+76
 5405              	.LVL579:
 5406 2924 0230A0E3 		mov	r3, #2
 5407 2928 0010A0E3 		mov	r1, #0
 5408 292c 00308DE5 		str	r3, [sp]
 5409 2930 0020A0E1 		mov	r2, r0
 5410 2934 0130A0E1 		mov	r3, r1
 5411 2938 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 5412              	.LVL580:
 5413 293c 96FFFFEA 		b	.L492
 5414              	.LVL581:
 5415              	.L545:
1755:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 5416              		.loc 1 1755 0
 5417 2940 AC039FE5 		ldr	r0, .L556+88
 5418 2944 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 5419              	.LVL582:
1756:../uvc.c      ****                     {
 5420              		.loc 1 1756 0
 5421 2948 000050E3 		cmp	r0, #0
 5422 294c 4A00001A 		bne	.L526
1762:../uvc.c      ****                 }
 5423              		.loc 1 1762 0
 5424 2950 8300A0E3 		mov	r0, #131
 5425              	.LVL583:
 5426 2954 FEFFFFEB 		bl	CyU3PUsbFlushEp
 5427              	.LVL584:
 5428 2958 B1FFFFEA 		b	.L504
 5429              	.L550:
1674:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 5430              		.loc 1 1674 0
 5431 295c DD30D4E5 		ldrb	r3, [r4, #221]	@ zero_extendqisi2
 5432 2960 020053E3 		cmp	r3, #2
 5433 2964 013083E2 		add	r3, r3, #1
 5434 2968 DD30C4E5 		strb	r3, [r4, #221]
 5435 296c DFFFFF9A 		bls	.L494
1675:../uvc.c      ****                 		stiflag = 0x0F;
 5436              		.loc 1 1675 0
 5437 2970 0113D5E5 		ldrb	r1, [r5, #769]	@ zero_extendqisi2
1676:../uvc.c      ****                 		IMcount = 0;
 5438              		.loc 1 1676 0
 5439 2974 0F30A0E3 		mov	r3, #15
1675:../uvc.c      ****                 		stiflag = 0x0F;
 5440              		.loc 1 1675 0
 5441 2978 201081E3 		orr	r1, r1, #32
1677:../uvc.c      ****                 		}
 5442              		.loc 1 1677 0
 5443 297c 0020A0E3 		mov	r2, #0
1675:../uvc.c      ****                 		stiflag = 0x0F;
 5444              		.loc 1 1675 0
 5445 2980 0113C5E5 		strb	r1, [r5, #769]
1677:../uvc.c      ****                 		}
 5446              		.loc 1 1677 0
 5447 2984 DD20C4E5 		strb	r2, [r4, #221]
1676:../uvc.c      ****                 		IMcount = 0;
 5448              		.loc 1 1676 0
 5449 2988 743084E5 		str	r3, [r4, #116]
 5450 298c D7FFFFEA 		b	.L494
 5451              	.L551:
1690:../uvc.c      ****                 	{
 5452              		.loc 1 1690 0
 5453 2990 DD30D4E5 		ldrb	r3, [r4, #221]	@ zero_extendqisi2
 5454 2994 020053E3 		cmp	r3, #2
 5455 2998 013083E2 		add	r3, r3, #1
 5456 299c DD30C4E5 		strb	r3, [r4, #221]
 5457 29a0 D2FFFF9A 		bls	.L494
1692:../uvc.c      ****                      {
 5458              		.loc 1 1692 0
 5459 29a4 DC20D4E5 		ldrb	r2, [r4, #220]	@ zero_extendqisi2
 5460 29a8 010052E3 		cmp	r2, #1
 5461 29ac 4600000A 		beq	.L499
 5462 29b0 020052E3 		cmp	r2, #2
 5463 29b4 0900001A 		bne	.L498
1700:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 5464              		.loc 1 1700 0
 5465 29b8 3010A0E3 		mov	r1, #48
 5466 29bc 0020A0E3 		mov	r2, #0
 5467 29c0 5230A0E3 		mov	r3, #82
 5468 29c4 0B00A0E3 		mov	r0, #11
 5469 29c8 FEFFFFEB 		bl	SensorSetIrisControl
 5470              	.LVL585:
1702:../uvc.c      ****                  		break;
 5471              		.loc 1 1702 0
 5472 29cc 0400A0E3 		mov	r0, #4
 5473 29d0 24139FE5 		ldr	r1, .L556+96
 5474 29d4 0B20A0E3 		mov	r2, #11
 5475 29d8 0130A0E3 		mov	r3, #1
 5476 29dc FEFFFFEB 		bl	CyU3PDebugPrint
 5477              	.LVL586:
 5478              	.L498:
1707:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 5479              		.loc 1 1707 0
 5480 29e0 0030A0E3 		mov	r3, #0
 5481 29e4 DD30C6E5 		strb	r3, [r6, #221]
1709:../uvc.c      ****                 	}
 5482              		.loc 1 1709 0
 5483 29e8 743086E5 		str	r3, [r6, #116]
 5484 29ec BFFFFFEA 		b	.L494
 5485              	.L549:
1664:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 5486              		.loc 1 1664 0 discriminator 1
 5487 29f0 00708DE5 		str	r7, [sp]
 5488 29f4 A4029FE5 		ldr	r0, .L556+4
 5489 29f8 8010A0E3 		mov	r1, #128
 5490 29fc 0320A0E3 		mov	r2, #3
 5491 2a00 60308DE2 		add	r3, sp, #96
 5492 2a04 FEFFFFEB 		bl	_txe_event_flags_get
 5493              	.LVL587:
 5494 2a08 000050E3 		cmp	r0, #0
 5495 2a0c B1FFFF1A 		bne	.L493
1669:../uvc.c      ****                 		IMcount = 0;
 5496              		.loc 1 1669 0
 5497 2a10 FF30A0E3 		mov	r3, #255
1670:../uvc.c      ****                 	}
 5498              		.loc 1 1670 0
 5499 2a14 DD00C4E5 		strb	r0, [r4, #221]
1669:../uvc.c      ****                 		IMcount = 0;
 5500              		.loc 1 1669 0
 5501 2a18 743084E5 		str	r3, [r4, #116]
1670:../uvc.c      ****                 	}
 5502              		.loc 1 1670 0
 5503 2a1c B3FFFFEA 		b	.L494
 5504              	.LVL588:
 5505              	.L547:
 5506              	.LBB338:
 5507              	.LBB336:
1499:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 5508              		.loc 1 1499 0
 5509 2a20 D8129FE5 		ldr	r1, .L556+100
 5510 2a24 0100A0E3 		mov	r0, #1
 5511              	.LVL589:
 5512 2a28 FEFFFFEB 		bl	CyU3PDebugPrint
 5513              	.LVL590:
1500:../uvc.c      ****     }
 5514              		.loc 1 1500 0
 5515 2a2c D0029FE5 		ldr	r0, .L556+104
 5516 2a30 FEFFFFEB 		bl	CyU3PGpifLoad
 5517              	.LVL591:
 5518 2a34 0050A0E1 		mov	r5, r0
 5519              	.LVL592:
 5520              	.L508:
1507:../uvc.c      ****     {
 5521              		.loc 1 1507 0
 5522 2a38 000055E3 		cmp	r5, #0
 5523 2a3c 3700001A 		bne	.L554
 5524              	.LVL593:
1519:../uvc.c      ****     {
 5525              		.loc 1 1519 0
 5526 2a40 B830D6E5 		ldrb	r3, [r6, #184]	@ zero_extendqisi2
 5527 2a44 023043E2 		sub	r3, r3, #2
 5528 2a48 FF3003E2 		and	r3, r3, #255
 5529 2a4c 010053E3 		cmp	r3, #1
 5530 2a50 8BFFFF8A 		bhi	.L509
1517:../uvc.c      ****     }
 5531              		.loc 1 1517 0
 5532 2a54 0500A0E1 		mov	r0, r5
 5533 2a58 0510A0E1 		mov	r1, r5
 5534 2a5c FEFFFFEB 		bl	CyU3PGpifSMStart
 5535              	.LVL594:
1523:../uvc.c      ****     {
 5536              		.loc 1 1523 0
 5537 2a60 005050E2 		subs	r5, r0, #0
 5538 2a64 86FFFF0A 		beq	.L509
1526:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5539              		.loc 1 1526 0
 5540 2a68 0400A0E3 		mov	r0, #4
 5541              	.LVL595:
 5542 2a6c 94129FE5 		ldr	r1, .L556+108
 5543 2a70 0520A0E1 		mov	r2, r5
 5544 2a74 FEFFFFEB 		bl	CyU3PDebugPrint
 5545              	.LVL596:
1527:../uvc.c      ****     }
 5546              		.loc 1 1527 0
 5547 2a78 0500A0E1 		mov	r0, r5
 5548              	.LVL597:
 5549              	.L526:
1511:../uvc.c      ****     }
 5550              		.loc 1 1511 0
 5551 2a7c FEFFFFEB 		bl	CyFxAppErrorHandler
 5552              	.LVL598:
 5553              	.L548:
1504:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 5554              		.loc 1 1504 0
 5555 2a80 84129FE5 		ldr	r1, .L556+112
 5556 2a84 0100A0E3 		mov	r0, #1
 5557              	.LVL599:
 5558 2a88 FEFFFFEB 		bl	CyU3PDebugPrint
 5559              	.LVL600:
1505:../uvc.c      ****     }
 5560              		.loc 1 1505 0
 5561 2a8c 7C029FE5 		ldr	r0, .L556+116
 5562 2a90 FEFFFFEB 		bl	CyU3PGpifLoad
 5563              	.LVL601:
 5564 2a94 0050A0E1 		mov	r5, r0
 5565              	.LVL602:
 5566 2a98 E6FFFFEA 		b	.L508
 5567              	.LVL603:
 5568              	.L553:
 5569              	.LBE336:
 5570              	.LBE338:
1725:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 5571              		.loc 1 1725 0
 5572 2a9c 0400A0E3 		mov	r0, #4
 5573              	.LVL604:
 5574 2aa0 6C129FE5 		ldr	r1, .L556+120
 5575 2aa4 0520A0E1 		mov	r2, r5
 5576 2aa8 FEFFFFEB 		bl	CyU3PDebugPrint
 5577              	.LVL605:
1726:../uvc.c      ****                 }
 5578              		.loc 1 1726 0
 5579 2aac 0500A0E1 		mov	r0, r5
 5580 2ab0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5581              	.LVL606:
 5582              	.L546:
1778:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 5583              		.loc 1 1778 0
 5584 2ab4 0400A0E3 		mov	r0, #4
 5585              	.LVL607:
 5586 2ab8 58129FE5 		ldr	r1, .L556+124
 5587 2abc 0520A0E1 		mov	r2, r5
 5588 2ac0 FEFFFFEB 		bl	CyU3PDebugPrint
 5589              	.LVL608:
1779:../uvc.c      ****                 }
 5590              		.loc 1 1779 0
 5591 2ac4 0500A0E1 		mov	r0, r5
 5592 2ac8 FEFFFFEB 		bl	CyFxAppErrorHandler
 5593              	.LVL609:
 5594              	.L499:
1695:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 5595              		.loc 1 1695 0
 5596 2acc 3010A0E3 		mov	r1, #48
 5597 2ad0 5230A0E3 		mov	r3, #82
 5598 2ad4 0B00A0E3 		mov	r0, #11
 5599 2ad8 FEFFFFEB 		bl	SensorSetIrisControl
 5600              	.LVL610:
1697:../uvc.c      ****                  		break;
 5601              		.loc 1 1697 0
 5602 2adc 18129FE5 		ldr	r1, .L556+96
 5603 2ae0 0B20A0E3 		mov	r2, #11
 5604 2ae4 0030A0E3 		mov	r3, #0
 5605 2ae8 0400A0E3 		mov	r0, #4
 5606 2aec FEFFFFEB 		bl	CyU3PDebugPrint
 5607              	.LVL611:
1698:../uvc.c      ****                  	case 2: //960
 5608              		.loc 1 1698 0
 5609 2af0 BAFFFFEA 		b	.L498
 5610              	.LVL612:
 5611              	.L552:
1717:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 5612              		.loc 1 1717 0
 5613 2af4 0400A0E3 		mov	r0, #4
 5614              	.LVL613:
 5615 2af8 1C129FE5 		ldr	r1, .L556+128
 5616 2afc 0520A0E1 		mov	r2, r5
 5617 2b00 FEFFFFEB 		bl	CyU3PDebugPrint
 5618              	.LVL614:
1718:../uvc.c      ****                 }
 5619              		.loc 1 1718 0
 5620 2b04 0500A0E1 		mov	r0, r5
 5621 2b08 FEFFFFEB 		bl	CyFxAppErrorHandler
 5622              	.LVL615:
 5623              	.L527:
 5624              	.LBB339:
 5625              	.LBB326:
 995:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5626              		.loc 1 995 0
 5627 2b0c 0400A0E3 		mov	r0, #4
 5628              	.LVL616:
 5629 2b10 08129FE5 		ldr	r1, .L556+132
 5630 2b14 FEFFFFEB 		bl	CyU3PDebugPrint
 5631              	.LVL617:
 996:../uvc.c      ****     }
 5632              		.loc 1 996 0
 5633 2b18 0400A0E1 		mov	r0, r4
 5634 2b1c FEFFFFEB 		bl	CyFxAppErrorHandler
 5635              	.LVL618:
 5636              	.L554:
 5637              	.LBE326:
 5638              	.LBE339:
 5639              	.LBB340:
 5640              	.LBB337:
1510:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5641              		.loc 1 1510 0
 5642 2b20 0400A0E3 		mov	r0, #4
 5643              	.LVL619:
 5644 2b24 F8119FE5 		ldr	r1, .L556+136
 5645 2b28 0520A0E1 		mov	r2, r5
 5646 2b2c FEFFFFEB 		bl	CyU3PDebugPrint
 5647              	.LVL620:
1511:../uvc.c      ****     }
 5648              		.loc 1 1511 0
 5649 2b30 0500A0E1 		mov	r0, r5
 5650 2b34 D0FFFFEA 		b	.L526
 5651              	.LVL621:
 5652              	.L555:
 5653              	.LBE337:
 5654              	.LBE340:
 5655              	.LBB341:
 5656              	.LBB331:
1472:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5657              		.loc 1 1472 0
 5658 2b38 0700A0E1 		mov	r0, r7
 5659              	.LVL622:
 5660              	.L524:
 5661 2b3c E4119FE5 		ldr	r1, .L556+140
 5662 2b40 0420A0E1 		mov	r2, r4
 5663 2b44 FEFFFFEB 		bl	CyU3PDebugPrint
 5664              	.LVL623:
1473:../uvc.c      ****     }
 5665              		.loc 1 1473 0
 5666 2b48 0400A0E1 		mov	r0, r4
 5667 2b4c CAFFFFEA 		b	.L526
 5668              	.LVL624:
 5669              	.L540:
1332:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 5670              		.loc 1 1332 0
 5671 2b50 0400A0E3 		mov	r0, #4
 5672 2b54 D0119FE5 		ldr	r1, .L556+144
 5673 2b58 FEFFFFEB 		bl	CyU3PDebugPrint
 5674              	.LVL625:
1333:../uvc.c      ****     }
 5675              		.loc 1 1333 0
 5676 2b5c 0700A0E1 		mov	r0, r7
 5677 2b60 FEFFFFEB 		bl	CyFxAppErrorHandler
 5678              	.LVL626:
 5679              	.L539:
1325:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5680              		.loc 1 1325 0
 5681 2b64 0400A0E3 		mov	r0, #4
 5682              	.LVL627:
 5683 2b68 C0119FE5 		ldr	r1, .L556+148
 5684 2b6c 0420A0E1 		mov	r2, r4
 5685 2b70 FEFFFFEB 		bl	CyU3PDebugPrint
 5686              	.LVL628:
1326:../uvc.c      ****     }
 5687              		.loc 1 1326 0
 5688 2b74 0400A0E1 		mov	r0, r4
 5689 2b78 FEFFFFEB 		bl	CyFxAppErrorHandler
 5690              	.LVL629:
 5691              	.L531:
1168:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5692              		.loc 1 1168 0
 5693 2b7c 0400A0E3 		mov	r0, #4
 5694              	.LVL630:
 5695 2b80 AC119FE5 		ldr	r1, .L556+152
 5696 2b84 0520A0E1 		mov	r2, r5
 5697 2b88 FEFFFFEB 		bl	CyU3PDebugPrint
 5698              	.LVL631:
1169:../uvc.c      ****     }
 5699              		.loc 1 1169 0
 5700 2b8c 0500A0E1 		mov	r0, r5
 5701 2b90 FEFFFFEB 		bl	CyFxAppErrorHandler
 5702              	.LVL632:
 5703              	.L530:
1162:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5704              		.loc 1 1162 0
 5705 2b94 0400A0E3 		mov	r0, #4
 5706              	.LVL633:
 5707 2b98 98119FE5 		ldr	r1, .L556+156
 5708 2b9c 0520A0E1 		mov	r2, r5
 5709 2ba0 FEFFFFEB 		bl	CyU3PDebugPrint
 5710              	.LVL634:
1163:../uvc.c      ****     }
 5711              		.loc 1 1163 0
 5712 2ba4 0500A0E1 		mov	r0, r5
 5713 2ba8 FEFFFFEB 		bl	CyFxAppErrorHandler
 5714              	.LVL635:
 5715              	.L529:
1153:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5716              		.loc 1 1153 0
 5717 2bac 0400A0E3 		mov	r0, #4
 5718              	.LVL636:
 5719 2bb0 84119FE5 		ldr	r1, .L556+160
 5720 2bb4 0520A0E1 		mov	r2, r5
 5721 2bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 5722              	.LVL637:
1154:../uvc.c      ****     }
 5723              		.loc 1 1154 0
 5724 2bbc 0500A0E1 		mov	r0, r5
 5725 2bc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5726              	.LVL638:
 5727              	.L528:
1131:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5728              		.loc 1 1131 0
 5729 2bc4 0400A0E3 		mov	r0, #4
 5730              	.LVL639:
 5731 2bc8 70119FE5 		ldr	r1, .L556+164
 5732 2bcc 0520A0E1 		mov	r2, r5
 5733 2bd0 FEFFFFEB 		bl	CyU3PDebugPrint
 5734              	.LVL640:
1132:../uvc.c      ****     }
 5735              		.loc 1 1132 0
 5736 2bd4 0500A0E1 		mov	r0, r5
 5737 2bd8 FEFFFFEB 		bl	CyFxAppErrorHandler
 5738              	.LVL641:
 5739              	.L541:
1356:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5740              		.loc 1 1356 0
 5741 2bdc 0700A0E1 		mov	r0, r7
 5742              	.LVL642:
 5743 2be0 5C119FE5 		ldr	r1, .L556+168
 5744 2be4 0420A0E1 		mov	r2, r4
 5745 2be8 FEFFFFEB 		bl	CyU3PDebugPrint
 5746              	.LVL643:
1357:../uvc.c      ****     }
 5747              		.loc 1 1357 0
 5748 2bec 0400A0E1 		mov	r0, r4
 5749 2bf0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5750              	.LVL644:
 5751              	.L538:
1282:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5752              		.loc 1 1282 0
 5753 2bf4 0400A0E3 		mov	r0, #4
 5754              	.LVL645:
 5755 2bf8 48119FE5 		ldr	r1, .L556+172
 5756 2bfc 0420A0E1 		mov	r2, r4
 5757 2c00 FEFFFFEB 		bl	CyU3PDebugPrint
 5758              	.LVL646:
1283:../uvc.c      ****     }
 5759              		.loc 1 1283 0
 5760 2c04 0400A0E1 		mov	r0, r4
 5761 2c08 FEFFFFEB 		bl	CyFxAppErrorHandler
 5762              	.LVL647:
 5763              	.L537:
1248:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5764              		.loc 1 1248 0
 5765 2c0c 0400A0E3 		mov	r0, #4
 5766              	.LVL648:
 5767 2c10 34119FE5 		ldr	r1, .L556+176
 5768 2c14 0420A0E1 		mov	r2, r4
 5769 2c18 FEFFFFEB 		bl	CyU3PDebugPrint
 5770              	.LVL649:
1249:../uvc.c      ****     }
 5771              		.loc 1 1249 0
 5772 2c1c 0400A0E1 		mov	r0, r4
 5773 2c20 FEFFFFEB 		bl	CyFxAppErrorHandler
 5774              	.LVL650:
 5775              	.L536:
1228:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5776              		.loc 1 1228 0
 5777 2c24 0400A0E3 		mov	r0, #4
 5778              	.LVL651:
 5779 2c28 20119FE5 		ldr	r1, .L556+180
 5780 2c2c 0420A0E1 		mov	r2, r4
 5781 2c30 FEFFFFEB 		bl	CyU3PDebugPrint
 5782              	.LVL652:
1229:../uvc.c      ****     }
 5783              		.loc 1 1229 0
 5784 2c34 0400A0E1 		mov	r0, r4
 5785 2c38 FEFFFFEB 		bl	CyFxAppErrorHandler
 5786              	.LVL653:
 5787              	.L535:
1215:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5788              		.loc 1 1215 0
 5789 2c3c 0400A0E3 		mov	r0, #4
 5790              	.LVL654:
 5791 2c40 0C119FE5 		ldr	r1, .L556+184
 5792 2c44 0920A0E1 		mov	r2, r9
 5793 2c48 FEFFFFEB 		bl	CyU3PDebugPrint
 5794              	.LVL655:
1216:../uvc.c      ****     }
 5795              		.loc 1 1216 0
 5796 2c4c 0900A0E1 		mov	r0, r9
 5797 2c50 FEFFFFEB 		bl	CyFxAppErrorHandler
 5798              	.LVL656:
 5799              	.L534:
1201:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5800              		.loc 1 1201 0
 5801 2c54 0400A0E3 		mov	r0, #4
 5802              	.LVL657:
 5803 2c58 F8109FE5 		ldr	r1, .L556+188
 5804 2c5c 0920A0E1 		mov	r2, r9
 5805 2c60 FEFFFFEB 		bl	CyU3PDebugPrint
 5806              	.LVL658:
1202:../uvc.c      ****     }
 5807              		.loc 1 1202 0
 5808 2c64 0900A0E1 		mov	r0, r9
 5809 2c68 FEFFFFEB 		bl	CyFxAppErrorHandler
 5810              	.LVL659:
 5811              	.L533:
1187:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5812              		.loc 1 1187 0
 5813 2c6c 0400A0E3 		mov	r0, #4
 5814              	.LVL660:
 5815 2c70 E4109FE5 		ldr	r1, .L556+192
 5816 2c74 0920A0E1 		mov	r2, r9
 5817 2c78 FEFFFFEB 		bl	CyU3PDebugPrint
 5818              	.LVL661:
1188:../uvc.c      ****     }
 5819              		.loc 1 1188 0
 5820 2c7c 0900A0E1 		mov	r0, r9
 5821 2c80 FEFFFFEB 		bl	CyFxAppErrorHandler
 5822              	.LVL662:
 5823              	.L532:
1174:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5824              		.loc 1 1174 0
 5825 2c84 0400A0E3 		mov	r0, #4
 5826              	.LVL663:
 5827 2c88 D0109FE5 		ldr	r1, .L556+196
 5828 2c8c 0520A0E1 		mov	r2, r5
 5829 2c90 FEFFFFEB 		bl	CyU3PDebugPrint
 5830              	.LVL664:
1175:../uvc.c      ****     }
 5831              		.loc 1 1175 0
 5832 2c94 0500A0E1 		mov	r0, r5
 5833 2c98 FEFFFFEB 		bl	CyFxAppErrorHandler
 5834              	.LVL665:
 5835              	.L557:
 5836              		.align	2
 5837              	.L556:
 5838 2c9c 00C20100 		.word	115200
 5839 2ca0 00000000 		.word	.LANCHOR0
 5840 2ca4 00000000 		.word	CyFxGpifCB
 5841 2ca8 00000000 		.word	CyFxUVCApplnUSBSetupCB
 5842 2cac 00000000 		.word	CyFxUVCApplnUSBEventCB
 5843 2cb0 00000000 		.word	CyFxUSBDeviceDscr
 5844 2cb4 00000000 		.word	CyFxUSBDeviceDscrSS
 5845 2cb8 00000000 		.word	CyFxUSBDeviceQualDscr
 5846 2cbc 00000000 		.word	CyFxUSBBOSDscr
 5847 2cc0 00000000 		.word	CyFxUSBHSConfigDscr
 5848 2cc4 00000000 		.word	CyFxUSBFSConfigDscr
 5849 2cc8 00000000 		.word	CyFxUSBSSConfigDscr
 5850 2ccc 00000000 		.word	CyFxUSBStringLangIDDscr
 5851 2cd0 00000000 		.word	CyFxUSBManufactureDscr
 5852 2cd4 00000000 		.word	CyFxUSBProductDscr
 5853 2cd8 013F0203 		.word	50478849
 5854 2cdc 00000000 		.word	glChHandleInterStat
 5855 2ce0 00000000 		.word	glInterStaBuffer
 5856 2ce4 00000000 		.word	imgHdMux
 5857 2ce8 01010000 		.word	257
 5858 2cec 03030000 		.word	771
 5859 2cf0 00000000 		.word	CyFxUvcApplnDmaCallback
 5860 2cf4 00000000 		.word	glChHandleUVCStream
 5861 2cf8 00000000 		.word	.LANCHOR1
 5862 2cfc 20080000 		.word	.LC49
 5863 2d00 D8080000 		.word	.LC53
 5864 2d04 00000000 		.word	.LANCHOR2
 5865 2d08 30090000 		.word	.LC56
 5866 2d0c E8080000 		.word	.LC54
 5867 2d10 1C000000 		.word	.LANCHOR2+28
 5868 2d14 70080000 		.word	.LC51
 5869 2d18 A4080000 		.word	.LC52
 5870 2d1c 44080000 		.word	.LC50
 5871 2d20 2C050000 		.word	.LC33
 5872 2d24 F8080000 		.word	.LC55
 5873 2d28 44070000 		.word	.LC45
 5874 2d2c B8070000 		.word	.LC47
 5875 2d30 78070000 		.word	.LC46
 5876 2d34 C4050000 		.word	.LC37
 5877 2d38 9C050000 		.word	.LC36
 5878 2d3c 78050000 		.word	.LC35
 5879 2d40 4C050000 		.word	.LC34
 5880 2d44 F0070000 		.word	.LC48
 5881 2d48 1C070000 		.word	.LC44
 5882 2d4c EC060000 		.word	.LC43
 5883 2d50 BC060000 		.word	.LC42
 5884 2d54 84060000 		.word	.LC41
 5885 2d58 50060000 		.word	.LC40
 5886 2d5c 1C060000 		.word	.LC39
 5887 2d60 F0050000 		.word	.LC38
 5888              	.LBE331:
 5889              	.LBE341:
 5890              		.cfi_endproc
 5891              	.LFE15:
 5893              		.align	2
 5894              		.global	CyFxApplicationDefine
 5896              	CyFxApplicationDefine:
 5897              	.LFB23:
2854:../uvc.c      **** }
2855:../uvc.c      **** 
2856:../uvc.c      **** 
2857:../uvc.c      **** /*
2858:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
2859:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
2860:../uvc.c      ****  */
2861:../uvc.c      **** void
2862:../uvc.c      **** CyFxApplicationDefine (
2863:../uvc.c      ****         void)
2864:../uvc.c      **** {
 5898              		.loc 1 2864 0
 5899              		.cfi_startproc
 5900              		@ args = 0, pretend = 0, frame = 40
 5901              		@ frame_needed = 0, uses_anonymous_args = 0
 5902              	.LVL666:
 5903 2d64 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5904              	.LCFI19:
 5905              		.cfi_def_cfa_offset 36
 5906              		.cfi_offset 4, -36
 5907              		.cfi_offset 5, -32
 5908              		.cfi_offset 6, -28
 5909              		.cfi_offset 7, -24
 5910              		.cfi_offset 8, -20
 5911              		.cfi_offset 9, -16
 5912              		.cfi_offset 10, -12
 5913              		.cfi_offset 11, -8
 5914              		.cfi_offset 14, -4
2865:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
2866:../uvc.c      ****     uint32_t retThrdCreate;
2867:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2868:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2869:../uvc.c      **** 
2870:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
2871:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 5915              		.loc 1 2871 0
 5916 2d68 010AA0E3 		mov	r0, #4096
2864:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 5917              		.loc 1 2864 0
 5918 2d6c 4CD04DE2 		sub	sp, sp, #76
 5919              	.LCFI20:
 5920              		.cfi_def_cfa_offset 112
 5921              		.loc 1 2871 0
 5922 2d70 FEFFFFEB 		bl	CyU3PMemAlloc
 5923              	.LVL667:
 5924 2d74 00A0A0E1 		mov	r10, r0
 5925              	.LVL668:
2872:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 5926              		.loc 1 2872 0
 5927 2d78 010AA0E3 		mov	r0, #4096
 5928              	.LVL669:
 5929 2d7c FEFFFFEB 		bl	CyU3PMemAlloc
 5930              	.LVL670:
 5931 2d80 0090A0E1 		mov	r9, r0
 5932              	.LVL671:
2873:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 5933              		.loc 1 2873 0
 5934 2d84 010AA0E3 		mov	r0, #4096
 5935              	.LVL672:
 5936 2d88 FEFFFFEB 		bl	CyU3PMemAlloc
 5937              	.LVL673:
2874:../uvc.c      **** 
2875:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 5938              		.loc 1 2875 0
 5939 2d8c 000059E3 		cmp	r9, #0
 5940 2d90 00005A13 		cmpne	r10, #0
 5941 2d94 00C0A013 		movne	ip, #0
 5942 2d98 01C0A003 		moveq	ip, #1
2873:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 5943              		.loc 1 2873 0
 5944 2d9c 00B0A0E1 		mov	fp, r0
 5945              	.LVL674:
 5946              		.loc 1 2875 0
 5947 2da0 0000001A 		bne	.L569
 5948              	.LVL675:
 5949              	.L559:
 5950              	.L561:
 5951 2da4 FEFFFFEA 		b	.L561
 5952              	.LVL676:
 5953              	.L569:
 5954              		.loc 1 2875 0 is_stmt 0 discriminator 1
 5955 2da8 000050E3 		cmp	r0, #0
 5956 2dac FCFFFF0A 		beq	.L559
2876:../uvc.c      ****         goto fatalErrorHandler;
2877:../uvc.c      **** 
2878:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
2879:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 5957              		.loc 1 2879 0 is_stmt 1
 5958 2db0 28008DE2 		add	r0, sp, #40
 5959              	.LVL677:
 5960 2db4 4010A0E3 		mov	r1, #64
 5961 2db8 0C219FE5 		ldr	r2, .L570
 5962 2dbc 28708DE2 		add	r7, sp, #40
 5963 2dc0 24C08DE5 		str	ip, [sp, #36]
 5964 2dc4 FEFFFFEB 		bl	cmdbufCreate
 5965              	.LVL678:
 5966 2dc8 0F00B7E8 		ldmia	r7!, {r0, r1, r2, r3}
 5967 2dcc FC509FE5 		ldr	r5, .L570+4
2880:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 5968              		.loc 1 2880 0
 5969 2dd0 FC409FE5 		ldr	r4, .L570+8
2879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 5970              		.loc 1 2879 0
 5971 2dd4 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 5972 2dd8 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
2881:../uvc.c      **** 
2882:../uvc.c      **** 	/****** initialize command descriptor ***********/
2883:../uvc.c      **** 	cmdquInit(cmdQuptr);
2884:../uvc.c      **** 	cmdquInit(statQuptr);
2885:../uvc.c      **** 
2886:../uvc.c      ****     /* Create the UVC application thread. */
2887:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 5973              		.loc 1 2887 0
 5974 2ddc 0860A0E3 		mov	r6, #8
2879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 5975              		.loc 1 2879 0
 5976 2de0 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
2880:../uvc.c      **** 
 5977              		.loc 1 2880 0
 5978 2de4 EC209FE5 		ldr	r2, .L570+12
 5979 2de8 28008DE2 		add	r0, sp, #40
 5980 2dec 2010A0E3 		mov	r1, #32
 5981 2df0 FEFFFFEB 		bl	cmdbufCreate
 5982              	.LVL679:
 5983 2df4 28E08DE2 		add	lr, sp, #40
 5984 2df8 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 5985              		.loc 1 2887 0
 5986 2dfc 0180A0E3 		mov	r8, #1
2880:../uvc.c      **** 
 5987              		.loc 1 2880 0
 5988 2e00 0F00A4E8 		stmia	r4!, {r0, r1, r2, r3}
 5989 2e04 0F0097E8 		ldmia	r7, {r0, r1, r2, r3}
 5990              		.loc 1 2887 0
 5991 2e08 A870A0E3 		mov	r7, #168
2880:../uvc.c      **** 
 5992              		.loc 1 2880 0
 5993 2e0c 0F0084E8 		stmia	r4, {r0, r1, r2, r3}
2883:../uvc.c      **** 	cmdquInit(statQuptr);
 5994              		.loc 1 2883 0
 5995 2e10 100045E2 		sub	r0, r5, #16
 5996 2e14 FEFFFFEB 		bl	cmdquInit
 5997              	.LVL680:
2884:../uvc.c      **** 
 5998              		.loc 1 2884 0
 5999 2e18 100044E2 		sub	r0, r4, #16
 6000 2e1c FEFFFFEB 		bl	cmdquInit
 6001              	.LVL681:
 6002              		.loc 1 2887 0
 6003 2e20 24C09DE5 		ldr	ip, [sp, #36]
 6004 2e24 012AA0E3 		mov	r2, #4096
 6005 2e28 0C30A0E1 		mov	r3, ip
 6006 2e2c 44008DE9 		stmib	sp, {r2, r6}
 6007 2e30 A4009FE5 		ldr	r0, .L570+16
 6008 2e34 00A08DE5 		str	r10, [sp]
 6009 2e38 10C08DE5 		str	ip, [sp, #16]
 6010 2e3c 0C608DE5 		str	r6, [sp, #12]
 6011 2e40 14808DE5 		str	r8, [sp, #20]
 6012 2e44 18708DE5 		str	r7, [sp, #24]
 6013 2e48 90109FE5 		ldr	r1, .L570+20
 6014 2e4c 90209FE5 		ldr	r2, .L570+24
 6015 2e50 FEFFFFEB 		bl	_txe_thread_create
 6016              	.LVL682:
2888:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
2889:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
2890:../uvc.c      ****             0,                                          /* No input parameter to thread */
2891:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
2892:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
2893:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
2894:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
2895:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
2896:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
2897:../uvc.c      ****             );
2898:../uvc.c      ****     if (retThrdCreate != 0)
 6017              		.loc 1 2898 0
 6018 2e54 003050E2 		subs	r3, r0, #0
 6019 2e58 D1FFFF1A 		bne	.L559
2899:../uvc.c      ****     {
2900:../uvc.c      ****         goto fatalErrorHandler;
2901:../uvc.c      ****     }
2902:../uvc.c      **** 
2903:../uvc.c      ****     /* Create the control request handling thread. */
2904:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 6020              		.loc 1 2904 0
 6021 2e5c 024BA0E3 		mov	r4, #2048
 6022 2e60 10308DE5 		str	r3, [sp, #16]
 6023 2e64 00908DE5 		str	r9, [sp]
 6024 2e68 08608DE5 		str	r6, [sp, #8]
 6025 2e6c 0C608DE5 		str	r6, [sp, #12]
 6026 2e70 14808DE5 		str	r8, [sp, #20]
 6027 2e74 18708DE5 		str	r7, [sp, #24]
 6028 2e78 04408DE5 		str	r4, [sp, #4]
 6029 2e7c 64009FE5 		ldr	r0, .L570+28
 6030              	.LVL683:
 6031 2e80 64109FE5 		ldr	r1, .L570+32
 6032 2e84 64209FE5 		ldr	r2, .L570+36
 6033 2e88 FEFFFFEB 		bl	_txe_thread_create
 6034              	.LVL684:
2905:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
2906:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
2907:../uvc.c      ****             0,                                                  /* No input parameter to thread */
2908:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
2909:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
2910:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
2911:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
2912:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
2913:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
2914:../uvc.c      ****             );
2915:../uvc.c      ****     if (retThrdCreate != 0)
 6035              		.loc 1 2915 0
 6036 2e8c 003050E2 		subs	r3, r0, #0
 6037 2e90 C3FFFF1A 		bne	.L559
2916:../uvc.c      ****     {
2917:../uvc.c      ****         goto fatalErrorHandler;
2918:../uvc.c      ****     }
2919:../uvc.c      **** #if 1
2920:../uvc.c      ****     /* Create the I2C control command handling thread. */
2921:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 6038              		.loc 1 2921 0
 6039 2e94 00B08DE5 		str	fp, [sp]
 6040 2e98 50008DE9 		stmib	sp, {r4, r6}
 6041 2e9c 50009FE5 		ldr	r0, .L570+40
 6042              	.LVL685:
 6043 2ea0 0C608DE5 		str	r6, [sp, #12]
 6044 2ea4 10308DE5 		str	r3, [sp, #16]
 6045 2ea8 14808DE5 		str	r8, [sp, #20]
 6046 2eac 18708DE5 		str	r7, [sp, #24]
 6047 2eb0 40109FE5 		ldr	r1, .L570+44
 6048 2eb4 40209FE5 		ldr	r2, .L570+48
 6049 2eb8 FEFFFFEB 		bl	_txe_thread_create
 6050              	.LVL686:
2922:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
2923:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
2924:../uvc.c      ****             0,                                          /* No input parameter to thread */
2925:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
2926:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
2927:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
2928:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
2929:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
2930:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
2931:../uvc.c      ****             );
2932:../uvc.c      ****     if (retThrdCreate != 0)
 6051              		.loc 1 2932 0
 6052 2ebc 000050E3 		cmp	r0, #0
 6053 2ec0 B7FFFF1A 		bne	.L559
2933:../uvc.c      ****     {
2934:../uvc.c      ****         goto fatalErrorHandler;
2935:../uvc.c      ****     }
2936:../uvc.c      **** #endif
2937:../uvc.c      **** 
2938:../uvc.c      ****     return;
2939:../uvc.c      **** 
2940:../uvc.c      **** fatalErrorHandler:
2941:../uvc.c      ****     /* Add custom recovery or debug actions here */
2942:../uvc.c      ****     /* Loop indefinitely */
2943:../uvc.c      ****     while (1);
2944:../uvc.c      **** }
 6054              		.loc 1 2944 0
 6055 2ec4 4CD08DE2 		add	sp, sp, #76
 6056              		@ sp needed
 6057 2ec8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 6058              	.LVL687:
 6059              	.L571:
 6060              		.align	2
 6061              	.L570:
 6062 2ecc 00000000 		.word	cmdQuMux
 6063 2ed0 00000000 		.word	cmdQu
 6064 2ed4 00000000 		.word	statQu
 6065 2ed8 00000000 		.word	staQuMux
 6066 2edc E0000000 		.word	.LANCHOR0+224
 6067 2ee0 68090000 		.word	.LC57
 6068 2ee4 00000000 		.word	UVCAppThread_Entry
 6069 2ee8 88010000 		.word	.LANCHOR0+392
 6070 2eec 7C090000 		.word	.LC58
 6071 2ef0 00000000 		.word	UVCAppEP0Thread_Entry
 6072 2ef4 30020000 		.word	.LANCHOR0+560
 6073 2ef8 94090000 		.word	.LC59
 6074 2efc 00000000 		.word	I2cAppThread_Entry
 6075              		.cfi_endproc
 6076              	.LFE23:
 6078              		.section	.text.startup,"ax",%progbits
 6079              		.align	2
 6080              		.global	main
 6082              	main:
 6083              	.LFB24:
2945:../uvc.c      **** 
2946:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
2947:../uvc.c      ****  * the ThreadX RTOS here.
2948:../uvc.c      ****  */
2949:../uvc.c      **** int
2950:../uvc.c      **** main (
2951:../uvc.c      ****         void)
2952:../uvc.c      **** {
 6084              		.loc 1 2952 0
 6085              		.cfi_startproc
 6086              		@ args = 0, pretend = 0, frame = 56
 6087              		@ frame_needed = 0, uses_anonymous_args = 0
 6088 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 6089              	.LCFI21:
 6090              		.cfi_def_cfa_offset 12
 6091              		.cfi_offset 4, -12
 6092              		.cfi_offset 5, -8
 6093              		.cfi_offset 14, -4
 6094 0004 3CD04DE2 		sub	sp, sp, #60
 6095              	.LCFI22:
 6096              		.cfi_def_cfa_offset 72
2953:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2954:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
2955:../uvc.c      **** 
2956:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
2957:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
2958:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 6097              		.loc 1 2958 0
 6098 0008 0230A0E3 		mov	r3, #2
2959:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
2960:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
2961:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 6099              		.loc 1 2961 0
 6100 000c 0010A0E3 		mov	r1, #0
2962:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 6101              		.loc 1 2962 0
 6102 0010 0320A0E3 		mov	r2, #3
2957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 6103              		.loc 1 2957 0
 6104 0014 0150A0E3 		mov	r5, #1
2963:../uvc.c      **** 
2964:../uvc.c      ****     /* Initialize the device */
2965:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 6105              		.loc 1 2965 0
 6106 0018 0D00A0E1 		mov	r0, sp
2957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 6107              		.loc 1 2957 0
 6108 001c 00508DE5 		str	r5, [sp]
2958:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 6109              		.loc 1 2958 0
 6110 0020 0430CDE5 		strb	r3, [sp, #4]
2959:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 6111              		.loc 1 2959 0
 6112 0024 0530CDE5 		strb	r3, [sp, #5]
2960:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 6113              		.loc 1 2960 0
 6114 0028 0630CDE5 		strb	r3, [sp, #6]
2961:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 6115              		.loc 1 2961 0
 6116 002c 08108DE5 		str	r1, [sp, #8]
2962:../uvc.c      **** 
 6117              		.loc 1 2962 0
 6118 0030 0C20CDE5 		strb	r2, [sp, #12]
 6119              		.loc 1 2965 0
 6120 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 6121              	.LVL688:
2966:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6122              		.loc 1 2966 0
 6123 0038 004050E2 		subs	r4, r0, #0
 6124 003c 0000000A 		beq	.L577
 6125              	.L573:
 6126              	.L574:
 6127 0040 FEFFFFEA 		b	.L574
 6128              	.L577:
2967:../uvc.c      ****     {
2968:../uvc.c      ****         goto handle_fatal_error;
2969:../uvc.c      ****     }
2970:../uvc.c      **** 
2971:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
2972:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 6129              		.loc 1 2972 0
 6130 0044 0410A0E1 		mov	r1, r4
 6131 0048 0420A0E1 		mov	r2, r4
 6132 004c 0500A0E1 		mov	r0, r5
 6133              	.LVL689:
 6134 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 6135              	.LVL690:
2973:../uvc.c      **** 
2974:../uvc.c      ****     /* Configure the IO matrix for the device. */
2975:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
2976:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
2977:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
2978:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
2979:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
2980:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
2981:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
2982:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
2983:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
2984:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
2985:../uvc.c      **** 
2986:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 6136              		.loc 1 2986 0
 6137 0054 10008DE2 		add	r0, sp, #16
2976:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 6138              		.loc 1 2976 0
 6139 0058 2640CDE5 		strb	r4, [sp, #38]
2977:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 6140              		.loc 1 2977 0
 6141 005c 28408DE5 		str	r4, [sp, #40]
2978:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 6142              		.loc 1 2978 0
 6143 0060 2C408DE5 		str	r4, [sp, #44]
2979:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 6144              		.loc 1 2979 0
 6145 0064 30408DE5 		str	r4, [sp, #48]
2980:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 6146              		.loc 1 2980 0
 6147 0068 34408DE5 		str	r4, [sp, #52]
2983:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 6148              		.loc 1 2983 0
 6149 006c 1C408DE5 		str	r4, [sp, #28]
2984:../uvc.c      **** 
 6150              		.loc 1 2984 0
 6151 0070 20408DE5 		str	r4, [sp, #32]
2975:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 6152              		.loc 1 2975 0
 6153 0074 10508DE5 		str	r5, [sp, #16]
2981:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 6154              		.loc 1 2981 0
 6155 0078 14508DE5 		str	r5, [sp, #20]
2982:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 6156              		.loc 1 2982 0
 6157 007c 18508DE5 		str	r5, [sp, #24]
 6158              		.loc 1 2986 0
 6159 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 6160              	.LVL691:
2987:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6161              		.loc 1 2987 0
 6162 0084 004050E2 		subs	r4, r0, #0
 6163 0088 ECFFFF1A 		bne	.L573
2988:../uvc.c      ****     {
2989:../uvc.c      ****         goto handle_fatal_error;
2990:../uvc.c      ****     }
2991:../uvc.c      **** 
2992:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
2993:../uvc.c      ****     CyU3PKernelEntry ();
 6164              		.loc 1 2993 0
 6165 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 6166              	.LVL692:
2994:../uvc.c      **** 
2995:../uvc.c      ****     /* Dummy return to make the compiler happy */
2996:../uvc.c      ****     return 0;
2997:../uvc.c      **** 
2998:../uvc.c      **** handle_fatal_error:
2999:../uvc.c      ****     /* Cannot recover from this error. */
3000:../uvc.c      ****     while (1);
3001:../uvc.c      **** }
 6167              		.loc 1 3001 0
 6168 0090 0400A0E1 		mov	r0, r4
 6169 0094 3CD08DE2 		add	sp, sp, #60
 6170              		@ sp needed
 6171 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 6172              		.cfi_endproc
 6173              	.LFE24:
 6175              		.comm	I2CCmdTimer,44,4
 6176              		.comm	posTick,4,4
 6177              		.global	glIsConfigured
 6178              		.global	glIsApplnActive
 6179              		.global	glUVCHeader
 6180              		.global	glProbeStilCtrl20
 6181              		.global	glProbeCtrl20
 6182              		.global	glProbeStilCtrl
 6183              		.global	glProbeCtrl
 6184              		.global	streamingStarted
 6185              		.global	clearFeatureRqtReceived
 6186              		.global	usbSpeed
 6187              		.global	isUsbConnected
 6188              		.global	pbcpbak
 6189              		.global	pbcbak
 6190              		.global	pbbak
 6191              		.global	fbbak
 6192              		.global	pbc
 6193              		.global	pb
 6194              		.global	fb
 6195              		.comm	wLength,2,2
 6196              		.comm	wIndex,2,2
 6197              		.comm	wValue,2,2
 6198              		.comm	bRequest,1,1
 6199              		.comm	bmReqType,1,1
 6200              		.comm	imgHdMux,56,4
 6201              		.comm	timMux,56,4
 6202              		.comm	staQuMux,56,4
 6203              		.comm	cmdQuMux,56,4
 6204              		.comm	statQu,32,4
 6205              		.comm	cmdQu,32,4
 6206              		.global	testSnap
 6207              		.global	snapButFlag
 6208              		.comm	glInterStaBuffer,4,4
 6209              		.comm	glChHandleInterStat,172,4
 6210              		.comm	glChHandleStillStream,232,4
 6211              		.comm	glChHandleUVCStream,232,4
 6212              		.global	CyFxGpifConfig_usb2
 6213              		.global	CyFxGpifRegValue_usb2
 6214              		.global	CyFxGpifWavedataPosition_usb2
 6215              		.global	CyFxGpifWavedata_usb2
 6216              		.global	CyFxGpifTransition_usb2
 6217              		.global	CyFxGpifConfig
 6218              		.global	CyFxGpifRegValue
 6219              		.global	CyFxGpifWavedataPosition
 6220              		.global	CyFxGpifWavedata
 6221              		.global	CyFxGpifTransition
 6222              		.section	.rodata
 6223              		.align	2
 6224              		.set	.LANCHOR2,. + 0
 6227              	CyFxGpifConfig:
 6228 0000 0F00     		.short	15
 6229 0002 0000     		.space	2
 6230 0004 00000000 		.word	CyFxGpifWavedata
 6231 0008 00000000 		.word	CyFxGpifWavedataPosition
 6232 000c 0500     		.short	5
 6233 000e 0000     		.space	2
 6234 0010 00000000 		.word	CyFxGpifTransition
 6235 0014 4C00     		.short	76
 6236 0016 0000     		.space	2
 6237 0018 00000000 		.word	CyFxGpifRegValue
 6240              	CyFxGpifConfig_usb2:
 6241 001c 9300     		.short	147
 6242 001e 0000     		.space	2
 6243 0020 00000000 		.word	CyFxGpifWavedata_usb2
 6244 0024 00000000 		.word	CyFxGpifWavedataPosition_usb2
 6245 0028 0800     		.short	8
 6246 002a 0000     		.space	2
 6247 002c 00000000 		.word	CyFxGpifTransition_usb2
 6248 0030 4C00     		.short	76
 6249 0032 0000     		.space	2
 6250 0034 00000000 		.word	CyFxGpifRegValue_usb2
 6251              		.data
 6252              		.align	2
 6253              		.set	.LANCHOR1,. + 0
 6256              	CtrlParArry:
 6257 0000 10       		.byte	16
 6258 0001 10       		.byte	16
 6259 0002 02       		.byte	2
 6260 0003 00       		.byte	0
 6261 0004 00       		.byte	0
 6262 0005 03       		.byte	3
 6263 0006 00       		.byte	0
 6264 0007 01       		.byte	1
 6265 0008 00       		.byte	0
 6266 0009 03       		.byte	3
 6267 000a 00       		.byte	0
 6268 000b 00       		.byte	0
 6269 000c 00       		.byte	0
 6270 000d 00       		.byte	0
 6271 000e 00       		.byte	0
 6272 000f 30       		.byte	48
 6273 0010 01       		.byte	1
 6274 0011 00       		.byte	0
 6275 0012 00       		.byte	0
 6276 0013 00000000 		.space	5
 6276      00
 6277 0018 01       		.byte	1
 6278 0019 00       		.byte	0
 6279 001a 02       		.byte	2
 6280 001b 00       		.byte	0
 6281 001c 00       		.byte	0
 6282 001d 3F       		.byte	63
 6283 001e 00       		.byte	0
 6284 001f 01       		.byte	1
 6285 0020 00       		.byte	0
 6286 0021 03       		.byte	3
 6287 0022 00       		.byte	0
 6288 0023 1F       		.byte	31
 6289 0024 00       		.byte	0
 6290 0025 1F       		.byte	31
 6291 0026 C7       		.byte	-57
 6292 0027 30       		.byte	48
 6293 0028 01       		.byte	1
 6294 0029 01       		.byte	1
 6295 002a 00       		.byte	0
 6296 002b 00000000 		.space	5
 6296      00
 6297 0030 07       		.byte	7
 6298 0031 07       		.byte	7
 6299 0032 02       		.byte	2
 6300 0033 10       		.byte	16
 6301 0034 00       		.byte	0
 6302 0035 40       		.byte	64
 6303 0036 00       		.byte	0
 6304 0037 01       		.byte	1
 6305 0038 00       		.byte	0
 6306 0039 03       		.byte	3
 6307 003a 00       		.byte	0
 6308 003b 28       		.byte	40
 6309 003c 00       		.byte	0
 6310 003d 28       		.byte	40
 6311 003e 00       		.byte	0
 6312 003f 30       		.byte	48
 6313 0040 01       		.byte	1
 6314 0041 01       		.byte	1
 6315 0042 00       		.byte	0
 6316 0043 00000000 		.space	5
 6316      00
 6317 0048 00       		.byte	0
 6318 0049 00       		.byte	0
 6319 004a 02       		.byte	2
 6320 004b 00       		.byte	0
 6321 004c 00       		.byte	0
 6322 004d 64       		.byte	100
 6323 004e 00       		.byte	0
 6324 004f 01       		.byte	1
 6325 0050 00       		.byte	0
 6326 0051 03       		.byte	3
 6327 0052 00       		.byte	0
 6328 0053 00       		.byte	0
 6329 0054 00       		.byte	0
 6330 0055 00       		.byte	0
 6331 0056 00       		.byte	0
 6332 0057 30       		.byte	48
 6333 0058 01       		.byte	1
 6334 0059 00       		.byte	0
 6335 005a 00       		.byte	0
 6336 005b 00000000 		.space	5
 6336      00
 6337 0060 07       		.byte	7
 6338 0061 07       		.byte	7
 6339 0062 02       		.byte	2
 6340 0063 00       		.byte	0
 6341 0064 00       		.byte	0
 6342 0065 01       		.byte	1
 6343 0066 00       		.byte	0
 6344 0067 01       		.byte	1
 6345 0068 00       		.byte	0
 6346 0069 03       		.byte	3
 6347 006a 00       		.byte	0
 6348 006b 01       		.byte	1
 6349 006c 00       		.byte	0
 6350 006d 01       		.byte	1
 6351 006e 00       		.byte	0
 6352 006f 30       		.byte	48
 6353 0070 01       		.byte	1
 6354 0071 00       		.byte	0
 6355 0072 00       		.byte	0
 6356 0073 00000000 		.space	5
 6356      00
 6357 0078 DF       		.byte	-33
 6358 0079 E1       		.byte	-31
 6359 007a 02       		.byte	2
 6360 007b 00       		.byte	0
 6361 007c 00       		.byte	0
 6362 007d FF       		.byte	-1
 6363 007e 00       		.byte	0
 6364 007f 01       		.byte	1
 6365 0080 00       		.byte	0
 6366 0081 03       		.byte	3
 6367 0082 00       		.byte	0
 6368 0083 80       		.byte	-128
 6369 0084 00       		.byte	0
 6370 0085 00       		.byte	0
 6371 0086 00       		.byte	0
 6372 0087 C6       		.byte	-58
 6373 0088 01       		.byte	1
 6374 0089 01       		.byte	1
 6375 008a 00       		.byte	0
 6376 008b 00000000 		.space	5
 6376      00
 6377 0090 85       		.byte	-123
 6378 0091 86       		.byte	-122
 6379 0092 02       		.byte	2
 6380 0093 00       		.byte	0
 6381 0094 00       		.byte	0
 6382 0095 64       		.byte	100
 6383 0096 00       		.byte	0
 6384 0097 01       		.byte	1
 6385 0098 00       		.byte	0
 6386 0099 03       		.byte	3
 6387 009a 00       		.byte	0
 6388 009b 32       		.byte	50
 6389 009c 00       		.byte	0
 6390 009d 32       		.byte	50
 6391 009e 00       		.byte	0
 6392 009f F2       		.byte	-14
 6393 00a0 01       		.byte	1
 6394 00a1 01       		.byte	1
 6395 00a2 00       		.byte	0
 6396 00a3 00000000 		.space	5
 6396      00
 6397 00a8 06       		.byte	6
 6398 00a9 06       		.byte	6
 6399 00aa 02       		.byte	2
 6400 00ab 00       		.byte	0
 6401 00ac 00       		.byte	0
 6402 00ad 0E       		.byte	14
 6403 00ae 00       		.byte	0
 6404 00af 01       		.byte	1
 6405 00b0 00       		.byte	0
 6406 00b1 03       		.byte	3
 6407 00b2 00       		.byte	0
 6408 00b3 00       		.byte	0
 6409 00b4 00       		.byte	0
 6410 00b5 00       		.byte	0
 6411 00b6 00       		.byte	0
 6412 00b7 30       		.byte	48
 6413 00b8 01       		.byte	1
 6414 00b9 01       		.byte	1
 6415 00ba 00       		.byte	0
 6416 00bb 00000000 		.space	5
 6416      00
 6417 00c0 00       		.byte	0
 6418 00c1 00       		.byte	0
 6419 00c2 02       		.byte	2
 6420 00c3 00       		.byte	0
 6421 00c4 00       		.byte	0
 6422 00c5 64       		.byte	100
 6423 00c6 00       		.byte	0
 6424 00c7 01       		.byte	1
 6425 00c8 00       		.byte	0
 6426 00c9 03       		.byte	3
 6427 00ca 00       		.byte	0
 6428 00cb 00       		.byte	0
 6429 00cc 00       		.byte	0
 6430 00cd 00       		.byte	0
 6431 00ce 00       		.byte	0
 6432 00cf 30       		.byte	48
 6433 00d0 01       		.byte	1
 6434 00d1 00       		.byte	0
 6435 00d2 00       		.byte	0
 6436 00d3 00000000 		.space	5
 6436      00
 6437 00d8 08       		.byte	8
 6438 00d9 08       		.byte	8
 6439 00da 02       		.byte	2
 6440 00db 00       		.byte	0
 6441 00dc 00       		.byte	0
 6442 00dd 05       		.byte	5
 6443 00de 00       		.byte	0
 6444 00df 01       		.byte	1
 6445 00e0 00       		.byte	0
 6446 00e1 03       		.byte	3
 6447 00e2 00       		.byte	0
 6448 00e3 00       		.byte	0
 6449 00e4 00       		.byte	0
 6450 00e5 00       		.byte	0
 6451 00e6 00       		.byte	0
 6452 00e7 30       		.byte	48
 6453 00e8 01       		.byte	1
 6454 00e9 00       		.byte	0
 6455 00ea 00       		.byte	0
 6456 00eb 00000000 		.space	5
 6456      00
 6457 00f0 00       		.byte	0
 6458 00f1 00       		.byte	0
 6459 00f2 02       		.byte	2
 6460 00f3 00       		.byte	0
 6461 00f4 00       		.byte	0
 6462 00f5 40       		.byte	64
 6463 00f6 00       		.byte	0
 6464 00f7 01       		.byte	1
 6465 00f8 00       		.byte	0
 6466 00f9 03       		.byte	3
 6467 00fa 00       		.byte	0
 6468 00fb 00       		.byte	0
 6469 00fc 00       		.byte	0
 6470 00fd 00       		.byte	0
 6471 00fe 00       		.byte	0
 6472 00ff 30       		.byte	48
 6473 0100 01       		.byte	1
 6474 0101 00       		.byte	0
 6475 0102 00       		.byte	0
 6476 0103 00000000 		.space	5
 6476      00
 6477 0108 09       		.byte	9
 6478 0109 0A       		.byte	10
 6479 010a 04       		.byte	4
 6480 010b 00       		.byte	0
 6481 010c 00       		.byte	0
 6482 010d 40       		.byte	64
 6483 010e 00       		.byte	0
 6484 010f 01       		.byte	1
 6485 0110 00       		.byte	0
 6486 0111 03       		.byte	3
 6487 0112 00       		.byte	0
 6488 0113 20       		.byte	32
 6489 0114 38       		.byte	56
 6490 0115 20       		.byte	32
 6491 0116 38       		.byte	56
 6492 0117 30       		.byte	48
 6493 0118 01       		.byte	1
 6494 0119 00       		.byte	0
 6495 011a 00       		.byte	0
 6496 011b 00000000 		.space	5
 6496      00
 6497 0120 00       		.byte	0
 6498 0121 00       		.byte	0
 6499 0122 02       		.byte	2
 6500 0123 00       		.byte	0
 6501 0124 00       		.byte	0
 6502 0125 64       		.byte	100
 6503 0126 00       		.byte	0
 6504 0127 01       		.byte	1
 6505 0128 00       		.byte	0
 6506 0129 03       		.byte	3
 6507 012a 00       		.byte	0
 6508 012b 00       		.byte	0
 6509 012c 00       		.byte	0
 6510 012d 00       		.byte	0
 6511 012e 00       		.byte	0
 6512 012f 30       		.byte	48
 6513 0130 01       		.byte	1
 6514 0131 00       		.byte	0
 6515 0132 00       		.byte	0
 6516 0133 00000000 		.space	5
 6516      00
 6517 0138 00       		.byte	0
 6518 0139 00       		.byte	0
 6519 013a 02       		.byte	2
 6520 013b 00       		.byte	0
 6521 013c 00       		.byte	0
 6522 013d 64       		.byte	100
 6523 013e 00       		.byte	0
 6524 013f 01       		.byte	1
 6525 0140 00       		.byte	0
 6526 0141 03       		.byte	3
 6527 0142 00       		.byte	0
 6528 0143 00       		.byte	0
 6529 0144 00       		.byte	0
 6530 0145 00       		.byte	0
 6531 0146 00       		.byte	0
 6532 0147 30       		.byte	48
 6533 0148 01       		.byte	1
 6534 0149 00       		.byte	0
 6535 014a 00       		.byte	0
 6536 014b 00000000 		.space	5
 6536      00
 6537 0150 2A       		.byte	42
 6538 0151 2A       		.byte	42
 6539 0152 02       		.byte	2
 6540 0153 00       		.byte	0
 6541 0154 00       		.byte	0
 6542 0155 1B       		.byte	27
 6543 0156 00       		.byte	0
 6544 0157 01       		.byte	1
 6545 0158 00       		.byte	0
 6546 0159 03       		.byte	3
 6547 015a 00       		.byte	0
 6548 015b 00       		.byte	0
 6549 015c 00       		.byte	0
 6550 015d 00       		.byte	0
 6551 015e 00       		.byte	0
 6552 015f 30       		.byte	48
 6553 0160 01       		.byte	1
 6554 0161 00       		.byte	0
 6555 0162 00       		.byte	0
 6556 0163 00000000 		.space	5
 6556      00
 6557 0168 00       		.byte	0
 6558 0169 00       		.byte	0
 6559 016a 02       		.byte	2
 6560 016b 00       		.byte	0
 6561 016c 00       		.byte	0
 6562 016d 64       		.byte	100
 6563 016e 00       		.byte	0
 6564 016f 01       		.byte	1
 6565 0170 00       		.byte	0
 6566 0171 03       		.byte	3
 6567 0172 00       		.byte	0
 6568 0173 00       		.byte	0
 6569 0174 00       		.byte	0
 6570 0175 00       		.byte	0
 6571 0176 00       		.byte	0
 6572 0177 30       		.byte	48
 6573 0178 01       		.byte	1
 6574 0179 00       		.byte	0
 6575 017a 00       		.byte	0
 6576 017b 00000000 		.space	5
 6576      00
 6577 0180 00       		.byte	0
 6578 0181 00       		.byte	0
 6579 0182 02       		.byte	2
 6580 0183 00       		.byte	0
 6581 0184 00       		.byte	0
 6582 0185 12       		.byte	18
 6583 0186 00       		.byte	0
 6584 0187 01       		.byte	1
 6585 0188 00       		.byte	0
 6586 0189 03       		.byte	3
 6587 018a 00       		.byte	0
 6588 018b 00       		.byte	0
 6589 018c 00       		.byte	0
 6590 018d 00       		.byte	0
 6591 018e 00       		.byte	0
 6592 018f 30       		.byte	48
 6593 0190 01       		.byte	1
 6594 0191 00       		.byte	0
 6595 0192 00       		.byte	0
 6596 0193 00000000 		.space	5
 6596      00
 6597 0198 01       		.byte	1
 6598 0199 01       		.byte	1
 6599 019a 02       		.byte	2
 6600 019b 00       		.byte	0
 6601 019c 00       		.byte	0
 6602 019d 09       		.byte	9
 6603 019e 00       		.byte	0
 6604 019f 01       		.byte	1
 6605 01a0 00       		.byte	0
 6606 01a1 03       		.byte	3
 6607 01a2 00       		.byte	0
 6608 01a3 00       		.byte	0
 6609 01a4 00       		.byte	0
 6610 01a5 01       		.byte	1
 6611 01a6 00       		.byte	0
 6612 01a7 30       		.byte	48
 6613 01a8 01       		.byte	1
 6614 01a9 00       		.byte	0
 6615 01aa 00       		.byte	0
 6616 01ab 00000000 		.space	5
 6616      00
 6617 01b0 05       		.byte	5
 6618 01b1 05       		.byte	5
 6619 01b2 02       		.byte	2
 6620 01b3 00       		.byte	0
 6621 01b4 00       		.byte	0
 6622 01b5 03       		.byte	3
 6623 01b6 00       		.byte	0
 6624 01b7 01       		.byte	1
 6625 01b8 00       		.byte	0
 6626 01b9 03       		.byte	3
 6627 01ba 00       		.byte	0
 6628 01bb 00       		.byte	0
 6629 01bc 00       		.byte	0
 6630 01bd 00       		.byte	0
 6631 01be 00       		.byte	0
 6632 01bf 30       		.byte	48
 6633 01c0 01       		.byte	1
 6634 01c1 00       		.byte	0
 6635 01c2 00       		.byte	0
 6636 01c3 00000000 		.space	5
 6636      00
 6637 01c8 18       		.byte	24
 6638 01c9 18       		.byte	24
 6639 01ca 02       		.byte	2
 6640 01cb 00       		.byte	0
 6641 01cc 00       		.byte	0
 6642 01cd 01       		.byte	1
 6643 01ce 00       		.byte	0
 6644 01cf 01       		.byte	1
 6645 01d0 00       		.byte	0
 6646 01d1 03       		.byte	3
 6647 01d2 00       		.byte	0
 6648 01d3 00       		.byte	0
 6649 01d4 00       		.byte	0
 6650 01d5 00       		.byte	0
 6651 01d6 00       		.byte	0
 6652 01d7 30       		.byte	48
 6653 01d8 01       		.byte	1
 6654 01d9 00       		.byte	0
 6655 01da 00       		.byte	0
 6656 01db 00000000 		.space	5
 6656      00
 6657 01e0 19       		.byte	25
 6658 01e1 19       		.byte	25
 6659 01e2 01       		.byte	1
 6660 01e3 00       		.byte	0
 6661 01e4 00       		.byte	0
 6662 01e5 40       		.byte	64
 6663 01e6 00       		.byte	0
 6664 01e7 01       		.byte	1
 6665 01e8 00       		.byte	0
 6666 01e9 03       		.byte	3
 6667 01ea 00       		.byte	0
 6668 01eb 20       		.byte	32
 6669 01ec 00       		.byte	0
 6670 01ed 20       		.byte	32
 6671 01ee 00       		.byte	0
 6672 01ef 30       		.byte	48
 6673 01f0 01       		.byte	1
 6674 01f1 00       		.byte	0
 6675 01f2 00       		.byte	0
 6676 01f3 00000000 		.space	5
 6676      00
 6677 01f8 20       		.byte	32
 6678 01f9 20       		.byte	32
 6679 01fa 02       		.byte	2
 6680 01fb 00       		.byte	0
 6681 01fc 00       		.byte	0
 6682 01fd 02       		.byte	2
 6683 01fe 00       		.byte	0
 6684 01ff 01       		.byte	1
 6685 0200 00       		.byte	0
 6686 0201 03       		.byte	3
 6687 0202 00       		.byte	0
 6688 0203 00       		.byte	0
 6689 0204 00       		.byte	0
 6690 0205 00       		.byte	0
 6691 0206 00       		.byte	0
 6692 0207 30       		.byte	48
 6693 0208 01       		.byte	1
 6694 0209 00       		.byte	0
 6695 020a 00       		.byte	0
 6696 020b 00000000 		.space	5
 6696      00
 6697 0210 22       		.byte	34
 6698 0211 22       		.byte	34
 6699 0212 02       		.byte	2
 6700 0213 00       		.byte	0
 6701 0214 00       		.byte	0
 6702 0215 3F       		.byte	63
 6703 0216 00       		.byte	0
 6704 0217 01       		.byte	1
 6705 0218 00       		.byte	0
 6706 0219 03       		.byte	3
 6707 021a 00       		.byte	0
 6708 021b 00       		.byte	0
 6709 021c 00       		.byte	0
 6710 021d 00       		.byte	0
 6711 021e 00       		.byte	0
 6712 021f 30       		.byte	48
 6713 0220 01       		.byte	1
 6714 0221 00       		.byte	0
 6715 0222 00       		.byte	0
 6716 0223 00000000 		.space	5
 6716      00
 6717 0228 23       		.byte	35
 6718 0229 23       		.byte	35
 6719 022a 02       		.byte	2
 6720 022b 00       		.byte	0
 6721 022c 00       		.byte	0
 6722 022d 64       		.byte	100
 6723 022e 00       		.byte	0
 6724 022f 01       		.byte	1
 6725 0230 00       		.byte	0
 6726 0231 03       		.byte	3
 6727 0232 00       		.byte	0
 6728 0233 10       		.byte	16
 6729 0234 00       		.byte	0
 6730 0235 10       		.byte	16
 6731 0236 00       		.byte	0
 6732 0237 30       		.byte	48
 6733 0238 01       		.byte	1
 6734 0239 00       		.byte	0
 6735 023a 00       		.byte	0
 6736 023b 00000000 		.space	5
 6736      00
 6737 0240 24       		.byte	36
 6738 0241 24       		.byte	36
 6739 0242 02       		.byte	2
 6740 0243 00       		.byte	0
 6741 0244 00       		.byte	0
 6742 0245 64       		.byte	100
 6743 0246 00       		.byte	0
 6744 0247 01       		.byte	1
 6745 0248 00       		.byte	0
 6746 0249 03       		.byte	3
 6747 024a 00       		.byte	0
 6748 024b 10       		.byte	16
 6749 024c 00       		.byte	0
 6750 024d 10       		.byte	16
 6751 024e 00       		.byte	0
 6752 024f 30       		.byte	48
 6753 0250 01       		.byte	1
 6754 0251 00       		.byte	0
 6755 0252 00       		.byte	0
 6756 0253 00000000 		.space	5
 6756      00
 6757 0258 02       		.byte	2
 6758 0259 03       		.byte	3
 6759 025a 04       		.byte	4
 6760 025b 00       		.byte	0
 6761 025c 00       		.byte	0
 6762 025d FF       		.byte	-1
 6763 025e 00       		.byte	0
 6764 025f 01       		.byte	1
 6765 0260 00       		.byte	0
 6766 0261 03       		.byte	3
 6767 0262 00       		.byte	0
 6768 0263 00       		.byte	0
 6769 0264 20       		.byte	32
 6770 0265 00       		.byte	0
 6771 0266 20       		.byte	32
 6772 0267 30       		.byte	48
 6773 0268 01       		.byte	1
 6774 0269 00       		.byte	0
 6775 026a 00       		.byte	0
 6776 026b 00000000 		.space	5
 6776      00
 6777 0270 04       		.byte	4
 6778 0271 04       		.byte	4
 6779 0272 02       		.byte	2
 6780 0273 00       		.byte	0
 6781 0274 00       		.byte	0
 6782 0275 3F       		.byte	63
 6783 0276 00       		.byte	0
 6784 0277 01       		.byte	1
 6785 0278 00       		.byte	0
 6786 0279 03       		.byte	3
 6787 027a 00       		.byte	0
 6788 027b 20       		.byte	32
 6789 027c 00       		.byte	0
 6790 027d 20       		.byte	32
 6791 027e 00       		.byte	0
 6792 027f 30       		.byte	48
 6793 0280 01       		.byte	1
 6794 0281 00       		.byte	0
 6795 0282 00       		.byte	0
 6796 0283 00000000 		.space	5
 6796      00
 6797 0288 00       		.byte	0
 6798 0289 00       		.byte	0
 6799 028a 02       		.byte	2
 6800 028b 00       		.byte	0
 6801 028c 00       		.byte	0
 6802 028d 19       		.byte	25
 6803 028e 00       		.byte	0
 6804 028f 01       		.byte	1
 6805 0290 00       		.byte	0
 6806 0291 03       		.byte	3
 6807 0292 00       		.byte	0
 6808 0293 00       		.byte	0
 6809 0294 00       		.byte	0
 6810 0295 00       		.byte	0
 6811 0296 00       		.byte	0
 6812 0297 30       		.byte	48
 6813 0298 01       		.byte	1
 6814 0299 00       		.byte	0
 6815 029a 00       		.byte	0
 6816 029b 00000000 		.space	5
 6816      00
 6817 02a0 10       		.byte	16
 6818 02a1 10       		.byte	16
 6819 02a2 02       		.byte	2
 6820 02a3 00       		.byte	0
 6821 02a4 00       		.byte	0
 6822 02a5 06       		.byte	6
 6823 02a6 00       		.byte	0
 6824 02a7 01       		.byte	1
 6825 02a8 00       		.byte	0
 6826 02a9 03       		.byte	3
 6827 02aa 00       		.byte	0
 6828 02ab 00       		.byte	0
 6829 02ac 00       		.byte	0
 6830 02ad 00       		.byte	0
 6831 02ae 00       		.byte	0
 6832 02af 30       		.byte	48
 6833 02b0 01       		.byte	1
 6834 02b1 00       		.byte	0
 6835 02b2 00       		.byte	0
 6836 02b3 00000000 		.space	5
 6836      00
 6837 02b8 00       		.byte	0
 6838 02b9 00       		.byte	0
 6839 02ba 02       		.byte	2
 6840 02bb 00       		.byte	0
 6841 02bc 00       		.byte	0
 6842 02bd 03       		.byte	3
 6843 02be 00       		.byte	0
 6844 02bf 01       		.byte	1
 6845 02c0 00       		.byte	0
 6846 02c1 03       		.byte	3
 6847 02c2 00       		.byte	0
 6848 02c3 00       		.byte	0
 6849 02c4 00       		.byte	0
 6850 02c5 00       		.byte	0
 6851 02c6 00       		.byte	0
 6852 02c7 30       		.byte	48
 6853 02c8 01       		.byte	1
 6854 02c9 00       		.byte	0
 6855 02ca 00       		.byte	0
 6856 02cb 00000000 		.space	5
 6856      00
 6857 02d0 50       		.byte	80
 6858 02d1 50       		.byte	80
 6859 02d2 01       		.byte	1
 6860 02d3 00       		.byte	0
 6861 02d4 00       		.byte	0
 6862 02d5 03       		.byte	3
 6863 02d6 00       		.byte	0
 6864 02d7 01       		.byte	1
 6865 02d8 00       		.byte	0
 6866 02d9 03       		.byte	3
 6867 02da 00       		.byte	0
 6868 02db 00       		.byte	0
 6869 02dc 00       		.byte	0
 6870 02dd 00       		.byte	0
 6871 02de 00       		.byte	0
 6872 02df 30       		.byte	48
 6873 02e0 01       		.byte	1
 6874 02e1 00       		.byte	0
 6875 02e2 00       		.byte	0
 6876 02e3 00000000 		.space	5
 6876      00
 6877 02e8 00       		.byte	0
 6878 02e9 00       		.byte	0
 6879 02ea 0B       		.byte	11
 6880 02eb 00       		.byte	0
 6881 02ec 00       		.byte	0
 6882 02ed FF       		.byte	-1
 6883 02ee FF       		.byte	-1
 6884 02ef 01       		.byte	1
 6885 02f0 00       		.byte	0
 6886 02f1 03       		.byte	3
 6887 02f2 00       		.byte	0
 6888 02f3 00       		.byte	0
 6889 02f4 00       		.byte	0
 6890 02f5 00       		.byte	0
 6891 02f6 00       		.byte	0
 6892 02f7 00       		.byte	0
 6893 02f8 01       		.byte	1
 6894 02f9 00       		.byte	0
 6895 02fa 00       		.byte	0
 6896 02fb 00000000 		.space	5
 6896      00
 6899              	glUVCHeader:
 6900 0300 0C       		.byte	12
 6901 0301 8C       		.byte	-116
 6902 0302 00       		.byte	0
 6903 0303 00       		.byte	0
 6904 0304 00       		.byte	0
 6905 0305 00       		.byte	0
 6906 0306 00       		.byte	0
 6907 0307 00       		.byte	0
 6908 0308 00       		.byte	0
 6909 0309 00       		.byte	0
 6910 030a 00       		.byte	0
 6911 030b 00       		.byte	0
 6914              	glProbeCtrl:
 6915 030c 00       		.byte	0
 6916 030d 00       		.byte	0
 6917 030e 01       		.byte	1
 6918 030f 01       		.byte	1
 6919 0310 15       		.byte	21
 6920 0311 16       		.byte	22
 6921 0312 05       		.byte	5
 6922 0313 00       		.byte	0
 6923 0314 00       		.byte	0
 6924 0315 00       		.byte	0
 6925 0316 00       		.byte	0
 6926 0317 00       		.byte	0
 6927 0318 00       		.byte	0
 6928 0319 00       		.byte	0
 6929 031a 00       		.byte	0
 6930 031b 00       		.byte	0
 6931 031c 00       		.byte	0
 6932 031d 00       		.byte	0
 6933 031e 00       		.byte	0
 6934 031f 48       		.byte	72
 6935 0320 3F       		.byte	63
 6936 0321 00       		.byte	0
 6937 0322 00       		.byte	0
 6938 0323 40       		.byte	64
 6939 0324 00       		.byte	0
 6940 0325 00       		.byte	0
 6941 0326 0000     		.space	2
 6944              	glProbeStilCtrl:
 6945 0328 01       		.byte	1
 6946 0329 01       		.byte	1
 6947 032a 00       		.byte	0
 6948 032b 00       		.byte	0
 6949 032c 48       		.byte	72
 6950 032d 3F       		.byte	63
 6951 032e 00       		.byte	0
 6952 032f 00       		.byte	0
 6953 0330 40       		.byte	64
 6954 0331 00       		.byte	0
 6955 0332 00       		.byte	0
 6956 0333 00       		.space	1
 6959              	glProbeStilCtrl20:
 6960 0334 01       		.byte	1
 6961 0335 01       		.byte	1
 6962 0336 00       		.byte	0
 6963 0337 00       		.byte	0
 6964 0338 D2       		.byte	-46
 6965 0339 0F       		.byte	15
 6966 033a 00       		.byte	0
 6967 033b 00       		.byte	0
 6968 033c 40       		.byte	64
 6969 033d 00       		.byte	0
 6970 033e 00       		.byte	0
 6973              	snapButFlag:
 6974 033f 01       		.byte	1
 6977              	glProbeCtrl20:
 6978 0340 00       		.byte	0
 6979 0341 00       		.byte	0
 6980 0342 01       		.byte	1
 6981 0343 01       		.byte	1
 6982 0344 80       		.byte	-128
 6983 0345 1A       		.byte	26
 6984 0346 06       		.byte	6
 6985 0347 00       		.byte	0
 6986 0348 00       		.byte	0
 6987 0349 00       		.byte	0
 6988 034a 00       		.byte	0
 6989 034b 00       		.byte	0
 6990 034c 00       		.byte	0
 6991 034d 00       		.byte	0
 6992 034e 00       		.byte	0
 6993 034f 00       		.byte	0
 6994 0350 00       		.byte	0
 6995 0351 00       		.byte	0
 6996 0352 00       		.byte	0
 6997 0353 D2       		.byte	-46
 6998 0354 0F       		.byte	15
 6999 0355 00       		.byte	0
 7000 0356 00       		.byte	0
 7001 0357 40       		.byte	64
 7002 0358 00       		.byte	0
 7003 0359 00       		.byte	0
 7004 035a 0000     		.space	2
 7007              	CyFxGpifRegValue_usb2:
 7008 035c 08830080 		.word	-2147450104
 7009 0360 67000000 		.word	103
 7010 0364 01000000 		.word	1
 7011 0368 46000000 		.word	70
 7012 036c 00000000 		.word	0
 7013 0370 00000000 		.word	0
 7014 0374 02000000 		.word	2
 7015 0378 82000000 		.word	130
 7016 037c 82070000 		.word	1922
 7017 0380 40040000 		.word	1088
 7018 0384 FCFF0000 		.word	65532
 7019 0388 28000000 		.word	40
 7020 038c 00000000 		.word	0
 7021 0390 00000000 		.word	0
 7022 0394 00000000 		.word	0
 7023 0398 00000000 		.word	0
 7024 039c 01000000 		.word	1
 7025 03a0 00000000 		.word	0
 7026 03a4 00000000 		.word	0
 7027 03a8 00000000 		.word	0
 7028 03ac 00000000 		.word	0
 7029 03b0 00000000 		.word	0
 7030 03b4 00000000 		.word	0
 7031 03b8 00000000 		.word	0
 7032 03bc 00000000 		.word	0
 7033 03c0 00000000 		.word	0
 7034 03c4 00000000 		.word	0
 7035 03c8 00000000 		.word	0
 7036 03cc 00000000 		.word	0
 7037 03d0 06000000 		.word	6
 7038 03d4 00000000 		.word	0
 7039 03d8 FFFF0000 		.word	65535
 7040 03dc 09010000 		.word	265
 7041 03e0 00000000 		.word	0
 7042 03e4 F71F0000 		.word	8183
 7043 03e8 00000000 		.word	0
 7044 03ec FFFF0000 		.word	65535
 7045 03f0 09010000 		.word	265
 7046 03f4 00000000 		.word	0
 7047 03f8 F71F0000 		.word	8183
 7048 03fc 00000000 		.word	0
 7049 0400 00000000 		.word	0
 7050 0404 00000000 		.word	0
 7051 0408 00000000 		.word	0
 7052 040c 00000000 		.word	0
 7053 0410 00000000 		.word	0
 7054 0414 00000000 		.word	0
 7055 0418 00000000 		.word	0
 7056 041c 00000000 		.word	0
 7057 0420 00000000 		.word	0
 7058 0424 00000000 		.word	0
 7059 0428 00000000 		.word	0
 7060 042c 00000000 		.word	0
 7061 0430 00000000 		.word	0
 7062 0434 00000000 		.word	0
 7063 0438 00000000 		.word	0
 7064 043c 00000000 		.word	0
 7065 0440 00000000 		.word	0
 7066 0444 00000000 		.word	0
 7067 0448 00000000 		.word	0
 7068 044c 00000000 		.word	0
 7069 0450 00000000 		.word	0
 7070 0454 00000000 		.word	0
 7071 0458 00040180 		.word	-2147417088
 7072 045c 01040180 		.word	-2147417087
 7073 0460 02040180 		.word	-2147417086
 7074 0464 03040180 		.word	-2147417085
 7075 0468 00000000 		.word	0
 7076 046c 00000000 		.word	0
 7077 0470 00000000 		.word	0
 7078 0474 00000000 		.word	0
 7079 0478 00000000 		.word	0
 7080 047c 00000000 		.word	0
 7081 0480 00000000 		.word	0
 7082 0484 00000000 		.word	0
 7083 0488 C1FFFFFF 		.word	-63
 7086              	CyFxGpifWavedataPosition_usb2:
 7087 048c 00       		.byte	0
 7088 048d 01       		.byte	1
 7089 048e 02       		.byte	2
 7090 048f 03       		.byte	3
 7091 0490 04       		.byte	4
 7092 0491 05       		.byte	5
 7093 0492 06       		.byte	6
 7094 0493 07       		.byte	7
 7095 0494 08       		.byte	8
 7096 0495 09       		.byte	9
 7097 0496 0A       		.byte	10
 7098 0497 08       		.byte	8
 7099 0498 0B       		.byte	11
 7100 0499 0C       		.byte	12
 7101 049a 0D       		.byte	13
 7102 049b 08       		.byte	8
 7103 049c 0E       		.byte	14
 7104 049d 0F       		.byte	15
 7105 049e 08       		.byte	8
 7106 049f 08       		.byte	8
 7107 04a0 08       		.byte	8
 7108 04a1 08       		.byte	8
 7109 04a2 08       		.byte	8
 7110 04a3 08       		.byte	8
 7111 04a4 08       		.byte	8
 7112 04a5 08       		.byte	8
 7113 04a6 08       		.byte	8
 7114 04a7 08       		.byte	8
 7115 04a8 08       		.byte	8
 7116 04a9 08       		.byte	8
 7117 04aa 08       		.byte	8
 7118 04ab 08       		.byte	8
 7119 04ac 08       		.byte	8
 7120 04ad 08       		.byte	8
 7121 04ae 08       		.byte	8
 7122 04af 08       		.byte	8
 7123 04b0 08       		.byte	8
 7124 04b1 08       		.byte	8
 7125 04b2 08       		.byte	8
 7126 04b3 08       		.byte	8
 7127 04b4 08       		.byte	8
 7128 04b5 08       		.byte	8
 7129 04b6 08       		.byte	8
 7130 04b7 08       		.byte	8
 7131 04b8 08       		.byte	8
 7132 04b9 08       		.byte	8
 7133 04ba 08       		.byte	8
 7134 04bb 08       		.byte	8
 7135 04bc 08       		.byte	8
 7136 04bd 08       		.byte	8
 7137 04be 08       		.byte	8
 7138 04bf 08       		.byte	8
 7139 04c0 08       		.byte	8
 7140 04c1 08       		.byte	8
 7141 04c2 08       		.byte	8
 7142 04c3 08       		.byte	8
 7143 04c4 08       		.byte	8
 7144 04c5 08       		.byte	8
 7145 04c6 08       		.byte	8
 7146 04c7 08       		.byte	8
 7147 04c8 08       		.byte	8
 7148 04c9 08       		.byte	8
 7149 04ca 08       		.byte	8
 7150 04cb 08       		.byte	8
 7151 04cc 08       		.byte	8
 7152 04cd 08       		.byte	8
 7153 04ce 08       		.byte	8
 7154 04cf 08       		.byte	8
 7155 04d0 08       		.byte	8
 7156 04d1 08       		.byte	8
 7157 04d2 08       		.byte	8
 7158 04d3 08       		.byte	8
 7159 04d4 08       		.byte	8
 7160 04d5 08       		.byte	8
 7161 04d6 08       		.byte	8
 7162 04d7 08       		.byte	8
 7163 04d8 08       		.byte	8
 7164 04d9 08       		.byte	8
 7165 04da 08       		.byte	8
 7166 04db 08       		.byte	8
 7167 04dc 08       		.byte	8
 7168 04dd 08       		.byte	8
 7169 04de 08       		.byte	8
 7170 04df 08       		.byte	8
 7171 04e0 08       		.byte	8
 7172 04e1 08       		.byte	8
 7173 04e2 08       		.byte	8
 7174 04e3 08       		.byte	8
 7175 04e4 08       		.byte	8
 7176 04e5 08       		.byte	8
 7177 04e6 08       		.byte	8
 7178 04e7 08       		.byte	8
 7179 04e8 08       		.byte	8
 7180 04e9 08       		.byte	8
 7181 04ea 08       		.byte	8
 7182 04eb 08       		.byte	8
 7183 04ec 08       		.byte	8
 7184 04ed 08       		.byte	8
 7185 04ee 08       		.byte	8
 7186 04ef 08       		.byte	8
 7187 04f0 08       		.byte	8
 7188 04f1 08       		.byte	8
 7189 04f2 08       		.byte	8
 7190 04f3 08       		.byte	8
 7191 04f4 08       		.byte	8
 7192 04f5 08       		.byte	8
 7193 04f6 08       		.byte	8
 7194 04f7 08       		.byte	8
 7195 04f8 08       		.byte	8
 7196 04f9 08       		.byte	8
 7197 04fa 08       		.byte	8
 7198 04fb 08       		.byte	8
 7199 04fc 08       		.byte	8
 7200 04fd 08       		.byte	8
 7201 04fe 08       		.byte	8
 7202 04ff 08       		.byte	8
 7203 0500 08       		.byte	8
 7204 0501 08       		.byte	8
 7205 0502 08       		.byte	8
 7206 0503 08       		.byte	8
 7207 0504 08       		.byte	8
 7208 0505 08       		.byte	8
 7209 0506 08       		.byte	8
 7210 0507 08       		.byte	8
 7211 0508 08       		.byte	8
 7212 0509 08       		.byte	8
 7213 050a 08       		.byte	8
 7214 050b 08       		.byte	8
 7215 050c 00       		.byte	0
 7216 050d 01       		.byte	1
 7217 050e 02       		.byte	2
 7218 050f 10       		.byte	16
 7219 0510 04       		.byte	4
 7220 0511 05       		.byte	5
 7221 0512 06       		.byte	6
 7222 0513 07       		.byte	7
 7223 0514 08       		.byte	8
 7224 0515 09       		.byte	9
 7225 0516 0A       		.byte	10
 7226 0517 08       		.byte	8
 7227 0518 11       		.byte	17
 7228 0519 0C       		.byte	12
 7229 051a 0D       		.byte	13
 7230 051b 08       		.byte	8
 7231 051c 0E       		.byte	14
 7232 051d 0F       		.byte	15
 7233 051e 08       		.byte	8
 7234 051f 00       		.space	1
 7237              	CyFxGpifWavedata_usb2:
 7238 0520 0181731E 		.word	510886145
 7239 0524 00000000 		.word	0
 7240 0528 00000080 		.word	-2147483648
 7241 052c 00000000 		.word	0
 7242 0530 00000000 		.word	0
 7243 0534 00000000 		.word	0
 7244 0538 0201703E 		.word	1047527682
 7245 053c 00010000 		.word	256
 7246 0540 A00000C0 		.word	-1073741664
 7247 0544 00000000 		.word	0
 7248 0548 00000000 		.word	0
 7249 054c 00000000 		.word	0
 7250 0550 0394731E 		.word	510891011
 7251 0554 04000020 		.word	536870916
 7252 0558 60004080 		.word	-2143289248
 7253 055c 00000000 		.word	0
 7254 0560 00000000 		.word	0
 7255 0564 00000000 		.word	0
 7256 0568 0620702E 		.word	779100166
 7257 056c 0C000000 		.word	12
 7258 0570 00000080 		.word	-2147483648
 7259 0574 0620702E 		.word	779100166
 7260 0578 0C000000 		.word	12
 7261 057c 00000080 		.word	-2147483648
 7262 0580 0394731E 		.word	510891011
 7263 0584 04000020 		.word	536870916
 7264 0588 60004080 		.word	-2143289248
 7265 058c 0620702E 		.word	779100166
 7266 0590 0C000000 		.word	12
 7267 0594 00000080 		.word	-2147483648
 7268 0598 0C93731E 		.word	510890764
 7269 059c 04000024 		.word	603979780
 7270 05a0 90004080 		.word	-2143289200
 7271 05a4 0D20702E 		.word	779100173
 7272 05a8 0C000000 		.word	12
 7273 05ac 00000080 		.word	-2147483648
 7274 05b0 0780724E 		.word	1316126727
 7275 05b4 0A000000 		.word	10
 7276 05b8 00000080 		.word	-2147483648
 7277 05bc 08000000 		.word	8
 7278 05c0 00000000 		.word	0
 7279 05c4 00010080 		.word	-2147483392
 7280 05c8 0920702E 		.word	779100169
 7281 05cc 0C010000 		.word	268
 7282 05d0 00000080 		.word	-2147483648
 7283 05d4 0A01701E 		.word	510656778
 7284 05d8 0E000100 		.word	65550
 7285 05dc 00000080 		.word	-2147483648
 7286 05e0 00000000 		.word	0
 7287 05e4 00000000 		.word	0
 7288 05e8 00000000 		.word	0
 7289 05ec 00000000 		.word	0
 7290 05f0 00000000 		.word	0
 7291 05f4 00000000 		.word	0
 7292 05f8 0394731E 		.word	510891011
 7293 05fc 04000020 		.word	536870916
 7294 0600 60004080 		.word	-2143289248
 7295 0604 08000000 		.word	8
 7296 0608 00000000 		.word	0
 7297 060c 00010080 		.word	-2147483392
 7298 0610 0B000000 		.word	11
 7299 0614 00000000 		.word	0
 7300 0618 00010080 		.word	-2147483392
 7301 061c 0C93731E 		.word	510890764
 7302 0620 04000024 		.word	603979780
 7303 0624 90004080 		.word	-2143289200
 7304 0628 0D20702E 		.word	779100173
 7305 062c 0C000000 		.word	12
 7306 0630 00000080 		.word	-2147483648
 7307 0634 0D20702E 		.word	779100173
 7308 0638 0C000000 		.word	12
 7309 063c 00000080 		.word	-2147483648
 7310 0640 0E60724E 		.word	1316118542
 7311 0644 0A000000 		.word	10
 7312 0648 00000080 		.word	-2147483648
 7313 064c 0F000000 		.word	15
 7314 0650 00000000 		.word	0
 7315 0654 00010080 		.word	-2147483392
 7316 0658 1020702E 		.word	779100176
 7317 065c 0C010000 		.word	268
 7318 0660 00000080 		.word	-2147483648
 7319 0664 1101701E 		.word	510656785
 7320 0668 0E000100 		.word	65550
 7321 066c 00000080 		.word	-2147483648
 7322 0670 0C93731E 		.word	510890764
 7323 0674 04000024 		.word	603979780
 7324 0678 90004080 		.word	-2143289200
 7325 067c 0F000000 		.word	15
 7326 0680 00000000 		.word	0
 7327 0684 00010080 		.word	-2147483392
 7328 0688 12000000 		.word	18
 7329 068c 00000000 		.word	0
 7330 0690 00010080 		.word	-2147483392
 7331 0694 0394731E 		.word	510891011
 7332 0698 04000020 		.word	536870916
 7333 069c 60004080 		.word	-2143289248
 7334 06a0 0480732E 		.word	779321348
 7335 06a4 02010000 		.word	258
 7336 06a8 000040C0 		.word	-1069547520
 7337 06ac 0580732E 		.word	779321349
 7338 06b0 02010000 		.word	258
 7339 06b4 000040C0 		.word	-1069547520
 7340 06b8 0580732E 		.word	779321349
 7341 06bc 02010000 		.word	258
 7342 06c0 000040C0 		.word	-1069547520
 7343 06c4 0480732E 		.word	779321348
 7344 06c8 02010000 		.word	258
 7345 06cc 000040C0 		.word	-1069547520
 7348              	CyFxGpifTransition_usb2:
 7349 06d0 0000     		.short	0
 7350 06d2 5555     		.short	21845
 7351 06d4 AAAA     		.short	-21846
 7352 06d6 8888     		.short	-30584
 7353 06d8 1111     		.short	4369
 7354 06da 4444     		.short	17476
 7355 06dc 3333     		.short	13107
 7356 06de CCCC     		.short	-13108
 7359              	CyFxGpifRegValue:
 7360 06e0 08830080 		.word	-2147450104
 7361 06e4 67000000 		.word	103
 7362 06e8 00000000 		.word	0
 7363 06ec 46000000 		.word	70
 7364 06f0 00000000 		.word	0
 7365 06f4 00000000 		.word	0
 7366 06f8 02000000 		.word	2
 7367 06fc 82000000 		.word	130
 7368 0700 82070000 		.word	1922
 7369 0704 40040000 		.word	1088
 7370 0708 FCFF0000 		.word	65532
 7371 070c 28000000 		.word	40
 7372 0710 00000000 		.word	0
 7373 0714 00000000 		.word	0
 7374 0718 00000000 		.word	0
 7375 071c 00000000 		.word	0
 7376 0720 01000000 		.word	1
 7377 0724 00000000 		.word	0
 7378 0728 00000000 		.word	0
 7379 072c 00000000 		.word	0
 7380 0730 00000000 		.word	0
 7381 0734 00000000 		.word	0
 7382 0738 00000000 		.word	0
 7383 073c 00000000 		.word	0
 7384 0740 00000000 		.word	0
 7385 0744 00000000 		.word	0
 7386 0748 00000000 		.word	0
 7387 074c 00000000 		.word	0
 7388 0750 00000000 		.word	0
 7389 0754 06000000 		.word	6
 7390 0758 00000000 		.word	0
 7391 075c FFFF0000 		.word	65535
 7392 0760 09010000 		.word	265
 7393 0764 00000000 		.word	0
 7394 0768 F71F0000 		.word	8183
 7395 076c 00000000 		.word	0
 7396 0770 FFFF0000 		.word	65535
 7397 0774 09010000 		.word	265
 7398 0778 00000000 		.word	0
 7399 077c F71F0000 		.word	8183
 7400 0780 00000000 		.word	0
 7401 0784 00000000 		.word	0
 7402 0788 00000000 		.word	0
 7403 078c 00000000 		.word	0
 7404 0790 00000000 		.word	0
 7405 0794 00000000 		.word	0
 7406 0798 00000000 		.word	0
 7407 079c 00000000 		.word	0
 7408 07a0 00000000 		.word	0
 7409 07a4 00000000 		.word	0
 7410 07a8 00000000 		.word	0
 7411 07ac 00000000 		.word	0
 7412 07b0 00000000 		.word	0
 7413 07b4 00000000 		.word	0
 7414 07b8 00000000 		.word	0
 7415 07bc 00000000 		.word	0
 7416 07c0 00000000 		.word	0
 7417 07c4 00000000 		.word	0
 7418 07c8 00000000 		.word	0
 7419 07cc 00000000 		.word	0
 7420 07d0 00000000 		.word	0
 7421 07d4 00000000 		.word	0
 7422 07d8 00000000 		.word	0
 7423 07dc 00040180 		.word	-2147417088
 7424 07e0 01040180 		.word	-2147417087
 7425 07e4 02040180 		.word	-2147417086
 7426 07e8 03040180 		.word	-2147417085
 7427 07ec 00000000 		.word	0
 7428 07f0 00000000 		.word	0
 7429 07f4 00000000 		.word	0
 7430 07f8 00000000 		.word	0
 7431 07fc 00000000 		.word	0
 7432 0800 00000000 		.word	0
 7433 0804 00000000 		.word	0
 7434 0808 00000000 		.word	0
 7435 080c C1FFFFFF 		.word	-63
 7438              	CyFxGpifWavedataPosition:
 7439 0810 00       		.byte	0
 7440 0811 01       		.byte	1
 7441 0812 02       		.byte	2
 7442 0813 03       		.byte	3
 7443 0814 04       		.byte	4
 7444 0815 05       		.byte	5
 7445 0816 06       		.byte	6
 7446 0817 07       		.byte	7
 7447 0818 08       		.byte	8
 7448 0819 09       		.byte	9
 7449 081a 0A       		.byte	10
 7450 081b 0B       		.byte	11
 7451 081c 0B       		.byte	11
 7452 081d 0B       		.byte	11
 7453 081e 0B       		.byte	11
 7454 081f 00       		.space	1
 7457              	CyFxGpifWavedata:
 7458 0820 0181731E 		.word	510886145
 7459 0824 00000000 		.word	0
 7460 0828 00000080 		.word	-2147483648
 7461 082c 00000000 		.word	0
 7462 0830 00000000 		.word	0
 7463 0834 00000000 		.word	0
 7464 0838 0201702E 		.word	779092226
 7465 083c 00010000 		.word	256
 7466 0840 A0000080 		.word	-2147483488
 7467 0844 00000000 		.word	0
 7468 0848 00000000 		.word	0
 7469 084c 00000000 		.word	0
 7470 0850 0380722E 		.word	779255811
 7471 0854 02010020 		.word	536871170
 7472 0858 60000080 		.word	-2147483552
 7473 085c 00000000 		.word	0
 7474 0860 00000000 		.word	0
 7475 0864 00000000 		.word	0
 7476 0868 0460722E 		.word	779247620
 7477 086c 02010024 		.word	603980034
 7478 0870 90000080 		.word	-2147483504
 7479 0874 0594731E 		.word	510891013
 7480 0878 06000000 		.word	6
 7481 087c 00000080 		.word	-2147483648
 7482 0880 0380722E 		.word	779255811
 7483 0884 02010020 		.word	536871170
 7484 0888 60000080 		.word	-2147483552
 7485 088c 0693731E 		.word	510890758
 7486 0890 06000000 		.word	6
 7487 0894 00000080 		.word	-2147483648
 7488 0898 0720703E 		.word	1047535623
 7489 089c 08010000 		.word	264
 7490 08a0 00000080 		.word	-2147483648
 7491 08a4 0820703E 		.word	1047535624
 7492 08a8 08010000 		.word	264
 7493 08ac 00000080 		.word	-2147483648
 7494 08b0 0920703E 		.word	1047535625
 7495 08b4 08010000 		.word	264
 7496 08b8 00000080 		.word	-2147483648
 7497 08bc 0A20703E 		.word	1047535626
 7498 08c0 08010000 		.word	264
 7499 08c4 00000080 		.word	-2147483648
 7500 08c8 0380722E 		.word	779255811
 7501 08cc 02010020 		.word	536871170
 7502 08d0 60000080 		.word	-2147483552
 7503 08d4 0B000000 		.word	11
 7504 08d8 00000000 		.word	0
 7505 08dc 00010080 		.word	-2147483392
 7506 08e0 0460722E 		.word	779247620
 7507 08e4 02010024 		.word	603980034
 7508 08e8 90000080 		.word	-2147483504
 7509 08ec 0D000000 		.word	13
 7510 08f0 00000000 		.word	0
 7511 08f4 00010080 		.word	-2147483392
 7512 08f8 0460722E 		.word	779247620
 7513 08fc 02010024 		.word	603980034
 7514 0900 90000080 		.word	-2147483504
 7515 0904 0C000000 		.word	12
 7516 0908 00000000 		.word	0
 7517 090c 00010080 		.word	-2147483392
 7518 0910 0380722E 		.word	779255811
 7519 0914 02010020 		.word	536871170
 7520 0918 60000080 		.word	-2147483552
 7521 091c 0E000000 		.word	14
 7522 0920 00000000 		.word	0
 7523 0924 00010080 		.word	-2147483392
 7524 0928 00000000 		.word	0
 7525 092c 00000000 		.word	0
 7526 0930 00000000 		.word	0
 7527 0934 00000000 		.word	0
 7528 0938 00000000 		.word	0
 7529 093c 00000000 		.word	0
 7532              	CyFxGpifTransition:
 7533 0940 0000     		.short	0
 7534 0942 5555     		.short	21845
 7535 0944 8888     		.short	-30584
 7536 0946 AAAA     		.short	-21846
 7537 0948 3333     		.short	13107
 7538 094a 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 7539              		.align	2
 7540              	.LC0:
 7541 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 7541      7065722D 
 7541      74696D65 
 7541      72202564 
 7541      0D0A00
 7542 0013 00       		.space	1
 7543              	.LC1:
 7544 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 7544      636F6D6D 
 7544      616E6420 
 7544      71756575 
 7544      65206973 
 7545 0037 00       		.space	1
 7546              	.LC2:
 7547 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 7547      7220696E 
 7547      206D756C 
 7547      74696368 
 7547      616E6E65 
 7548 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 7548      2C20646D 
 7548      61446F6E 
 7548      65202578 
 7548      0D0A00
 7549 007e 0000     		.space	2
 7550              	.LC3:
 7551 0080 0A746865 		.ascii	"\012the event...0x%x 0x%x\015\012\000"
 7551      20657665 
 7551      6E742E2E 
 7551      2E307825 
 7551      78203078 
 7552 0099 000000   		.space	3
 7553              	.LC4:
 7554 009c 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 7554      5420656E 
 7554      636F756E 
 7554      74657265 
 7554      642E2E2E 
 7555              	.LC5:
 7556 00bc 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 7556      454E4420 
 7556      656E636F 
 7556      756E7465 
 7556      7265642E 
 7557 00de 0000     		.space	2
 7558              	.LC6:
 7559 00e0 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 7559      64697363 
 7559      6F6E6E65 
 7559      63746564 
 7559      2E2E2E30 
 7560 00ff 00       		.space	1
 7561              	.LC7:
 7562 0100 0A206465 		.ascii	"\012 default...0x%x 0x%x\015\012\000"
 7562      6661756C 
 7562      742E2E2E 
 7562      30782578 
 7562      20307825 
 7563              	.LC8:
 7564 0118 0A0D6252 		.ascii	"\012\015bRType = 0x%x, bRequest = 0x%x, wValue = 0x"
 7564      54797065 
 7564      203D2030 
 7564      7825782C 
 7564      20625265 
 7565 0145 25782C20 		.ascii	"%x, wIndex = 0x%x, wLength= 0x%x\000"
 7565      77496E64 
 7565      6578203D 
 7565      20307825 
 7565      782C2077 
 7566 0166 0000     		.space	2
 7567              	.LC9:
 7568 0168 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 7568      43595F46 
 7568      585F5556 
 7568      435F5649 
 7568      44454F5F 
 7569 019b 0A00     		.ascii	"\012\000"
 7570 019d 000000   		.space	3
 7571              	.LC10:
 7572 01a0 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 7572      43595F46 
 7572      585F5556 
 7572      435F5649 
 7572      44454F5F 
 7573 01d3 00       		.ascii	"\000"
 7574              	.LC11:
 7575 01d4 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 7575      726E6174 
 7575      65207365 
 7575      7474696E 
 7575      6720302E 
 7576              	.LC12:
 7577 01ec 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 7577      72206665 
 7577      61747572 
 7577      65207265 
 7577      71756573 
 7578 020f 00       		.space	1
 7579              	.LC13:
 7580 0210 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 7580      67657420 
 7580      64617461 
 7580      2066726F 
 7580      6D20686F 
 7581 023d 000000   		.space	3
 7582              	.LC14:
 7583 0240 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 7583      52657175 
 7583      65737420 
 7583      30782578 
 7583      20706172 
 7584 0273 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 7584      6E642074 
 7584      6F20686F 
 7584      73742030 
 7584      78257820 
 7585 028e 0000     		.space	2
 7586              	.LC15:
 7587 0290 4572726F 		.ascii	"Error handler...\015\012\000"
 7587      72206861 
 7587      6E646C65 
 7587      722E2E2E 
 7587      0D0A00
 7588 02a3 00       		.space	1
 7589              	.LC16:
 7590 02a4 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 7590      64656661 
 7590      756C7420 
 7590      73657475 
 7590      70207265 
 7591              	.LC17:
 7592 02d0 47657420 		.ascii	"Get UVC Prob(set) control %d %d %d %d %d %d %d\015\012"
 7592      55564320 
 7592      50726F62 
 7592      28736574 
 7592      2920636F 
 7593 0300 00       		.ascii	"\000"
 7594 0301 000000   		.space	3
 7595              	.LC18:
 7596 0304 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 7596      74686520 
 7596      76696465 
 7596      6F206D6F 
 7596      64652066 
 7597 0325 000000   		.space	3
 7598              	.LC19:
 7599 0328 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 7599      74686520 
 7599      76696465 
 7599      6F206D6F 
 7599      64652066 
 7600 034d 000000   		.space	3
 7601              	.LC20:
 7602 0350 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 7602      43595F46 
 7602      585F5556 
 7602      435F5354 
 7602      5245414D 
 7603 0376 0000     		.space	2
 7604              	.LC21:
 7605 0378 47657420 		.ascii	"Get UVC still Prob(set) control %d \015\012\000"
 7605      55564320 
 7605      7374696C 
 7605      6C205072 
 7605      6F622873 
 7606 039e 0000     		.space	2
 7607              	.LC22:
 7608 03a0 25642025 		.ascii	"%d %d %d %d %d %d %d %d %d %d %d\015\012\000"
 7608      64202564 
 7608      20256420 
 7608      25642025 
 7608      64202564 
 7609 03c3 00       		.space	1
 7610              	.LC23:
 7611 03c4 47657420 		.ascii	"Get UVC still commit(set) control %d \015\012\000"
 7611      55564320 
 7611      7374696C 
 7611      6C20636F 
 7611      6D6D6974 
 7612              	.LC24:
 7613 03ec 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 7613      43595F46 
 7613      585F5556 
 7613      435F5354 
 7613      494C5F45 
 7614              	.LC25:
 7615 0410 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 7615      55564320 
 7615      7374696C 
 7615      6C207472 
 7615      69676765 
 7616 0439 000000   		.space	3
 7617              	.LC26:
 7618 043c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 7618      7374696C 
 7618      6C207472 
 7618      69676765 
 7618      7220636F 
 7619 0463 00       		.space	1
 7620              	.LC27:
 7621 0464 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 7621      65642074 
 7621      6F207365 
 7621      6E642069 
 7621      6E746572 
 7622 0495 0A00     		.ascii	"\012\000"
 7623 0497 00       		.space	1
 7624              	.LC28:
 7625 0498 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 7625      6F6D6D69 
 7625      74656F66 
 7625      20737461 
 7625      7465203D 
 7626              	.LC29:
 7627 04b0 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 7627      6E656C20 
 7627      53657420 
 7627      57726170 
 7627      55702066 
 7628 04dd 000000   		.space	3
 7629              	.LC30:
 7630 04e0 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 7630      69742045 
 7630      4F462066 
 7630      61696C65 
 7630      64210A00 
 7631              	.LC31:
 7632 04f4 49324320 		.ascii	"I2C initialization failed!\012\000"
 7632      696E6974 
 7632      69616C69 
 7632      7A617469 
 7632      6F6E2066 
 7633              	.LC32:
 7634 0510 49324320 		.ascii	"I2C configuration failed!\012\000"
 7634      636F6E66 
 7634      69677572 
 7634      6174696F 
 7634      6E206661 
 7635 052b 00       		.space	1
 7636              	.LC33:
 7637 052c 55415254 		.ascii	"UART initialization failed!\012\000"
 7637      20696E69 
 7637      7469616C 
 7637      697A6174 
 7637      696F6E20 
 7638 0549 000000   		.space	3
 7639              	.LC34:
 7640 054c 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 7640      43726561 
 7640      74652045 
 7640      76656E74 
 7640      20666169 
 7641 0576 0000     		.space	2
 7642              	.LC35:
 7643 0578 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 7643      20496E69 
 7643      74206661 
 7643      696C6564 
 7643      2C204572 
 7644 059b 00       		.space	1
 7645              	.LC36:
 7646 059c 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 7646      204F7665 
 7646      72726964 
 7646      65206661 
 7646      696C6564 
 7647 05c3 00       		.space	1
 7648              	.LC37:
 7649 05c4 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 7649      28323029 
 7649      204F7665 
 7649      72726964 
 7649      65206661 
 7650 05ef 00       		.space	1
 7651              	.LC38:
 7652 05f0 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 7652      28323429 
 7652      204F7665 
 7652      72726964 
 7652      65206661 
 7653 061b 00       		.space	1
 7654              	.LC39:
 7655 061c 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 7655      20536574 
 7655      20287265 
 7655      73657420 
 7655      32322920 
 7656 064e 00       		.ascii	"\000"
 7657 064f 00       		.space	1
 7658              	.LC40:
 7659 0650 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 7659      20536574 
 7659      2028706F 
 7659      77657220 
 7659      32302920 
 7660 0682 00       		.ascii	"\000"
 7661 0683 00       		.space	1
 7662              	.LC41:
 7663 0684 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 7663      20536574 
 7663      2028736E 
 7663      61702073 
 7663      686F7420 
 7664 06b7 25640A00 		.ascii	"%d\012\000"
 7665 06bb 00       		.space	1
 7666              	.LC42:
 7667 06bc 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 7667      46756E63 
 7667      74696F6E 
 7667      20466169 
 7667      6C656420 
 7668 06eb 00       		.space	1
 7669              	.LC43:
 7670 06ec 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 7670      46756E63 
 7670      74696F6E 
 7670      20466169 
 7670      6C656420 
 7671 071b 00       		.space	1
 7672              	.LC44:
 7673 071c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 7673      436F6E6E 
 7673      65637420 
 7673      6661696C 
 7673      65642C20 
 7674 0741 000000   		.space	3
 7675              	.LC45:
 7676 0744 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 7676      53657420 
 7676      456E6470 
 7676      6F696E74 
 7676      20636F6E 
 7677 0774 00       		.ascii	"\000"
 7678 0775 000000   		.space	3
 7679              	.LC46:
 7680 0778 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 7680      496E7465 
 7680      72727570 
 7680      74205374 
 7680      61747573 
 7681 07ab 20436F64 		.ascii	" Code = %d\012\000"
 7681      65203D20 
 7681      25640A00 
 7682 07b7 00       		.space	1
 7683              	.LC47:
 7684 07b8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 7684      65642074 
 7684      6F20616C 
 7684      6C6F6361 
 7684      7465206D 
 7685 07eb 65720D0A 		.ascii	"er\015\012\000"
 7685      00
 7686              	.LC48:
 7687 07f0 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 7687      4368616E 
 7687      6E656C20 
 7687      43726561 
 7687      74696F6E 
 7688 081e 0000     		.space	2
 7689              	.LC49:
 7690 0820 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 7690      74686520 
 7690      76696465 
 7690      6F206D6F 
 7690      64652066 
 7691 0842 0000     		.space	2
 7692              	.LC50:
 7693 0844 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 7693      4368616E 
 7693      6E656C20 
 7693      52657365 
 7693      74204661 
 7694 086f 00       		.space	1
 7695              	.LC51:
 7696 0870 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 7696      4368616E 
 7696      6E656C20 
 7696      53657420 
 7696      5472616E 
 7697 08a1 00       		.ascii	"\000"
 7698 08a2 0000     		.space	2
 7699              	.LC52:
 7700 08a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 7700      4368616E 
 7700      6E656C20 
 7700      53657420 
 7700      5472616E 
 7701 08d5 0A00     		.ascii	"\012\000"
 7702 08d7 00       		.space	1
 7703              	.LC53:
 7704 08d8 0D0A2073 		.ascii	"\015\012 super gpif\000"
 7704      75706572 
 7704      20677069 
 7704      6600
 7705 08e6 0000     		.space	2
 7706              	.LC54:
 7707 08e8 0D0A2068 		.ascii	"\015\012 high gpif\000"
 7707      69676820 
 7707      67706966 
 7707      00
 7708 08f5 000000   		.space	3
 7709              	.LC55:
 7710 08f8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 7710      696E6720 
 7710      47504946 
 7710      20436F6E 
 7710      66696775 
 7711 092b 0A00     		.ascii	"\012\000"
 7712 092d 000000   		.space	3
 7713              	.LC56:
 7714 0930 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 7714      74696E67 
 7714      20475049 
 7714      46207374 
 7714      61746520 
 7715 0963 0D0A00   		.ascii	"\015\012\000"
 7716 0966 0000     		.space	2
 7717              	.LC57:
 7718 0968 33303A55 		.ascii	"30:UVC App Thread\000"
 7718      56432041 
 7718      70702054 
 7718      68726561 
 7718      6400
 7719 097a 0000     		.space	2
 7720              	.LC58:
 7721 097c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 7721      56432041 
 7721      70702045 
 7721      50302054 
 7721      68726561 
 7722 0992 0000     		.space	2
 7723              	.LC59:
 7724 0994 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 7724      32432041 
 7724      70702043 
 7724      54524C20 
 7724      54687265 
 7725 09ab 00       		.bss
 7726              		.align	2
 7727              		.set	.LANCHOR0,. + 0
 7730              	glFxUVCEvent:
 7731 0000 00000000 		.space	40
 7731      00000000 
 7731      00000000 
 7731      00000000 
 7731      00000000 
 7734              	timercount:
 7735 0028 00       		.space	1
 7736 0029 000000   		.space	3
 7739              	curFlag:
 7740 002c 00000000 		.space	64
 7740      00000000 
 7740      00000000 
 7740      00000000 
 7740      00000000 
 7743              	fb:
 7744 006c 0000     		.space	2
 7747              	pb:
 7748 006e 0000     		.space	2
 7751              	pbc:
 7752 0070 0000     		.space	2
 7753 0072 0000     		.space	2
 7756              	stiflag:
 7757 0074 00000000 		.space	4
 7760              	hitFV:
 7761 0078 00000000 		.space	4
 7764              	prodCount:
 7765 007c 0000     		.space	2
 7768              	consCount:
 7769 007e 0000     		.space	2
 7772              	streamingStarted:
 7773 0080 00000000 		.space	4
 7776              	gpif_initialized:
 7777 0084 00000000 		.space	4
 7780              	isUsbConnected:
 7781 0088 00000000 		.space	4
 7784              	glIsConfigured:
 7785 008c 00000000 		.space	4
 7788              	glIsApplnActive:
 7789 0090 00000000 		.space	4
 7792              	clearFeatureRqtReceived:
 7793 0094 00000000 		.space	4
 7796              	glEp0Buffer:
 7797 0098 00000000 		.space	32
 7797      00000000 
 7797      00000000 
 7797      00000000 
 7797      00000000 
 7800              	usbSpeed:
 7801 00b8 00       		.space	1
 7802 00b9 000000   		.space	3
 7805              	glCommitCtrl:
 7806 00bc 00000000 		.space	32
 7806      00000000 
 7806      00000000 
 7806      00000000 
 7806      00000000 
 7809              	setRes:
 7810 00dc 00       		.space	1
 7813              	IMcount.8012:
 7814 00dd 00       		.space	1
 7815 00de 0000     		.space	2
 7818              	uvcAppThread:
 7819 00e0 00000000 		.space	168
 7819      00000000 
 7819      00000000 
 7819      00000000 
 7819      00000000 
 7822              	uvcAppEP0Thread:
 7823 0188 00000000 		.space	168
 7823      00000000 
 7823      00000000 
 7823      00000000 
 7823      00000000 
 7826              	i2cAppThread:
 7827 0230 00000000 		.space	168
 7827      00000000 
 7827      00000000 
 7827      00000000 
 7827      00000000 
 7830              	WDRflag:
 7831 02d8 00000000 		.space	4
 7834              	pbcpbak:
 7835 02dc 0000     		.space	2
 7838              	pbcbak:
 7839 02de 0000     		.space	2
 7842              	pbbak:
 7843 02e0 0000     		.space	2
 7846              	fbbak:
 7847 02e2 0000     		.space	2
 7850              	testSnap:
 7851 02e4 00       		.space	1
 7852 02e5 000000   		.text
 7853              	.Letext0:
 7854              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 7855              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 7856              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 7857              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 7858              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 7859              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 7860              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 7861              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 7862              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7863              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7864              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7865              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7866              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7867              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7868              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7869              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 7870              		.file 18 "../cmdqu.h"
 7871              		.file 19 "../uvc.h"
 7872              		.file 20 "../cyfxgpif2config.h"
 7873              		.file 21 "../cyfxgpif2config_usb2_720.h"
 7874              		.file 22 "../sensor.h"
 7875              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:38     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:42     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:45     .text:00000014 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:205    .text:0000015c $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:211    .text:0000016c $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:320    .text:00000244 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:332    .text:00000268 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:335    .text:00000268 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:567    .text:00000400 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:577    .text:0000041c $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:579    .text:0000041c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:614    .text:0000044c $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:622    .text:00000464 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:807    .text:000005d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:816    .text:000005e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:818    .text:000005e8 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1193   .text:000008e0 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000002 wValue
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1212   .text:00000910 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1215   .text:00000910 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1229   .text:00000914 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1574   .text:00000bfc $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1584   .text:00000c18 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1587   .text:00000c18 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1631   .text:00000c5c $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1636   .text:00000c64 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1639   .text:00000c64 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1667   .text:00000c80 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1671   .text:00000c84 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1674   .text:00000c84 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1739   .text:00000cf4 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:1747   .text:00000d04 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:3544   .text:00001c84 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000ac glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:3579   .text:00001cf4 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4508   .text:00002200 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4540   .text:00002234 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4553   .text:00002260 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4558   .text:00002270 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4563   .text:00002280 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4610   .text:000022d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4620   .text:000022ec $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4623   .text:000022ec CyFxUVCApplnI2CInit
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4692   .text:00002358 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4698   .text:00002364 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:4701   .text:00002364 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:5838   .text:00002c9c $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:5893   .text:00002d64 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:5896   .text:00002d64 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6062   .text:00002ecc $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6079   .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6082   .text.startup:00000000 main
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7784   .bss:0000008c glIsConfigured
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7788   .bss:00000090 glIsApplnActive
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6899   .data:00000300 glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6959   .data:00000334 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6977   .data:00000340 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6944   .data:00000328 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6914   .data:0000030c glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7772   .bss:00000080 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7792   .bss:00000094 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7800   .bss:000000b8 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7780   .bss:00000088 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7834   .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7838   .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7842   .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7846   .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7751   .bss:00000070 pbc
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7747   .bss:0000006e pb
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7743   .bss:0000006c fb
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7850   .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6973   .data:0000033f snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6240   .rodata:0000001c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7007   .data:0000035c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7086   .data:0000048c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7237   .data:00000520 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7348   .data:000006d0 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6227   .rodata:00000000 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7359   .data:000006e0 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7438   .data:00000810 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7457   .data:00000820 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7532   .data:00000940 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6223   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6252   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:6256   .data:00000000 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7539   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7726   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7730   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7734   .bss:00000028 timercount
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7739   .bss:0000002c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7756   .bss:00000074 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7760   .bss:00000078 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7764   .bss:0000007c prodCount
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7768   .bss:0000007e consCount
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7776   .bss:00000084 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7796   .bss:00000098 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7805   .bss:000000bc glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7809   .bss:000000dc setRes
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7813   .bss:000000dd IMcount.8012
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7818   .bss:000000e0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7822   .bss:00000188 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7826   .bss:00000230 i2cAppThread
C:\Users\wcheng\AppData\Local\Temp\ccdBRevJ.s:7830   .bss:000002d8 WDRflag
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_event_flags_set
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
memset
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
cmdSet
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetWrapUp
CyU3PI2cInit
CyU3PI2cSetConfig
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PConnectState
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
