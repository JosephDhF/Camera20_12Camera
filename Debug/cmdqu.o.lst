   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"cmdqu.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	creatqu
  19              	creatqu:
  20              	.LFB0:
  21              		.file 1 "../cmdqu.c"
   1:../cmdqu.c    **** /*********************************************************
   2:../cmdqu.c    ****  * The cmdqu.c for the ring buffer that can be used any case that needs a buffer.
   3:../cmdqu.c    ****  * Copyright Videology Imaging Solution Inc. 2013
   4:../cmdqu.c    ****  * All Rights Reserved
   5:../cmdqu.c    ****  *
   6:../cmdqu.c    ****  *  Created on: Oct 30, 2013
   7:../cmdqu.c    ****  *  Author: wcheng
   8:../cmdqu.c    ****  *
   9:../cmdqu.c    ****  *  it's used to create a ring buffer for the commands queue for buffering the host
  10:../cmdqu.c    ****  *  commands. it improves the commands performace.
  11:../cmdqu.c    ****  *********************************************************/
  12:../cmdqu.c    **** 
  13:../cmdqu.c    **** #include <cyu3system.h>
  14:../cmdqu.c    **** #include <cyu3os.h>
  15:../cmdqu.c    **** #include <cyu3usb.h>
  16:../cmdqu.c    **** #include "uvc.h"
  17:../cmdqu.c    **** #include "sensor.h"
  18:../cmdqu.c    **** #include "cmdqu.h"
  19:../cmdqu.c    **** 
  20:../cmdqu.c    **** static uint16_t DelayArray[64] = {
  21:../cmdqu.c    **** 		700, //0: BLC
  22:../cmdqu.c    **** 		260, //1: Brightness
  23:../cmdqu.c    **** 		260, //2: Contrast
  24:../cmdqu.c    **** 		260, //3: 0
  25:../cmdqu.c    **** 		700, //4: MainFreq
  26:../cmdqu.c    **** 		260, //5: Hue
  27:../cmdqu.c    **** 		260, //6: Saturation
  28:../cmdqu.c    **** 		260, //7: Sharpness
  29:../cmdqu.c    **** 		260, //8: 0
  30:../cmdqu.c    **** 		260, //9: WBMode
  31:../cmdqu.c    **** 		260, //A: 0
  32:../cmdqu.c    **** 		260, //B: WBComp
  33:../cmdqu.c    **** 		260, //C: 0
  34:../cmdqu.c    **** 		260, //D: 0
  35:../cmdqu.c    **** 		260, //E: DigZoom
  36:../cmdqu.c    **** 		260, //F: 0
  37:../cmdqu.c    **** 		700, //10: Shutter
  38:../cmdqu.c    **** 		700, //11: SenseUp
  39:../cmdqu.c    **** 		400, //12: MirrMode
  40:../cmdqu.c    **** 		300, //13: NoiRedu3DMod
  41:../cmdqu.c    **** 		300, //14: NoiRedu3DLev
  42:../cmdqu.c    **** 		300, //15: DayNightMod
  43:../cmdqu.c    **** 		300, //16: DayNightDly
  44:../cmdqu.c    **** 		260, //17: DayNightLev
  45:../cmdqu.c    **** 		260, //18: NightDayLev
  46:../cmdqu.c    **** 		700, //19: AExModee
  47:../cmdqu.c    **** 		700, //1A: AExReferleve
  48:../cmdqu.c    **** 		260, //1B: 0
  49:../cmdqu.c    **** 		700, //1C: SensorMode
  50:../cmdqu.c    **** 		260, //1D: 0
  51:../cmdqu.c    **** 		500, //1E: SevePars
  52:../cmdqu.c    **** 		260, //1F: 0
  53:../cmdqu.c    **** 		260, //20: Iris auto (AF Lens)
  54:../cmdqu.c    **** 		260, //21: Iris auto (non AF Lens)
  55:../cmdqu.c    **** 		400, //22: Iris value (DC manual)
  56:../cmdqu.c    **** 		400, //23: Iris value (DC manual)
  57:../cmdqu.c    **** 		400, //24: BLCRange
  58:../cmdqu.c    **** 		260, //25: BLCWeight
  59:../cmdqu.c    **** 		260, //26: BLCGrid
  60:../cmdqu.c    **** 		260, //27: 0
  61:../cmdqu.c    **** 		260, //28: 0
  62:../cmdqu.c    **** 		260, //29: 0
  63:../cmdqu.c    **** 		260, //2A: 0
  64:../cmdqu.c    **** 		260, //2B: 0
  65:../cmdqu.c    **** 		0
  66:../cmdqu.c    **** 
  67:../cmdqu.c    **** };
  68:../cmdqu.c    **** 
  69:../cmdqu.c    **** void creatqu(uint8_t para){
  22              		.loc 1 69 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
  28              		.loc 1 69 0
  29 0000 0020A0E1 		mov	r2, r0
  70:../cmdqu.c    **** 	CyU3PDebugPrint (4, "The test cmdqu %d \r\n", para); // additional debug
  30              		.loc 1 70 0
  31 0004 04109FE5 		ldr	r1, .L2
  32 0008 0400A0E3 		mov	r0, #4
  33              	.LVL1:
  34 000c FEFFFFEA 		b	CyU3PDebugPrint
  35              	.LVL2:
  36              	.L3:
  37              		.align	2
  38              	.L2:
  39 0010 00000000 		.word	.LC0
  40              		.cfi_endproc
  41              	.LFE0:
  43              		.align	2
  44              		.global	cmdquTest
  46              	cmdquTest:
  47              	.LFB1:
  71:../cmdqu.c    **** }
  72:../cmdqu.c    **** 
  73:../cmdqu.c    **** /**** it's used test the cmdqu data structure. */
  74:../cmdqu.c    **** void  cmdquTest(VdRingBuf *cmdbuf, uint8_t state){
  48              		.loc 1 74 0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 0
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52              	.LVL3:
  53 0014 30402DE9 		stmfd	sp!, {r4, r5, lr}
  54              	.LCFI0:
  55              		.cfi_def_cfa_offset 12
  56              		.cfi_offset 4, -12
  57              		.cfi_offset 5, -8
  58              		.cfi_offset 14, -4
  75:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
  76:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
  77:../cmdqu.c    **** 	CyU3PDebugPrint (4, "Command Queue %s state %d\r\n", cmdbuf->bufferName, state);
  59              		.loc 1 77 0
  60 0018 042090E5 		ldr	r2, [r0, #4]
  74:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
  61              		.loc 1 74 0
  62 001c 0040A0E1 		mov	r4, r0
  63 0020 14D04DE2 		sub	sp, sp, #20
  64              	.LCFI1:
  65              		.cfi_def_cfa_offset 32
  74:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
  66              		.loc 1 74 0
  67 0024 0130A0E1 		mov	r3, r1
  68              		.loc 1 77 0
  69 0028 0400A0E3 		mov	r0, #4
  70              	.LVL4:
  71 002c 80109FE5 		ldr	r1, .L8
  72              	.LVL5:
  73 0030 FEFFFFEB 		bl	CyU3PDebugPrint
  74              	.LVL6:
  78:../cmdqu.c    **** 	CyU3PDebugPrint (4, "Command Queue check queueID %d startAdd 0x%x endAdd 0x%x write 0x%x read 0x%x
  75              		.loc 1 78 0
  76 0034 100094E5 		ldr	r0, [r4, #16]
  77 0038 1A10D4E5 		ldrb	r1, [r4, #26]	@ zero_extendqisi2
  78 003c 0CE094E5 		ldr	lr, [r4, #12]
  79 0040 14C094E5 		ldr	ip, [r4, #20]
  80 0044 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
  81 0048 083094E5 		ldr	r3, [r4, #8]
  82 004c 08008DE5 		str	r0, [sp, #8]
  83 0050 0C108DE5 		str	r1, [sp, #12]
  84 0054 00E08DE5 		str	lr, [sp]
  85 0058 04C08DE5 		str	ip, [sp, #4]
  86 005c 0400A0E3 		mov	r0, #4
  87 0060 50109FE5 		ldr	r1, .L8+4
  88 0064 FEFFFFEB 		bl	CyU3PDebugPrint
  89              	.LVL7:
  79:../cmdqu.c    **** 			cmdbuf->ringbufID, cmdbuf->startAdd, cmdbuf->endAdd, cmdbuf->writePtr, cmdbuf->readPtr, cmdbuf->
  80:../cmdqu.c    **** 	lcCmdDes = cmdbuf->startAdd;
  90              		.loc 1 80 0
  91 0068 084094E5 		ldr	r4, [r4, #8]
  92              	.LVL8:
  93 006c 0050A0E3 		mov	r5, #0
  94              	.LVL9:
  95              	.L6:
  81:../cmdqu.c    **** 	for(cmdQuIdx = 0; cmdQuIdx < 0x10/*MAXCMD*/; cmdQuIdx++){
  82:../cmdqu.c    **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d cmdf
  96              		.loc 1 82 0 discriminator 2
  97 0070 383094E5 		ldr	r3, [r4, #56]
  98 0074 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
  99 0078 00308DE5 		str	r3, [sp]
 100 007c 343094E5 		ldr	r3, [r4, #52]
 101 0080 0400A0E3 		mov	r0, #4
 102 0084 28008DE9 		stmib	sp, {r3, r5}
 103 0088 3C3094E5 		ldr	r3, [r4, #60]
 104 008c 015085E2 		add	r5, r5, #1
 105              	.LVL10:
 106 0090 0C308DE5 		str	r3, [sp, #12]
 107 0094 20109FE5 		ldr	r1, .L8+8
 108 0098 0430A0E1 		mov	r3, r4
 109 009c FEFFFFEB 		bl	CyU3PDebugPrint
 110              	.LVL11:
  81:../cmdqu.c    **** 	for(cmdQuIdx = 0; cmdQuIdx < 0x10/*MAXCMD*/; cmdQuIdx++){
 111              		.loc 1 81 0 discriminator 2
 112 00a0 100055E3 		cmp	r5, #16
  83:../cmdqu.c    **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx, lcCmdDes->
  84:../cmdqu.c    **** 		lcCmdDes += 1;
 113              		.loc 1 84 0 discriminator 2
 114 00a4 404084E2 		add	r4, r4, #64
 115              	.LVL12:
  81:../cmdqu.c    **** 	for(cmdQuIdx = 0; cmdQuIdx < 0x10/*MAXCMD*/; cmdQuIdx++){
 116              		.loc 1 81 0 discriminator 2
 117 00a8 F0FFFF1A 		bne	.L6
  85:../cmdqu.c    **** 	}
  86:../cmdqu.c    **** 
  87:../cmdqu.c    **** 	return;
  88:../cmdqu.c    **** }
 118              		.loc 1 88 0
 119 00ac 14D08DE2 		add	sp, sp, #20
 120              		@ sp needed
 121 00b0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 122              	.LVL13:
 123              	.L9:
 124              		.align	2
 125              	.L8:
 126 00b4 18000000 		.word	.LC1
 127 00b8 34000000 		.word	.LC2
 128 00bc 94000000 		.word	.LC3
 129              		.cfi_endproc
 130              	.LFE1:
 132              		.align	2
 133              		.global	cmdbufCreate
 135              	cmdbufCreate:
 136              	.LFB2:
  89:../cmdqu.c    **** 
  90:../cmdqu.c    **** /***** create a command buffer. *******/
  91:../cmdqu.c    **** VdRingBuf  cmdbufCreate(uint16_t size, CyU3PMutex *muxPtr){
 137              		.loc 1 91 0
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 0
 140              		@ frame_needed = 0, uses_anonymous_args = 0
 141              	.LVL14:
 142 00c0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 143              	.LCFI2:
 144              		.cfi_def_cfa_offset 16
 145              		.cfi_offset 4, -16
 146              		.cfi_offset 5, -12
 147              		.cfi_offset 6, -8
 148              		.cfi_offset 14, -4
 149              		.loc 1 91 0
 150 00c4 0040A0E1 		mov	r4, r0
  92:../cmdqu.c    **** 	VdRingBuf cmdque;
  93:../cmdqu.c    **** 
  94:../cmdqu.c    **** 	cmdque.startAdd = CyU3PMemAlloc(sizeof(VdcmdDes)*(MAXCMD));    //allocate memory for command queue
 151              		.loc 1 94 0
 152 00c8 010AA0E3 		mov	r0, #4096
 153              	.LVL15:
  91:../cmdqu.c    **** 	VdRingBuf cmdque;
 154              		.loc 1 91 0
 155 00cc 0250A0E1 		mov	r5, r2
 156              		.loc 1 94 0
 157 00d0 FEFFFFEB 		bl	CyU3PMemAlloc
 158              	.LVL16:
  95:../cmdqu.c    **** 	cmdque.bugFlag = CyFalse;  // set command queue unavailable.
  96:../cmdqu.c    **** 	cmdque.bufferName = "I2C command queue";
  97:../cmdqu.c    **** 	cmdque.ringbufID = CMDQU0;
  98:../cmdqu.c    **** 	cmdque.numUnit = MAXCMD;
  99:../cmdqu.c    **** 	cmdque.endAdd = cmdque.startAdd + MAXCMD;  //the read pointer is initialed one command unit behind
 100:../cmdqu.c    **** 	//cmdque.ringMux = CyU3PMemAlloc(sizeof(CyU3PMutex));
 101:../cmdqu.c    **** 	cmdque.ringMux = muxPtr;
 102:../cmdqu.c    **** 	CyU3PMutexCreate(cmdque.ringMux, CYU3P_NO_INHERIT);
 159              		.loc 1 102 0
 160 00d4 0010A0E3 		mov	r1, #0
 161 00d8 0120A0E1 		mov	r2, r1
 162 00dc 3830A0E3 		mov	r3, #56
  94:../cmdqu.c    **** 	cmdque.bugFlag = CyFalse;  // set command queue unavailable.
 163              		.loc 1 94 0
 164 00e0 0060A0E1 		mov	r6, r0
 165              	.LVL17:
 166              		.loc 1 102 0
 167 00e4 0500A0E1 		mov	r0, r5
 168              	.LVL18:
 169 00e8 FEFFFFEB 		bl	_txe_mutex_create
 170              	.LVL19:
 103:../cmdqu.c    **** 	return cmdque;
 171              		.loc 1 103 0
 172 00ec 2C109FE5 		ldr	r1, .L11
  99:../cmdqu.c    **** 	//cmdque.ringMux = CyU3PMemAlloc(sizeof(CyU3PMutex));
 173              		.loc 1 99 0
 174 00f0 010A86E2 		add	r0, r6, #4096
 175              	.LVL20:
 176              		.loc 1 103 0
 177 00f4 0030A0E3 		mov	r3, #0
 178 00f8 4020A0E3 		mov	r2, #64
 179 00fc 0C0084E5 		str	r0, [r4, #12]
 180 0100 086084E5 		str	r6, [r4, #8]
 181 0104 1C5084E5 		str	r5, [r4, #28]
 182 0108 041084E5 		str	r1, [r4, #4]
 183 010c B821C4E1 		strh	r2, [r4, #24]	@ movhi
 184 0110 0030C4E5 		strb	r3, [r4]
 185 0114 1A30C4E5 		strb	r3, [r4, #26]
 104:../cmdqu.c    **** }
 186              		.loc 1 104 0
 187 0118 0400A0E1 		mov	r0, r4
 188              	.LVL21:
 189 011c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 190              	.L12:
 191              		.align	2
 192              	.L11:
 193 0120 EC000000 		.word	.LC4
 194              		.cfi_endproc
 195              	.LFE2:
 197              		.align	2
 198              		.global	cmdquInit
 200              	cmdquInit:
 201              	.LFB3:
 105:../cmdqu.c    **** 
 106:../cmdqu.c    **** /**** initialize the command queue  *****/
 107:../cmdqu.c    **** void  cmdquInit(VdRingBuf *cmdqu){
 202              		.loc 1 107 0
 203              		.cfi_startproc
 204              		@ args = 0, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              	.LVL22:
 108:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
 109:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
 110:../cmdqu.c    **** 
 111:../cmdqu.c    **** 	for(lcCmdDes = cmdqu->startAdd; lcCmdDes <= cmdqu->endAdd; lcCmdDes++){
 207              		.loc 1 111 0
 208 0124 083090E5 		ldr	r3, [r0, #8]
 209              	.LVL23:
 210 0128 0C2090E5 		ldr	r2, [r0, #12]
 107:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
 211              		.loc 1 107 0
 212 012c 10402DE9 		stmfd	sp!, {r4, lr}
 213              	.LCFI3:
 214              		.cfi_def_cfa_offset 8
 215              		.cfi_offset 4, -8
 216              		.cfi_offset 14, -4
 217              		.loc 1 111 0
 218 0130 020053E1 		cmp	r3, r2
 107:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
 219              		.loc 1 107 0
 220 0134 0040A0E1 		mov	r4, r0
 221              		.loc 1 111 0
 222 0138 1400008A 		bhi	.L14
 108:../cmdqu.c    **** 	uint16_t cmdQuIdx = 0;
 223              		.loc 1 108 0
 224 013c 0020A0E3 		mov	r2, #0
 225 0140 403083E2 		add	r3, r3, #64
 226              	.LVL24:
 112:../cmdqu.c    **** 		lcCmdDes->CmdID = cmdQuIdx;
 113:../cmdqu.c    **** 		lcCmdDes->cmdFlag = deswait;            //initial the command unavailable
 227              		.loc 1 113 0
 228 0144 02E0A0E1 		mov	lr, r2
 229              	.LVL25:
 230              	.L16:
 112:../cmdqu.c    **** 		lcCmdDes->CmdID = cmdQuIdx;
 231              		.loc 1 112 0
 232 0148 402043E5 		strb	r2, [r3, #-64]
 233              		.loc 1 113 0
 234 014c 04E003E5 		str	lr, [r3, #-4]
 114:../cmdqu.c    **** 		lcCmdDes->cmdDesNext = cmdqu->startAdd + (uint16_t)((cmdQuIdx + 1)&0x3F);
 235              		.loc 1 114 0
 236 0150 011082E2 		add	r1, r2, #1
 237 0154 08C094E5 		ldr	ip, [r4, #8]
 238 0158 0118A0E1 		mov	r1, r1, asl #16
 239 015c 012042E2 		sub	r2, r2, #1
 240              	.LVL26:
 115:../cmdqu.c    **** 		lcCmdDes->cmdDesPrevious = cmdqu->startAdd + (uint16_t)((cmdQuIdx - 1)&0x3F);
 241              		.loc 1 115 0
 242 0160 3F2002E2 		and	r2, r2, #63
 243              	.LVL27:
 114:../cmdqu.c    **** 		lcCmdDes->cmdDesNext = cmdqu->startAdd + (uint16_t)((cmdQuIdx + 1)&0x3F);
 244              		.loc 1 114 0
 245 0164 3F0801E2 		and	r0, r1, #4128768
 246 0168 20058CE0 		add	r0, ip, r0, lsr #10
 247              		.loc 1 115 0
 248 016c 02C38CE0 		add	ip, ip, r2, asl #6
 114:../cmdqu.c    **** 		lcCmdDes->cmdDesNext = cmdqu->startAdd + (uint16_t)((cmdQuIdx + 1)&0x3F);
 249              		.loc 1 114 0
 250 0170 0C0003E5 		str	r0, [r3, #-12]
 251              		.loc 1 115 0
 252 0174 08C003E5 		str	ip, [r3, #-8]
 253              	.LVL28:
 111:../cmdqu.c    **** 		lcCmdDes->CmdID = cmdQuIdx;
 254              		.loc 1 111 0
 255 0178 0C0094E5 		ldr	r0, [r4, #12]
 114:../cmdqu.c    **** 		lcCmdDes->cmdDesNext = cmdqu->startAdd + (uint16_t)((cmdQuIdx + 1)&0x3F);
 256              		.loc 1 114 0
 257 017c 2128A0E1 		mov	r2, r1, lsr #16
 258              	.LVL29:
 111:../cmdqu.c    **** 		lcCmdDes->CmdID = cmdQuIdx;
 259              		.loc 1 111 0
 260 0180 030050E1 		cmp	r0, r3
 261 0184 403083E2 		add	r3, r3, #64
 262              	.LVL30:
 263 0188 EEFFFF2A 		bcs	.L16
 264 018c 083094E5 		ldr	r3, [r4, #8]
 265              	.LVL31:
 266              	.L14:
 116:../cmdqu.c    **** 		if(0/*!cmdQuIdx debug*/) 		CyU3PDebugPrint (4, "Command Queue init 0 cmdID %d CmdDes 0x%x previou
 117:../cmdqu.c    **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, 0, lcCmdDes->cmdFlag
 118:../cmdqu.c    **** 		cmdQuIdx ++;
 119:../cmdqu.c    **** 	}
 120:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 121:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(11) readptr 0x%x next 0x%x previous 0x%x local 0x%x\r\n",
 122:../cmdqu.c    **** 				cmdqu->readPtr, cmdqu->readPtr->cmdDesNext, cmdqu->readPtr->cmdDesPrevious, lcCmdDes);
 123:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(11) writeptr 0x%x next 0x%x previous 0x%x\r\n",
 124:../cmdqu.c    **** 			cmdqu->writePtr, cmdqu->writePtr->cmdDesNext, cmdqu->writePtr->cmdDesPrevious);
 125:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(11) start 0x%x next 0x%x previous 0x%x\r\n",
 126:../cmdqu.c    **** 			cmdqu->startAdd, cmdqu->startAdd->cmdDesNext, cmdqu->startAdd->cmdDesPrevious);
 127:../cmdqu.c    **** #endif
 128:../cmdqu.c    **** 	cmdqu->readPtr = cmdqu->startAdd;
 267              		.loc 1 128 0
 268 0190 103084E5 		str	r3, [r4, #16]
 129:../cmdqu.c    **** 	CyU3PThreadSleep(10);
 269              		.loc 1 129 0
 270 0194 0A00A0E3 		mov	r0, #10
 271 0198 FEFFFFEB 		bl	_tx_thread_sleep
 272              	.LVL32:
 130:../cmdqu.c    **** 	cmdqu->writePtr = cmdqu->readPtr;
 273              		.loc 1 130 0
 274 019c 103094E5 		ldr	r3, [r4, #16]
 131:../cmdqu.c    **** 	CyU3PThreadSleep(10);
 275              		.loc 1 131 0
 276 01a0 0A00A0E3 		mov	r0, #10
 130:../cmdqu.c    **** 	cmdqu->writePtr = cmdqu->readPtr;
 277              		.loc 1 130 0
 278 01a4 143084E5 		str	r3, [r4, #20]
 279              		.loc 1 131 0
 280 01a8 FEFFFFEB 		bl	_tx_thread_sleep
 281              	.LVL33:
 132:../cmdqu.c    **** 	cmdqu->bugFlag = (uint8_t)CyTrue; //command queue available.
 282              		.loc 1 132 0
 283 01ac 0130A0E3 		mov	r3, #1
 284 01b0 1A30C4E5 		strb	r3, [r4, #26]
 285 01b4 1080BDE8 		ldmfd	sp!, {r4, pc}
 286              		.cfi_endproc
 287              	.LFE3:
 289              		.align	2
 290              		.global	cmdbufDestroy
 292              	cmdbufDestroy:
 293              	.LFB4:
 133:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 134:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(12) readptr 0x%x next 0x%x previous 0x%x local 0x%x\r\n",
 135:../cmdqu.c    **** 				cmdqu->readPtr, cmdqu->readPtr->cmdDesNext, cmdqu->readPtr->cmdDesPrevious, lcCmdDes);
 136:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(12) writeptr 0x%x next 0x%x previous 0x%x\r\n",
 137:../cmdqu.c    **** 			cmdqu->writePtr, cmdqu->writePtr->cmdDesNext, cmdqu->writePtr->cmdDesPrevious);
 138:../cmdqu.c    **** 	CyU3PDebugPrint (4, "send a I2C command(12) start 0x%x next 0x%x previous 0x%x\r\n",
 139:../cmdqu.c    **** 			cmdqu->startAdd, cmdqu->startAdd->cmdDesNext, cmdqu->startAdd->cmdDesPrevious);
 140:../cmdqu.c    **** #endif
 141:../cmdqu.c    **** 	return;
 142:../cmdqu.c    **** }
 143:../cmdqu.c    **** 
 144:../cmdqu.c    **** CyBool_t  cmdbufDestroy(VdRingBuf *cmdqu){
 294              		.loc 1 144 0
 295              		.cfi_startproc
 296              		@ args = 0, pretend = 0, frame = 0
 297              		@ frame_needed = 0, uses_anonymous_args = 0
 298              		@ link register save eliminated.
 299              	.LVL34:
 145:../cmdqu.c    **** 	;  //na
 146:../cmdqu.c    **** 	return CyTrue;
 147:../cmdqu.c    **** }
 300              		.loc 1 147 0
 301 01b8 0100A0E3 		mov	r0, #1
 302              	.LVL35:
 303 01bc 1EFF2FE1 		bx	lr
 304              		.cfi_endproc
 305              	.LFE4:
 307              		.align	2
 308              		.global	cmdSet
 310              	cmdSet:
 311              	.LFB5:
 148:../cmdqu.c    **** 
 149:../cmdqu.c    **** /******* set a command into command queue based on the command ID *******/
 150:../cmdqu.c    **** CyBool_t  cmdSet(VdRingBuf *cmdqu, uint8_t cmdID, uint8_t RegAdd, uint8_t DevAdd, uint8_t Data, uin
 312              		.loc 1 150 0
 313              		.cfi_startproc
 314              		@ args = 8, pretend = 0, frame = 0
 315              		@ frame_needed = 0, uses_anonymous_args = 0
 316              	.LVL36:
 317 01c0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 318              	.LCFI4:
 319              		.cfi_def_cfa_offset 16
 320              		.cfi_offset 4, -16
 321              		.cfi_offset 5, -12
 322              		.cfi_offset 6, -8
 323              		.cfi_offset 14, -4
 151:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
 152:../cmdqu.c    **** 
 153:../cmdqu.c    **** 	lcCmdDes = cmdqu->startAdd; //get a command descriptor
 324              		.loc 1 153 0
 325 01c4 084090E5 		ldr	r4, [r0, #8]
 326              	.LVL37:
 150:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
 327              		.loc 1 150 0
 328 01c8 10D04DE2 		sub	sp, sp, #16
 329              	.LCFI5:
 330              		.cfi_def_cfa_offset 32
 154:../cmdqu.c    **** 	lcCmdDes = lcCmdDes + cmdID;
 331              		.loc 1 154 0
 332 01cc 010384E0 		add	r0, r4, r1, asl #6
 333              	.LVL38:
 155:../cmdqu.c    **** 	if(lcCmdDes->cmdFlag != desusing){
 334              		.loc 1 155 0
 335 01d0 3CC090E5 		ldr	ip, [r0, #60]
 154:../cmdqu.c    **** 	lcCmdDes = lcCmdDes + cmdID;
 336              		.loc 1 154 0
 337 01d4 0150A0E1 		mov	r5, r1
 338              		.loc 1 155 0
 339 01d8 0F005CE3 		cmp	ip, #15
 150:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
 340              		.loc 1 150 0
 341 01dc 2060DDE5 		ldrb	r6, [sp, #32]	@ zero_extendqisi2
 342 01e0 24C0DDE5 		ldrb	ip, [sp, #36]	@ zero_extendqisi2
 343              		.loc 1 155 0
 344 01e4 1600000A 		beq	.L20
 156:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->DevAdd = DevAdd;
 157:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->RegAdd = RegAdd;
 158:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->Data = Data;
 159:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->DelayT = DelayArray[cmdID];
 345              		.loc 1 159 0
 346 01e8 60E09FE5 		ldr	lr, .L24
 347 01ec 8110A0E1 		mov	r1, r1, asl #1
 348              	.LVL39:
 349 01f0 B1E09EE1 		ldrh	lr, [lr, r1]
 350 01f4 8C108CE0 		add	r1, ip, ip, asl #1
 351 01f8 811080E0 		add	r1, r0, r1, asl #1
 156:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->DevAdd = DevAdd;
 352              		.loc 1 156 0
 353 01fc 0530C1E5 		strb	r3, [r1, #5]
 354              		.loc 1 159 0
 355 0200 B8E0C1E1 		strh	lr, [r1, #8]	@ movhi
 157:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->Data = Data;
 356              		.loc 1 157 0
 357 0204 0420C1E5 		strb	r2, [r1, #4]
 158:../cmdqu.c    **** 		((lcCmdDes->CmdPar)+dataIdx)->DelayT = DelayArray[cmdID];
 358              		.loc 1 158 0
 359 0208 0660C1E5 		strb	r6, [r1, #6]
 160:../cmdqu.c    **** 		lcCmdDes->NumPara = dataIdx;
 161:../cmdqu.c    **** 		lcCmdDes->curNum = 0;
 162:../cmdqu.c    **** 		lcCmdDes->cmdFlag = desReady;
 163:../cmdqu.c    **** //#ifdef USB_DEBUG_PRINT
 164:../cmdqu.c    **** 		CyU3PDebugPrint (4, "Command Queue set cmdID %d CmdDes 0x%x next 0x%x cmdflag %d dataIdx %d data 
 360              		.loc 1 164 0
 361 020c 34E090E5 		ldr	lr, [r0, #52]
 162:../cmdqu.c    **** //#ifdef USB_DEBUG_PRINT
 362              		.loc 1 162 0
 363 0210 FF10A0E3 		mov	r1, #255
 161:../cmdqu.c    **** 		lcCmdDes->cmdFlag = desReady;
 364              		.loc 1 161 0
 365 0214 0030A0E3 		mov	r3, #0
 366              	.LVL40:
 367              		.loc 1 164 0
 368 0218 0523D4E7 		ldrb	r2, [r4, r5, asl #6]	@ zero_extendqisi2
 369              	.LVL41:
 161:../cmdqu.c    **** 		lcCmdDes->cmdFlag = desReady;
 370              		.loc 1 161 0
 371 021c 0130C0E5 		strb	r3, [r0, #1]
 372              	.LVL42:
 162:../cmdqu.c    **** //#ifdef USB_DEBUG_PRINT
 373              		.loc 1 162 0
 374 0220 3C1080E5 		str	r1, [r0, #60]
 160:../cmdqu.c    **** 		lcCmdDes->NumPara = dataIdx;
 375              		.loc 1 160 0
 376 0224 02C0C0E5 		strb	ip, [r0, #2]
 377              		.loc 1 164 0
 378 0228 0030A0E1 		mov	r3, r0
 379 022c 02108DE9 		stmib	sp, {r1, ip}
 380 0230 1C109FE5 		ldr	r1, .L24+4
 381 0234 00E08DE5 		str	lr, [sp]
 382 0238 0C608DE5 		str	r6, [sp, #12]
 383 023c 0400A0E3 		mov	r0, #4
 384              	.LVL43:
 385 0240 FEFFFFEB 		bl	CyU3PDebugPrint
 386              	.LVL44:
 387              	.L20:
 165:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesNext, lcCmdDes->cmdFlag, dataIdx, Data);
 166:../cmdqu.c    **** //#endif
 167:../cmdqu.c    **** 	}else{
 168:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 169:../cmdqu.c    **** 		CyU3PDebugPrint (4, "Command Queue set fail as transferring cmdID %d CmdDes 0x%x\r\n",
 170:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes);
 171:../cmdqu.c    **** #endif
 172:../cmdqu.c    **** 	}
 173:../cmdqu.c    **** 	return CyTrue;
 174:../cmdqu.c    **** }
 388              		.loc 1 174 0
 389 0244 0100A0E3 		mov	r0, #1
 390 0248 10D08DE2 		add	sp, sp, #16
 391              		@ sp needed
 392 024c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 393              	.LVL45:
 394              	.L25:
 395              		.align	2
 396              	.L24:
 397 0250 00000000 		.word	.LANCHOR0
 398 0254 00010000 		.word	.LC5
 399              		.cfi_endproc
 400              	.LFE5:
 402              		.align	2
 403              		.global	statGet
 405              	statGet:
 406              	.LFB6:
 175:../cmdqu.c    **** 
 176:../cmdqu.c    **** #if 0 // alternate putting queue approach
 177:../cmdqu.c    **** /******* set a command into command queue based on write pointer *******/
 178:../cmdqu.c    **** CyBool_t  cmdSet(VdRingBuf *cmdqu, uint8_t RegAdd, uint8_t DevAdd, uint8_t Data){
 179:../cmdqu.c    **** 	VdcmdDes *lcCmdDes;
 180:../cmdqu.c    **** 
 181:../cmdqu.c    **** 	lcCmdDes = cmdqu->writePtr; //get a command descriptor
 182:../cmdqu.c    **** 	CyU3PDebugPrint (4, "Command Queue init 0 cmdID %d CmdDes 0x%x previous 0x%x next 0x%x qunext 0x%x
 183:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdqu->writePtr->cm
 184:../cmdqu.c    **** 	//cmdquTest(cmdqu, 0);
 185:../cmdqu.c    **** 	if(lcCmdDes == cmdqu->readPtr){//at first state.
 186:../cmdqu.c    **** 		if(lcCmdDes->cmdFlag == deswait){//the writing available
 187:../cmdqu.c    **** 			lcCmdDes->DevAdd = DevAdd;
 188:../cmdqu.c    **** 			lcCmdDes->RegAdd = RegAdd;
 189:../cmdqu.c    **** 			lcCmdDes->Data[0] = Data;
 190:../cmdqu.c    **** 			lcCmdDes->curNum = 0;
 191:../cmdqu.c    **** 			lcCmdDes->cmdFlag = desReady;
 192:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 193:../cmdqu.c    **** 			CyU3PDebugPrint (4, "CmdQu first state cmdID %d CmdDes 0x%x reader 0x%x next 0x%x\r\n",
 194:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes, cmdqu->readPtr, lcCmdDes->cmdDesNext);
 195:../cmdqu.c    **** #endif
 196:../cmdqu.c    **** 			cmdqu->writePtr = lcCmdDes->cmdDesNext;
 197:../cmdqu.c    **** 
 198:../cmdqu.c    **** 		}else{ //queue fullness
 199:../cmdqu.c    **** 			CyU3PDebugPrint (4, "CmdQu fullness cmdID %d CmdDes 0x%x reader 0x%x\r\n",
 200:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes, cmdqu->readPtr);
 201:../cmdqu.c    **** 			return 0;
 202:../cmdqu.c    **** 		}
 203:../cmdqu.c    **** 	}else{ //in normal state
 204:../cmdqu.c    **** 		//the command descriptor is available.
 205:../cmdqu.c    **** 		if(lcCmdDes->cmdFlag == dewait){
 206:../cmdqu.c    **** 			lcCmdDes->DevAdd = DevAdd;
 207:../cmdqu.c    **** 			lcCmdDes->RegAdd = RegAdd;
 208:../cmdqu.c    **** 			lcCmdDes->Data[0] = Data;
 209:../cmdqu.c    **** 			lcCmdDes->curNum = 0;
 210:../cmdqu.c    **** 			lcCmdDes->cmdFlag = desReady;
 211:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 212:../cmdqu.c    **** 			CyU3PDebugPrint (4, "Command descriptor setting cmdID %d nextID %d data %d cmdAdd 0x%x flag %d %
 213:../cmdqu.c    **** 					lcCmdDes->CmdID, lcCmdDes->cmdDesNext->CmdID, lcCmdDes->Data[0], lcCmdDes, cmdqu->writePtr->cm
 214:../cmdqu.c    **** #endif
 215:../cmdqu.c    **** 			cmdqu->writePtr = lcCmdDes->cmdDesNext; // update the command queue writer pointer.
 216:../cmdqu.c    **** 		}else{//reset writer
 217:../cmdqu.c    **** 			while(lcCmdDes != cmdqu->readPtr){
 218:../cmdqu.c    **** 				lcCmdDes = lcCmdDes->cmdDesNext; //update cmdDes.
 219:../cmdqu.c    **** 				if(lcCmdDes->cmdFlag == dewait){
 220:../cmdqu.c    **** 					lcCmdDes->DevAdd = DevAdd;
 221:../cmdqu.c    **** 					lcCmdDes->RegAdd = RegAdd;
 222:../cmdqu.c    **** 					lcCmdDes->Data[0] = Data;
 223:../cmdqu.c    **** 					lcCmdDes->curNum = 0;
 224:../cmdqu.c    **** 					lcCmdDes->cmdFlag = desReady;
 225:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 226:../cmdqu.c    **** 					CyU3PDebugPrint (4, "Command descriptor setting cmdID %d nextID %d data %d cmdAdd 0x%x flag %d
 227:../cmdqu.c    **** 							lcCmdDes->CmdID, lcCmdDes->cmdDesNext->CmdID, lcCmdDes->Data[0], lcCmdDes, cmdqu->writePtr->
 228:../cmdqu.c    **** #endif
 229:../cmdqu.c    **** 					break;
 230:../cmdqu.c    **** 				}
 231:../cmdqu.c    **** 			}
 232:../cmdqu.c    **** 			if(lcCmdDes != cmdqu->readPtr)
 233:../cmdqu.c    **** 				cmdqu->writePtr = lcCmdDes->cmdDesNext; //update writer.
 234:../cmdqu.c    **** 			else cmdqu->writePtr = cmdqu->readPtr; //reset writer.
 235:../cmdqu.c    **** 		}
 236:../cmdqu.c    **** 	}
 237:../cmdqu.c    **** 
 238:../cmdqu.c    **** 	return CyTrue;
 239:../cmdqu.c    **** }
 240:../cmdqu.c    **** #endif
 241:../cmdqu.c    **** 
 242:../cmdqu.c    **** /******* get a state from camera register. *******
 243:../cmdqu.c    ****  * it might be unused, if state request performs immediately
 244:../cmdqu.c    ****  *****/
 245:../cmdqu.c    **** void statGet(VdRingBuf *statqu, uint8_t statID){
 407              		.loc 1 245 0
 408              		.cfi_startproc
 409              		@ args = 0, pretend = 0, frame = 0
 410              		@ frame_needed = 0, uses_anonymous_args = 0
 411              		@ link register save eliminated.
 412              	.LVL46:
 246:../cmdqu.c    **** #if 1 // copy
 247:../cmdqu.c    **** 	VdstateDes *lcStatDes;
 248:../cmdqu.c    **** 	uint8_t Data0, Data1;
 249:../cmdqu.c    **** 	uint8_t sendData[2];
 250:../cmdqu.c    **** 
 251:../cmdqu.c    **** 	lcStatDes = (VdstateDes*)((statqu->startAdd) + statID);//get a state descriptor, and find any avai
 413              		.loc 1 251 0
 414 0258 083090E5 		ldr	r3, [r0, #8]
 415 025c 013383E0 		add	r3, r3, r1, asl #6
 416              	.LVL47:
 252:../cmdqu.c    **** 
 253:../cmdqu.c    **** 	if(lcStatDes->statFlag == 0x0F){//statFlag: 0x00:noCom; 0xFF:cmdready; 0x0F:state ready.
 417              		.loc 1 253 0
 418 0260 3C2093E5 		ldr	r2, [r3, #60]
 419 0264 0F0052E3 		cmp	r2, #15
 420 0268 1EFF2F11 		bxne	lr
 254:../cmdqu.c    **** 		switch(statID){
 421              		.loc 1 254 0
 422 026c 010051E3 		cmp	r1, #1
 423 0270 1000000A 		beq	.L29
 424 0274 050051E3 		cmp	r1, #5
 425 0278 0700000A 		beq	.L30
 255:../cmdqu.c    **** 			case BrgtCtlID1:
 256:../cmdqu.c    **** 					Data0 = lcStatDes->staPar->Data;
 257:../cmdqu.c    **** 					Data1 = ((lcStatDes->staPar)+1)->Data;
 258:../cmdqu.c    **** 					//CtrlParArry[CtrlID][13] = Data0;
 259:../cmdqu.c    **** 					//CtrlParArry[CtrlID][14] = Data1;
 260:../cmdqu.c    **** 					if (Data1&0x2){ //check the sign bit (bit1)
 261:../cmdqu.c    **** 						Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 262:../cmdqu.c    **** 					}else{
 263:../cmdqu.c    **** 						Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 264:../cmdqu.c    **** 					}
 265:../cmdqu.c    **** 					glEp0Buffer[0] = Data1;
 266:../cmdqu.c    **** 					glEp0Buffer[1] = 0;
 267:../cmdqu.c    **** 					break;
 268:../cmdqu.c    **** 				case HueCtlID5:
 269:../cmdqu.c    **** 					Data0 = lcStatDes->staPar->Data;
 270:../cmdqu.c    **** 					glEp0Buffer[0] = Data0 + GREEN_BASE;
 271:../cmdqu.c    **** 					sendData[1] = 0;
 272:../cmdqu.c    **** 					break;
 273:../cmdqu.c    **** 				//case SaturCtlID6:
 274:../cmdqu.c    **** 				//case WBTLevCtlID10:
 275:../cmdqu.c    **** 				default:
 276:../cmdqu.c    **** 					glEp0Buffer[0] = lcStatDes->staPar->Data;
 426              		.loc 1 276 0
 427 027c 0610D3E5 		ldrb	r1, [r3, #6]	@ zero_extendqisi2
 428              	.LVL48:
 429              	.L35:
 430 0280 58309FE5 		ldr	r3, .L36
 277:../cmdqu.c    **** 					glEp0Buffer[1] = 0;
 431              		.loc 1 277 0
 432 0284 0020A0E3 		mov	r2, #0
 276:../cmdqu.c    **** 					glEp0Buffer[1] = 0;
 433              		.loc 1 276 0
 434 0288 0010C3E5 		strb	r1, [r3]
 278:../cmdqu.c    **** 					break;
 279:../cmdqu.c    **** 			 }
 280:../cmdqu.c    **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 435              		.loc 1 280 0
 436 028c 0200A0E3 		mov	r0, #2
 437              	.LVL49:
 438 0290 48109FE5 		ldr	r1, .L36
 277:../cmdqu.c    **** 					break;
 439              		.loc 1 277 0
 440 0294 0120C3E5 		strb	r2, [r3, #1]
 441              		.loc 1 280 0
 442 0298 FEFFFFEA 		b	CyU3PUsbSendEP0Data
 443              	.LVL50:
 444              	.L30:
 270:../cmdqu.c    **** 					sendData[1] = 0;
 445              		.loc 1 270 0
 446 029c 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 447 02a0 38309FE5 		ldr	r3, .L36
 448              	.LVL51:
 449 02a4 802042E2 		sub	r2, r2, #128
 450              		.loc 1 280 0
 451 02a8 0200A0E3 		mov	r0, #2
 452              	.LVL52:
 453 02ac 2C109FE5 		ldr	r1, .L36
 454              	.LVL53:
 270:../cmdqu.c    **** 					sendData[1] = 0;
 455              		.loc 1 270 0
 456 02b0 0020C3E5 		strb	r2, [r3]
 457              	.LVL54:
 458              		.loc 1 280 0
 459 02b4 FEFFFFEA 		b	CyU3PUsbSendEP0Data
 460              	.LVL55:
 461              	.L29:
 257:../cmdqu.c    **** 					//CtrlParArry[CtrlID][13] = Data0;
 462              		.loc 1 257 0
 463 02b8 0C20D3E5 		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 256:../cmdqu.c    **** 					Data1 = ((lcStatDes->staPar)+1)->Data;
 464              		.loc 1 256 0
 465 02bc 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 466              	.LVL56:
 261:../cmdqu.c    **** 					}else{
 467              		.loc 1 261 0
 468 02c0 0213A0E1 		mov	r1, r2, asl #6
 469              	.LVL57:
 260:../cmdqu.c    **** 						Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 470              		.loc 1 260 0
 471 02c4 020012E3 		tst	r2, #2
 263:../cmdqu.c    **** 					}
 472              		.loc 1 263 0
 473 02c8 FF100102 		andeq	r1, r1, #255
 261:../cmdqu.c    **** 					}else{
 474              		.loc 1 261 0
 475 02cc 40100112 		andne	r1, r1, #64
 263:../cmdqu.c    **** 					}
 476              		.loc 1 263 0
 477 02d0 23118101 		orreq	r1, r1, r3, lsr #2
 261:../cmdqu.c    **** 					}else{
 478              		.loc 1 261 0
 479 02d4 23118111 		orrne	r1, r1, r3, lsr #2
 480              	.LVL58:
 263:../cmdqu.c    **** 					}
 481              		.loc 1 263 0
 482 02d8 80108103 		orreq	r1, r1, #128
 483              	.LVL59:
 484 02dc E7FFFFEA 		b	.L35
 485              	.L37:
 486              		.align	2
 487              	.L36:
 488 02e0 00000000 		.word	.LANCHOR1
 489              		.cfi_endproc
 490              	.LFE6:
 492              		.align	2
 493              		.global	cmdFind
 495              	cmdFind:
 496              	.LFB7:
 281:../cmdqu.c    **** #ifdef USB_DEBUG_PRINT
 282:../cmdqu.c    **** 			  CyU3PDebugPrint (4, "Command Queue init 0 cmdID %d CmdDes 0x%x previous 0x%x next 0x%x qunext 
 283:../cmdqu.c    **** 					  lcStatDes->StatID, lcStatDes, lcStatDes->staDesPrevious, lcStatDes->staDesNext, statqu->writ
 284:../cmdqu.c    **** #endif
 285:../cmdqu.c    **** 		}
 286:../cmdqu.c    **** 		lcStatDes++;
 287:../cmdqu.c    **** #endif
 288:../cmdqu.c    **** 	return;
 289:../cmdqu.c    **** }
 290:../cmdqu.c    **** 
 291:../cmdqu.c    **** /******* find a command form command queue ********/
 292:../cmdqu.c    **** VdcmdDes *cmdFind(VdRingBuf *cmdqu, uint8_t cmdID){
 497              		.loc 1 292 0
 498              		.cfi_startproc
 499              		@ args = 0, pretend = 0, frame = 0
 500              		@ frame_needed = 0, uses_anonymous_args = 0
 501              		@ link register save eliminated.
 502              	.LVL60:
 293:../cmdqu.c    **** 	VdcmdDes *cmd = cmdqu->startAdd;
 294:../cmdqu.c    **** 	;  //na
 295:../cmdqu.c    **** 	return cmd;
 296:../cmdqu.c    **** }
 503              		.loc 1 296 0
 504 02e4 080090E5 		ldr	r0, [r0, #8]
 505              	.LVL61:
 506 02e8 1EFF2FE1 		bx	lr
 507              		.cfi_endproc
 508              	.LFE7:
 510              		.section	.rodata
 511              		.align	2
 512              		.set	.LANCHOR0,. + 0
 515              	DelayArray:
 516 0000 BC02     		.short	700
 517 0002 0401     		.short	260
 518 0004 0401     		.short	260
 519 0006 0401     		.short	260
 520 0008 BC02     		.short	700
 521 000a 0401     		.short	260
 522 000c 0401     		.short	260
 523 000e 0401     		.short	260
 524 0010 0401     		.short	260
 525 0012 0401     		.short	260
 526 0014 0401     		.short	260
 527 0016 0401     		.short	260
 528 0018 0401     		.short	260
 529 001a 0401     		.short	260
 530 001c 0401     		.short	260
 531 001e 0401     		.short	260
 532 0020 BC02     		.short	700
 533 0022 BC02     		.short	700
 534 0024 9001     		.short	400
 535 0026 2C01     		.short	300
 536 0028 2C01     		.short	300
 537 002a 2C01     		.short	300
 538 002c 2C01     		.short	300
 539 002e 0401     		.short	260
 540 0030 0401     		.short	260
 541 0032 BC02     		.short	700
 542 0034 BC02     		.short	700
 543 0036 0401     		.short	260
 544 0038 BC02     		.short	700
 545 003a 0401     		.short	260
 546 003c F401     		.short	500
 547 003e 0401     		.short	260
 548 0040 0401     		.short	260
 549 0042 0401     		.short	260
 550 0044 9001     		.short	400
 551 0046 9001     		.short	400
 552 0048 9001     		.short	400
 553 004a 0401     		.short	260
 554 004c 0401     		.short	260
 555 004e 0401     		.short	260
 556 0050 0401     		.short	260
 557 0052 0401     		.short	260
 558 0054 0401     		.short	260
 559 0056 0401     		.short	260
 560 0058 0000     		.short	0
 561 005a 00000000 		.space	38
 561      00000000 
 561      00000000 
 561      00000000 
 561      00000000 
 562              		.section	.rodata.str1.4,"aMS",%progbits,1
 563              		.align	2
 564              	.LC0:
 565 0000 54686520 		.ascii	"The test cmdqu %d \015\012\000"
 565      74657374 
 565      20636D64 
 565      71752025 
 565      64200D0A 
 566 0015 000000   		.space	3
 567              	.LC1:
 568 0018 436F6D6D 		.ascii	"Command Queue %s state %d\015\012\000"
 568      616E6420 
 568      51756575 
 568      65202573 
 568      20737461 
 569              	.LC2:
 570 0034 436F6D6D 		.ascii	"Command Queue check queueID %d startAdd 0x%x endAdd"
 570      616E6420 
 570      51756575 
 570      65206368 
 570      65636B20 
 571 0067 20307825 		.ascii	" 0x%x write 0x%x read 0x%x queueFlag %d\015\012\000"
 571      78207772 
 571      69746520 
 571      30782578 
 571      20726561 
 572 0091 000000   		.space	3
 573              	.LC3:
 574 0094 436F6D6D 		.ascii	"Command Queue check cmdID %d CmdDes 0x%x previous 0"
 574      616E6420 
 574      51756575 
 574      65206368 
 574      65636B20 
 575 00c7 78257820 		.ascii	"x%x next 0x%x Idx %d cmdflag %d\015\012\000"
 575      6E657874 
 575      20307825 
 575      78204964 
 575      78202564 
 576 00e9 000000   		.space	3
 577              	.LC4:
 578 00ec 49324320 		.ascii	"I2C command queue\000"
 578      636F6D6D 
 578      616E6420 
 578      71756575 
 578      6500
 579 00fe 0000     		.space	2
 580              	.LC5:
 581 0100 436F6D6D 		.ascii	"Command Queue set cmdID %d CmdDes 0x%x next 0x%x cm"
 581      616E6420 
 581      51756575 
 581      65207365 
 581      7420636D 
 582 0133 64666C61 		.ascii	"dflag %d dataIdx %d data 0x%x\015\012\000"
 582      67202564 
 582      20646174 
 582      61496478 
 582      20256420 
 583 0153 00       		.bss
 584              		.align	2
 585              		.set	.LANCHOR1,. + 0
 588              	glEp0Buffer:
 589 0000 00000000 		.space	32
 589      00000000 
 589      00000000 
 589      00000000 
 589      00000000 
 590              		.text
 591              	.Letext0:
 592              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 593              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 594              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 595              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 596              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 597              		.file 7 "../cmdqu.h"
 598              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 599              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 600              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 cmdqu.c
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:19     .text:00000000 creatqu
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:39     .text:00000010 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:43     .text:00000014 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:46     .text:00000014 cmdquTest
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:126    .text:000000b4 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:132    .text:000000c0 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:135    .text:000000c0 cmdbufCreate
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:193    .text:00000120 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:197    .text:00000124 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:200    .text:00000124 cmdquInit
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:292    .text:000001b8 cmdbufDestroy
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:310    .text:000001c0 cmdSet
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:397    .text:00000250 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:402    .text:00000258 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:405    .text:00000258 statGet
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:488    .text:000002e0 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:492    .text:000002e4 $a
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:495    .text:000002e4 cmdFind
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:511    .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:515    .rodata:00000000 DelayArray
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:563    .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:584    .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cczFHiHQ.s:588    .bss:00000000 glEp0Buffer
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
CyU3PMemAlloc
_txe_mutex_create
_tx_thread_sleep
CyU3PUsbSendEP0Data
